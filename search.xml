<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux的load_average</title>
    <url>/2021/03/30/Linux%E7%9A%84load-average/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分布式协议之2pc与3pc</title>
    <url>/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8B2pc%E4%B8%8E3pc/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode74.搜索二维矩阵</title>
    <url>/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>题目（LeetCode摘抄）：<br><br>　　编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ol>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ol>
<p>示例1：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="number">13</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">m == <span class="built_in">matrix</span>.<span class="built_in">length</span></span><br><span class="line">n == <span class="built_in">matrix</span>[i].<span class="built_in">length</span></span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">100</span></span><br><span class="line">-<span class="number">104</span> &lt;= <span class="built_in">matrix</span>[i][j], target &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构，java</tag>
      </tags>
  </entry>
  <entry>
    <title>_builtin_expect</title>
    <url>/2021/03/29/builtin-expect/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>今天在看项目代码的时候看到了unliekly和likely的使用，往上追溯代码的时候找到了如下的宏定义：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#if</span> <span class="selector-tag">defined</span> <span class="selector-tag">__GNUC__</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">likely</span>(x) <span class="selector-tag">__builtin_expect</span>((x), <span class="number">1</span>)    </span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">unlikely</span>(x) <span class="selector-tag">__builtin_expect</span>((x), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>对于__builtin_expect因为了解的不多，于是就打算整理下笔记，认真学习下这个宏定义。</p>
<h5 id="builtin-expect作用"><a href="#builtin-expect作用" class="headerlink" title="__builtin_expect作用"></a>__builtin_expect作用</h5><p>该指令是由gcc引入的，其作用是允许程序员将”分支转移”的信息告诉编译器，以便编译器对代码进行优化，来减少指令跳转带来的性能下降问题。<br><br>原型为：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">__builtin_expect(<span class="built_in">exp</span>, <span class="built_in">N</span>)</span><br></pre></td></tr></table></figure>
<p>表示exp==N的概率很大。</p>
<span id="more"></span>
<p><br>这里，我给出一个测试用例来说明下该指令的作用：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> x, y;</span><br><span class="line"> <span class="attribute">if</span>(unlikely(x &gt; <span class="number">0</span>))</span><br><span class="line">    <span class="attribute">y</span> = <span class="number">1</span>; </span><br><span class="line"><span class="attribute">else</span> </span><br><span class="line">    <span class="attribute">y</span> = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>该用例表示x&gt;0为false的概率比较大，即走else分支的概率比较大，因此gcc编译的指令会预先读取 y = -1 这条指令。<br><br>说明：在日常的编码过程中，条件判断都是有偏向性的。比如：在使用if-else结构时，程序员经常通过else分支来补充一些意外性的情况。此时，该程序更多的是期待执行if分支的指令。因此，__builtin_expect指令可以利用该偏向特点提醒编译器在汇编曾进行指令优化。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编译优化，linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeroMQ源码解析之消息存储方式</title>
    <url>/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>ZeroMQ的消息队列主要由yqueue.hpp与ypipe.hpp两个类构成。<br><br>在yqueue中有一个重要的结构体chunk_t，他是yqueue高效的关键因素。内存的申请和释放非常浪费效率，yqueue为了避免频繁的内存操作，每次不会申请一个元素大小的内存空间，而是申请一批，这一批元素就保存在chunk_t结构体中.</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct chunk_t</span><br><span class="line">&#123;</span><br><span class="line">    T values[N]<span class="comment">;</span></span><br><span class="line">    chunk_t *prev<span class="comment">;</span></span><br><span class="line">    chunk_t *next<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>yqueue分别用三个指针和三个游标来记录chunk以及在chunk内有效的数据的索引。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  当对列为空的时候，back poisiton指向一个无效的值，而begin或者end position永远是一个有效值。</span></span><br><span class="line"><span class="comment">//  begin是用来在读取数据的时候使用的；而end是在入队的时候使用的游标</span></span><br><span class="line"><span class="keyword">chunk_t</span> *_begin_chunk;</span><br><span class="line"><span class="keyword">int</span> _begin_pos;</span><br><span class="line"><span class="keyword">chunk_t</span> *_back_chunk;</span><br><span class="line"><span class="keyword">int</span> _back_pos; <span class="comment">// 当队列为空的时候该值</span></span><br><span class="line"><span class="keyword">chunk_t</span> *_end_chunk;</span><br><span class="line"><span class="keyword">int</span> _end_pos;</span><br></pre></td></tr></table></figure>
<p>yqueue还有一个特殊的变量_spare_chunk,这是因为往往生产者和消费者的速率达成一致时，使用_spare_chunk保存刚刚释放的chunk，这样当需要申请新的chunk时就可以直接使用_spare_chunk所记录的chunk了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">atomic_ptr_t</span>&lt;<span class="keyword">chunk_t</span>&gt; _spare_chunk;</span><br></pre></td></tr></table></figure>
<p>yqueue的主要操作有pop、puhs、unpush:</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Adds an element to the back end of the queue.</span></span><br><span class="line">inline void push ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">_back_chunk</span> = <span class="variable">_end_chunk</span>;</span><br><span class="line">    <span class="variable">_back_pos</span> = <span class="variable">_end_pos</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++<span class="variable">_end_pos</span> != N)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    chunk_t *sc = <span class="variable">_spare_chunk</span>.xchg (NULL);</span><br><span class="line">    <span class="keyword">if</span> (sc) &#123;</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next = sc;</span><br><span class="line">        sc-&gt;prev = <span class="variable">_end_chunk</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next = allocate_chunk ();</span><br><span class="line">        alloc_assert (<span class="variable">_end_chunk</span>-&gt;next);</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next-&gt;prev = <span class="variable">_end_chunk</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">_end_chunk</span> = <span class="variable">_end_chunk</span>-&gt;next;</span><br><span class="line">    <span class="variable">_end_pos</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpush是指回滚上一次入队的消息，调用者需要释放回滚的信息的内存。</span></span><br><span class="line">inline void unpush ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  First, move &#x27;back&#x27; one position backwards.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_back_pos</span>)</span><br><span class="line">        --<span class="variable">_back_pos</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_back_pos</span> = N - <span class="number">1</span>;</span><br><span class="line">        <span class="variable">_back_chunk</span> = <span class="variable">_back_chunk</span>-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Now, move &#x27;end&#x27; position backwards. Note that obsolete end chunk</span></span><br><span class="line">    <span class="comment">//  is not used as a spare chunk. The analysis shows that doing so</span></span><br><span class="line">    <span class="comment">//  would require free and atomic operation per chunk deallocated</span></span><br><span class="line">    <span class="comment">//  instead of a simple free.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_end_pos</span>)</span><br><span class="line">        --<span class="variable">_end_pos</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_end_pos</span> = N - <span class="number">1</span>;</span><br><span class="line">        <span class="variable">_end_chunk</span> = <span class="variable">_end_chunk</span>-&gt;prev;</span><br><span class="line">        free (<span class="variable">_end_chunk</span>-&gt;next);</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Removes an element from the front end of the queue.</span></span><br><span class="line">inline void pop ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (++<span class="variable">_begin_pos</span> == N) &#123;</span><br><span class="line">        chunk_t *o = <span class="variable">_begin_chunk</span>;</span><br><span class="line">        <span class="variable">_begin_chunk</span> = <span class="variable">_begin_chunk</span>-&gt;next;</span><br><span class="line">        <span class="variable">_begin_chunk</span>-&gt;prev = NULL;</span><br><span class="line">        <span class="variable">_begin_pos</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  &#x27;o&#x27; has been more recently used than _spare_chunk,</span></span><br><span class="line">        <span class="comment">//  so for cache reasons we&#x27;ll get rid of the spare and</span></span><br><span class="line">        <span class="comment">//  use &#x27;o&#x27; as the spare.</span></span><br><span class="line">        chunk_t *cs = <span class="variable">_spare_chunk</span>.xchg (o);</span><br><span class="line">        free (cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看下ypipe：ypipe继承自ypipe_base_t，ypipe_base_t抽象出了ypipe和ypipe_conflate（后面分析）的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">ypipe_base_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="keyword">ypipe_base_t</span> () &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(<span class="keyword">const</span> T &amp;value_, <span class="keyword">bool</span> incomplete_)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">unwrite</span> <span class="params">(T *value_)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">flush</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">check_read</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span> <span class="params">(T *value_)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">probe</span> <span class="params">(<span class="keyword">bool</span> (*fn)(<span class="keyword">const</span> T &amp;))</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ypipe包含了一个yqueue队列和四个非常重要的指针，下面是ypipe的成员变量定义：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>  Allocation-efficient queue to store pipe items.</span><br><span class="line"><span class="regexp">//</span>  Front of the queue points to the first prefetched item, back of</span><br><span class="line"><span class="regexp">//</span>  the pipe points to last un-flushed item. Front is used only by</span><br><span class="line"><span class="regexp">//</span>  reader thread, <span class="keyword">while</span> back is used only by writer thread.</span><br><span class="line">yqueue_t &lt;T, N&gt; queue;</span><br><span class="line"></span><br><span class="line">T *w;</span><br><span class="line">T *r;</span><br><span class="line">T *f; <span class="regexp">//</span>f指针指向了当前未做flush操作的第一个元素，如果是写入了一条完整消息，那f指向的就是结束符。</span><br><span class="line">atomic_ptr_t &lt;T&gt; c; <span class="regexp">//</span>c只能有两个值，要么等于w，要么为空，当c为空时说明之前的check_read操作没有读到元素，check_read返回false同时将c置为空。</span><br></pre></td></tr></table></figure>
<p>ypipe管道的读写操作：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void write (const T &amp;value_, <span class="built_in">bool</span> incomplete_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Place the value to the queue, add new terminator element.</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span> = value_;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>push <span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Move the &quot;flush up to here&quot; poiter.</span></span><br><span class="line">    <span class="keyword">if</span> (!incomplete_)</span><br><span class="line">        _f = &amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Pop an incomplete item from the pipe. Returns true if such</span></span><br><span class="line"><span class="comment">//  item exists, false otherwise.</span></span><br><span class="line"><span class="built_in">bool</span> unwrite (T *value_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_f<span class="operator"> == </span>&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>unpush <span class="literal">()</span>;</span><br><span class="line">    *value_ = <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Flush all the completed items into the pipe. Returns false if</span></span><br><span class="line"><span class="comment">//  the reader thread is sleeping. In that case, caller is obliged to</span></span><br><span class="line"><span class="comment">//  wake the reader up before using the pipe again.</span></span><br><span class="line"><span class="built_in">bool</span> flush <span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  If there are no un-flushed items, do nothing.</span></span><br><span class="line">    <span class="keyword">if</span> (_w<span class="operator"> == </span>_f)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Try to set &#x27;c&#x27; to &#x27;f&#x27;.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">_c</span>.</span></span>cas (_w, _f) != _w) &#123;</span><br><span class="line">        <span class="comment">//  Compare-and-swap was unseccessful because &#x27;c&#x27; is NULL.</span></span><br><span class="line">        <span class="comment">//  This means that the reader is asleep. Therefore we don&#x27;t</span></span><br><span class="line">        <span class="comment">//  care about thread-safeness and update c in non-atomic</span></span><br><span class="line">        <span class="comment">//  manner. We&#x27;ll return false to let the caller know</span></span><br><span class="line">        <span class="comment">//  that reader is sleeping.</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_c</span>.</span></span>set (_f);</span><br><span class="line">        _w = _f;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Reader is alive. Nothing special to do now. Just move</span></span><br><span class="line">    <span class="comment">//  the &#x27;first un-flushed item&#x27; pointer to &#x27;f&#x27;.</span></span><br><span class="line">    _w = _f;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*check_read操作，它的返回值标记了队列中是否有数据，他使用r指针来标记当前可以读到的位置：</span></span><br><span class="line"><span class="comment">*如果r指针不在front位置处，说明有元素可读。</span></span><br><span class="line"><span class="comment">*否则就用c和front对比来判断当前是否有元素，如果没有将c置为空，表明读操作处于睡眠状态。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">bool</span> check_read <span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Was the value prefetched already? If so, return.</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span> != _r<span class="operator"> &amp;&amp; </span>_r)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  There&#x27;s no prefetched value, so let us prefetch more values.</span></span><br><span class="line">    <span class="comment">//  Prefetching is to simply retrieve the</span></span><br><span class="line">    <span class="comment">//  pointer from c in atomic fashion. If there are no</span></span><br><span class="line">    <span class="comment">//  items to prefetch, set c to NULL (using compare-and-swap).</span></span><br><span class="line">    _r = <span class="module-access"><span class="module"><span class="identifier">_c</span>.</span></span>cas (&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span>, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  If there are no elements prefetched, exit.</span></span><br><span class="line">    <span class="comment">//  During pipe&#x27;s lifetime r should never be NULL, however,</span></span><br><span class="line">    <span class="comment">//  it can happen during pipe shutdown when items</span></span><br><span class="line">    <span class="comment">//  are being deallocated.</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span><span class="operator"> == </span>_r<span class="operator"> || </span>!_r)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  There was at least one value prefetched.</span></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Reads an item from the pipe. Returns false if there is no value.</span></span><br><span class="line"><span class="comment">//  available.</span></span><br><span class="line"><span class="built_in">bool</span> read (T *value_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Try to prefetch a value.</span></span><br><span class="line">    <span class="keyword">if</span> (!check_read <span class="literal">()</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  There was at least one value prefetched.</span></span><br><span class="line">    <span class="comment">//  Return it to the caller.</span></span><br><span class="line">    *value_ = <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>pop <span class="literal">()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Applies the function fn to the first elemenent in the pipe</span></span><br><span class="line"><span class="comment">//  and returns the value returned by the fn.</span></span><br><span class="line"><span class="comment">//  The pipe mustn&#x27;t be empty or the function crashes.</span></span><br><span class="line"><span class="built_in">bool</span> probe (<span class="built_in">bool</span> (*fn_) (const T &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="built_in">bool</span> rc = check_read <span class="literal">()</span>;</span><br><span class="line">    zmq_assert (rc);</span><br><span class="line"></span><br><span class="line">    return (*fn_) (<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ZeroMQ</category>
      </categories>
      <tags>
        <tag>消息队列， C++</tag>
      </tags>
  </entry>
  <entry>
    <title>BIO与NIO和AIO三种reactor模型</title>
    <url>/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++11之default与delete关键字</title>
    <url>/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在讲default与delete关键字之前，我们先了解下C++的几个特殊函数。<br><br>C++98编译器会隐式的产生四个函数：缺省构造函数，析构函数，拷贝构造函数和拷贝赋值运算符，它们称为特殊成员函数，负责创建、初始化、销毁，或者拷贝类的对象。<br>在 C++11 中，除了上面四个外，特殊成员函数还有两个：移动构造函数和移动赋值算符。例：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">class <span class="built_in">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span> ();                  <span class="comment">// 缺省构造函数</span></span><br><span class="line">    ~<span class="built_in">Data</span> ();                 <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span> (const <span class="built_in">Data</span> &amp; rhs);         　 　  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Data</span> &amp; operator=(const <span class="built_in">Data</span> &amp; rhs);    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span> (const <span class="built_in">Data</span> &amp;&amp; rhs);         <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Data</span> &amp; operator=(<span class="built_in">Data</span> &amp;&amp; rhs);    <span class="comment">// 移动赋值算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="C-的特殊成员函数"><a href="#C-的特殊成员函数" class="headerlink" title="C++的特殊成员函数"></a>C++的特殊成员函数</h3><h4 id="缺省构造函数与析构函数"><a href="#缺省构造函数与析构函数" class="headerlink" title="缺省构造函数与析构函数"></a>缺省构造函数与析构函数</h4><p>缺省构造函数指不需要参数就能初始化的构造函数，包含无参和所有参数有默认值两种类型的构造函数。 一个缺省的构造函数只有在类中没有声明任何构造函数的情况下才会被编译器自动生成。<br><br>特殊成员函数被隐式生成为public和inline，并且它们是nonvirtual，除非是在派生类中的析构函数，并且这个派生类继承自带virtual析构函数的基类。在这种情况下，派生类中，编译器生成的析构函数也是virtual。</p>
<span id="more"></span>
<h4 id="拷贝构造与拷贝赋值运算符"><a href="#拷贝构造与拷贝赋值运算符" class="headerlink" title="拷贝构造与拷贝赋值运算符"></a>拷贝构造与拷贝赋值运算符</h4><p>拷贝构造是指用已经存在的对象创建出一个新的对象。因为创建一个对象首先是进行内存分配然后是调用构造函数对其初始化，即对分配的内存进行首次赋值。而拷贝构造就是利用其它对象的数据来初始化新对象的内存。<br><br>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p>
<ol>
<li><p>为什么必须是当前类的引用呢？<br><br>　　如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。<br>因此只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p>
</li>
<li><p>为什么是 const 引用呢？<br><br>　　拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。其次，因为非const类型可以转换为const类型而const类型不能转换为非const类型，所以如果没有使用const修饰时，就不能将const对象传递给形参了。<br><br>换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。<br><br>如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。<br><br>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员，此时，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据（深拷贝）。例如：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数,采用深拷贝的方式拷贝d.num指针成员</span></span><br><span class="line">    demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序中定义了一个可返回demo对象的get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
</li>
<li><p>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</p>
</li>
<li><p>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</p>
</li>
<li><p>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</p>
</li>
<li><p>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。<br><br>示例程序摘抄自<a href="http://c.biancheng.net/view/7847.html%E3%80%82">http://c.biancheng.net/view/7847.html。</a></p>
<h4 id="移动拷贝构造与移动拷贝赋值运算符"><a href="#移动拷贝构造与移动拷贝赋值运算符" class="headerlink" title="移动拷贝构造与移动拷贝赋值运算符"></a>移动拷贝构造与移动拷贝赋值运算符</h4><p>因为拷贝构造函数的深拷贝涉及到临时对象的创建与销毁，对应的是内存的不停分配与释放，当对象占用内存比较大时，程序的效率就会大大降低。因此C++11提出了移动拷贝构造的概念。<br><br>移动指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象，也就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。因为，程序执行过程中产生的临时对象往往只用于传递数据，并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。<br>例如，在上面的例子上我们手动添加一个移动拷贝函数：</p>
 <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">//添加移动构造函数</span><br><span class="line"><span class="built_in">demo</span>(<span class="built_in">demo</span> &amp;&amp;d):<span class="built_in">num</span>(d.<span class="built_in">num</span>)&#123;</span><br><span class="line">    d.<span class="built_in">num</span> = NULL;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
</li>
</ol>
<p><em><strong>当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</strong></em></p>
<h3 id="default与delete关键字"><a href="#default与delete关键字" class="headerlink" title="default与delete关键字"></a>default与delete关键字</h3><h4 id="default关键字"><a href="#default关键字" class="headerlink" title="default关键字"></a>default关键字</h4><p>C++11的新特性，仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。 程序员只需在函数声明后加上”=default;”，就可将该函数声明为defaulted函数，编译器将为显式声明的defaulted函数自动生成函数体。<br><br>defaulted函数既可以在类体里(inline)定义，也可以在类体外(out-of-line)定义。</p>
<h4 id="delete-关键字"><a href="#delete-关键字" class="headerlink" title="delete 关键字"></a>delete 关键字</h4><p>C++11 中，可在想要 “禁止使用” 的特殊成员函数声明后加 “= delete”，而需要保留的加 “= default” 或者不采取操作.<br><br>与default关键字不同的是，delete 关键字可用于任何函数，不仅仅局限于类成员函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode190.颠倒二进制位</title>
    <url>/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<p>题目（LeetCode摘抄）：<br><br>颠倒给定的 32 位无符号整数的二进制位。<br><br>提示：<br><br>　　请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。<br><br>进阶:如果多次调用这个函数，你将如何优化你的算法？</p>
<span id="more"></span>
<p>解法一：利用位操作取每一位上的数字，再根据二进制转十进制的规则进行计算相加得到最后需要的结果。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBit</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">doMethod</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            result+= (n &amp; <span class="number">1</span>) * Math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>-i);</span><br><span class="line">            n=n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(doMethod(<span class="number">4326159</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：利用位操作：左移位加上右移位</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">int</span> doMethod1(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="literal">result</span> |= (n &amp; <span class="number">1</span>)&lt;&lt;(<span class="number">31</span>-i);</span><br><span class="line">        n=n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构，java</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread_key_create</title>
    <url>/2021/03/26/pthread-key-create/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在工作中重新深入认识了一个函数pthread_key_create。深入挖掘该函数源码，才发现这就是java中的ThreadLocal。<br><br>其实这就是线程本地变量的概念。因为在多线程的程序中，线程是共享程序中的全局变量的。而对于线程本地变量，每一个变量是拥有该全局变量的一个副本，各线程对该变量的修改是线程内可见，线程间不影响。</p>
<h3 id="pthread-key-create"><a href="#pthread-key-create" class="headerlink" title="pthread_key_create"></a>pthread_key_create</h3><p>函数声明：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">int pthread_key_create(pthread_key_t *key, void <span class="comment">(*destructor)(void*)</span>);</span><br></pre></td></tr></table></figure>
<p>参数1：pthread_key_t *key，pthread_key_create函数从 TSD ((Thread-specific Data) 池中分配一项，将其地址值赋给 key 供以后访问使用。<br><br>参数2：是一个清理函数，用来在线程退出(调用 pthread_exit() 函数)时将以 key 锁关联的数据作为参数调用它，以释放分配的缓冲区，或是关闭文件流等。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。该函数成功返回0.其他任何返回值都表示出现了错误。</p>
<span id="more"></span>

<p>与线程本地变量数据相关的几个函数：</p>
<ol>
<li>pthread_key_create</li>
<li>pthread_key_delete： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_key_delete(<span class="params">pthread_key_t</span> <span class="params">key</span>)</span>;</span><br></pre></td></tr></table></figure>
该函数的目的是销毁key键并释放与该key关联的所有内存。因为该函数是不会主动调用任何析构函数去释放资源，所以在调用该函数之前必须释放所有线程的特定资源。<br><br>需要注意的是反复调用pthread_key_create与pthread_key_delete可能会产生问题。对于每个所需的键，应当只调用pthread_key_create一次。</li>
<li>pthread_setspecific(): <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_setspecific(<span class="params">pthread_key_t</span> <span class="params">key</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">value</span>)</span>;</span><br></pre></td></tr></table></figure>
当线程中需要存储特殊值的时候，可以调用 pthread_setspcific() 。该函数有两个参数，第一个为前面声明的pthread_key_t变量，第二个为void*变量，这样你可以存储任何类型的值。</li>
<li>pthread_getspecific():<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure>
该函数返回的是与key相关联数据的指针。需要注意的是：因为pthread_setspecific()存储的数据是void*，所以在利用该函数返回的指针时，虽然知道关联的数据地址，但并不知道指向的数据类型，因此要对其进行强制类型转换。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>linux、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeroMQ概念入门</title>
    <url>/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在代码评审的过程中，接触到了一个新的之前没接触过的通信框架——ZeroMQ。所以打算借助代码评审的过程对该框架进行学习，并写些博客作为心得笔记。</p>
<h3 id="什么是ZeroMQ"><a href="#什么是ZeroMQ" class="headerlink" title="什么是ZeroMQ"></a>什么是ZeroMQ</h3><p>ZeroMQ是一个用于分布式或者并发环境下的高性能的异步通信框架。它支持在多种协议上进行消息传递，比如TCP、进程内、进程间、组播以及socket通信等。<br><br>Zero支持的通信模型有：发布订阅、请求响应、推拉模式以及Router/Dealer模式等。ZeroMQ支持多种语言，比如C、C++、Java、Python等。</p>
<span id="more"></span>

<h3 id="请求响应模式"><a href="#请求响应模式" class="headerlink" title="请求响应模式"></a>请求响应模式</h3><p>程序员的入门方式一定是以“HelloWord”开始的，这里我们以ZeroMQ官方给出的例子来简单解释下其请求响应方式下的工作流程。<br><br>首先新建一个client和server，client向server发送“hello”请求，而server在接收到该请求的时候回复“world”。<br><br><div align="center"><img src="/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/req-reply.png" alt="req-reply.png"></div><br>客户端代码(C++)：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zmq.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// initialize the zmq context with a single IO thread</span></span><br><span class="line">    zmq::<span class="keyword">context_t</span> context&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a REQ (request) socket and connect to interface</span></span><br><span class="line">    zmq::<span class="keyword">socket_t</span> socket&#123;context, zmq::socket_type::req&#125;;</span><br><span class="line">    socket.<span class="built_in">connect</span>(<span class="string">&quot;tcp://localhost:5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up some static data to send</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> data&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> request_num = <span class="number">0</span>; request_num &lt; <span class="number">10</span>; ++request_num) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// send the request message</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sending Hello &quot;</span> &lt;&lt; request_num &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        socket.send(zmq::<span class="built_in">buffer</span>(data), zmq::send_flags::none);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// wait for reply from server</span></span><br><span class="line">        zmq::<span class="keyword">message_t</span> reply&#123;&#125;;</span><br><span class="line">        socket.recv(reply, zmq::recv_flags::none);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received &quot;</span> &lt;&lt; reply.to_string(); </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; request_num &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server端代码(C++)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="comment">//  Hello World server in C++</span></span><br><span class="line"><span class="comment">//  Binds REP socket to tcp://*:5555</span></span><br><span class="line"><span class="comment">//  Expects &quot;Hello&quot; from client, replies with &quot;World&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zmq.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sleep(n)	Sleep(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and socket</span></span><br><span class="line">    <span class="function">zmq::<span class="keyword">context_t</span> <span class="title">context</span> <span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">zmq::<span class="keyword">socket_t</span> <span class="title">socket</span> <span class="params">(context, ZMQ_REP)</span></span>;</span><br><span class="line">    socket.bind (<span class="string">&quot;tcp://*:5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        zmq::<span class="keyword">message_t</span> request;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Wait for next request from client</span></span><br><span class="line">        socket.recv (&amp;request);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received Hello&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Do some &#x27;work&#x27;</span></span><br><span class="line">    	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Send reply back to client</span></span><br><span class="line">        <span class="function">zmq::<span class="keyword">message_t</span> <span class="title">reply</span> <span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">        <span class="built_in">memcpy</span> (reply.data (), <span class="string">&quot;World&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        socket.send (reply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：ZeroMQ的请求应答模型的消息发送是有一定规则的，client需要以整体一次或者循环调用zmq_send()和zmq_recv()，如果连续发送两次zmq_send()将会报错返回-1；同样的在server端也是需要依次调用zmq_recv()和zmq_send()。</p>
<h3 id="特殊的命名方式"><a href="#特殊的命名方式" class="headerlink" title="特殊的命名方式"></a>特殊的命名方式</h3><p>ZeroMQ源码中以s_开头的表示是静态方法或者静态变量</p>
]]></content>
      <categories>
        <category>网络通信、消息队列</category>
      </categories>
      <tags>
        <tag>C++、 Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos</title>
    <url>/2021/03/26/Paxos%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Paxos is a consensus algorithm executed by a set of processes, termed replicas, to agree on a single value in the presence of failures.<br><br>Lamport提出的Paxos算法用于解决分布式系统中一致性问题：将所有节点都写入同一个值，且被写入后不再更改。Paxos算法又分为两种：</p>
<ol>
<li>Basic Paxos算法：描述多节点如何就某个提案Value达成共识</li>
<li>Multi-Paxos算法：描述执行多个Basic Paxos的实例如何就一系列值达成共识。<br><br>Paxos算法的变种有：Fast Paxos、Cheap Paxos、Raft算法等。</li>
</ol>
<h3 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h3><ol>
<li><p>角色是Basic Paxos算法中最核心的三个功能的抽象：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>提议者Proposer</td>
<td>提议一个用于投票表决的值，即提案Value。在大多数的分布式场景下，集群中收到客户端请求的节点会是一个Proposer。</td>
<td>接入和协调功能：在收到客户端请求后，发起二阶段提交，进行共识协商</td>
</tr>
<tr>
<td>接受者Acceptor</td>
<td>负责对每个提议的值进行投票，并存储接受的值。一般来说，集群中的所有节点都在扮演Acceptor的角色，参与共识协商并接受和存储数据。</td>
<td>投票协商与数据存储功能：对提案Value进行投票，并接受达成共识的值，存储保存</td>
</tr>
<tr>
<td>学习者Learner</td>
<td>被通知投票的结果，接受并存储达成共识的值，不参与投票过程。一般来说，集群中的数据备份节点，比如主从结构宏的从节点是Learner，被动接受并保存数据，进行容灾备份。</td>
<td>数据存储功能：不参与共识协商，只进行达成共识的值接受与存储</td>
</tr>
</tbody></table>
</li>
</ol>
<p>在一致性协议框架中，集群中的节点可以同时承担以上多种角色。</p>
<span id="more"></span>
<ol start="2">
<li>如何达成共识？<br><br>Basic Paxos算法采用带有编号和提议值的提案代表一个提议，编号是用来区分不同的提议者。整个共识协商的过程共分为两个阶段：<ol>
<li>准备阶段<ol>
<li>提议者分别向所有接受者发送包含提案编号的准备请求（该阶段的请求中不携带具体的提议值）</li>
<li>接收节点接收到准备请求的处理也分为两种case：<ol>
<li>如果接收节点之前没有通过任何提案，则返回一个“尚无提案”的响应，并承诺不再响应提案编号小于等于当前提案编号的请求，不会通过编号小于当前编号的提案</li>
<li>如果接收到小于之前响应的准备请求的提案编号的提案，则丢弃该准备请求，不响应</li>
<li>如果接受者之前已经有通过提案，接受者会在准备请求的响应中包含已经通过的最大编号的提案。</li>
</ol>
</li>
</ol>
</li>
<li>接受阶段<ol>
<li>提议者在接收到大多数节点的准备响应之后，<em><strong>会根据响应中提案编号最大的提案的值，设置接受请求中的值（如果之前已经有达成共识的提议值，则不会修改该值）</strong></em>并发送接受请求</li>
<li>接受者收到接受请求值根据自己承诺过的提案值来选择接受或者拒绝，并将接受结果通知给所有学习者</li>
<li>学习者发现大多数的接受者都通过某个提案，它也通过该提案并接受该提议值<br><br>从上面的分析中可以看出：Basic Paxos是利用二阶段提交的方式来达成共识的，且由于“大多数”的概念的存在，意味着Basic Paxos算法还实现了容错，即在少于一半的节点出现故障时，集群依旧可以工作。<br><br>paxos将提议与leader进行分离，第一阶段选举leader而第二阶段选举最终提议。保证了当最初的共识方案提议者出故障的情况下，该提议也会被接受者发给后续提议者去继承。</li>
</ol>
</li>
</ol>
</li>
<li>basic Paxos的局限性：<ol>
<li>活锁问题：<br><br>　　Paxos理论上存在一个不能终结协议的活锁竞争问题。比如：当一个proposer提交的提议因为编号过低被拒绝时, 该proposer可能会提高编号重新提交。 如果同时有两个proposer都发现自己的方案编号过低, 从而轮流提出更高编号的proposal而导致对方被拒, 就可能会导致死循环(或活锁)。</li>
<li>恶意节点：<br><br>　　Paxos是假设所有节点都遵守协议的规定，不存在恶意节点的。</li>
</ol>
</li>
</ol>
<h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h3>]]></content>
      <categories>
        <category>分布式协议</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>binlog与redolog</title>
    <url>/2021/03/26/binlog%E4%B8%8Eredolog/</url>
    <content><![CDATA[<p>日志是Mysql数据库的重要组成部分，记录着数据库运行期间各种状态信息。Mysql的日志系统主要有错误日志、查询日志、慢查询日志、事务日志（redolog和undolog）、二进制日志（binlog）几大类。<br><br>其中：事务日志是InnoDB存储引擎层的日志，而二进制日志binlog是MysqlServer层记录的日志。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="什么是binlog？"><a href="#什么是binlog？" class="headerlink" title="什么是binlog？"></a>什么是binlog？</h4><p>binlog是属于数据库Server层面的逻辑日志，又称归档日志,使用任何存储引擎的Mysql数据库都会记录binlog日志。<br><br>binlog以二进制的形式记录数据库执行的写入性操作(不包括查询，即select与show等执行语句)信息<br><br>binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<h6 id="逻辑日志与物理日志"><a href="#逻辑日志与物理日志" class="headerlink" title="逻辑日志与物理日志"></a>逻辑日志与物理日志</h6><ol>
<li>逻辑日志：可以简单理解为记录的就是sql语句。</li>
<li>物理日志：因为Mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更。<h4 id="binlog的使用场景"><a href="#binlog的使用场景" class="headerlink" title="binlog的使用场景"></a>binlog的使用场景</h4>在实际应用中，binlog的主要使用场景有两个，分别是主从复制和数据恢复：</li>
<li>主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端relay binlog从而达到主从数据一致。</li>
<li>数据恢复：通过使用mysqlbinlog工具来恢复数据。<h4 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h4>对于InnoDB存储引擎而言，只有在事务提交时才会记录binlog，此时记录还在内存中，那么binlog是什么时候刷到磁盘中的呢？<br><br>Mysql通过sync_binlog参数控制biglog的刷盘时机，取值范围是0-N：</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>不去强制要求，由系统自行判断何时写入磁盘</td>
</tr>
<tr>
<td>1</td>
<td>每次commit的时候都要将binlog写入磁盘</td>
</tr>
<tr>
<td>N</td>
<td>每N个事务，才会将binlog写入磁盘</td>
</tr>
</tbody></table>
<p><br>从上面可以看出，sync_binlog最安全的是设置是1，这也是MySQL 5.7.7之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p>
<h4 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h4><p>binlog日志有三种格式，分别为STATMENT、ROW和MIXED。<br><br>在 MySQL5.7.7之前，默认的格式是STATEMENT；而MySQL5.7.7之后，默认值是ROW。日志格式通过binlog-format指定。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>STATMENT</td>
<td>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。</td>
<td>不需要记录每一行的变化，减少了binlog日志量，节约了IO, 从而提高了性能</td>
<td>在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等。</td>
</tr>
<tr>
<td>ROW</td>
<td>基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了。</td>
<td>不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题；</td>
<td>会产生大量的日志，尤其是alter table的时候会让日志暴涨</td>
</tr>
<tr>
<td>MIXED</td>
<td>基于STATMENT和ROW两种模式的混合复制(mixed-based replication, MBR)。一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><p><br>WAL技术：<br><br>　　对于Mysql，如果每一次的更新操作都需要写入磁盘，然后磁盘需要对应找到该记录并更新，那么IO的成本以及磁盘文件查找的成本都会很高。所以Mysql利用WAL技术，即先写日志再写磁盘的技术来提升整个更新效率。</p>
<h4 id="什么是redolog？"><a href="#什么是redolog？" class="headerlink" title="什么是redolog？"></a>什么是redolog？</h4><p>redolog是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。<br><br>redolog包括两部分：一个是内存中的日志缓冲(redolog buffer)，另一个是磁盘上的日志文件(redolog file)。Mysql每执行一条DML语句，先将记录写入redolog buffer，后续某个时间点再一次性将多个操作记录写到redolog file中。<br><br>redolog是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</p>
<h4 id="redolog刷盘时机"><a href="#redolog刷盘时机" class="headerlink" title="redolog刷盘时机"></a>redolog刷盘时机</h4><p>Mysql支持三种将redolog buffer写入redolog file的时机，可以通过innodb_flush_log_at_trx_commit参数配置，各参数值含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>每次提交事务都只把redolog留在redolog buffer中</td>
</tr>
<tr>
<td>1</td>
<td>每次提交事务都将redolog 持久化到磁盘上（write+fsync）</td>
</tr>
<tr>
<td>2</td>
<td>每次都把redolog写到系统的page cache中（只write，不fsync）</td>
</tr>
</tbody></table>
<h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。<br><br>属于逻辑日志，根据每行记录进行记录。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化之大端小端序</title>
    <url>/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天写一个跨域跨模型通信的Demo演示程序时，服务端对应的函数调用就是没有触发。Debug的时候发现，两端的通信连接是建立成功的，但是当客户端发起服务调用时，服务端总是提示反序列化失败的提示。<br>既然是反序列化失败，就去找序列化的代码。然后发现，因为是跨模型通信，走的是同一个协议的两种通信框架，而这两种框架又分别采用大端序和小端序的字节存储方式，所以就造成了信息解码失败的问题。<br>所以想趁此机会，写一篇博客来详解下字节编码的字节序问题。</p>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>在计算机底层，所有的数据在存储和运算时都使用二进制表示。而对于同一组二进制数据，不同的个体定义的编码方式可能会将其解析成不同的符号。因此通信双方需要使用同一种编码方式才不会造成数据解析混乱。</p>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>ASCII码一共规定了128个字符的编码，只占用了一个字节的后面7位，最前面的1位统一规定为0。比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。<br><br>ASCII码主要用于表示英语和其它西欧语言。英语用128个符号便可以表示所有，但是用来表示其它语言，128个符号是不够的。于是，一些欧洲国家就决定，将字节最高位设为1，拓展到256个符号：其中0~127表示的符号是一样的，不一样的只是128 ~ 255的这一段。 这又引入了新的问题，同一个最高位为1的二进制字节在不同的国家中表示不同的符号。<br><br>而且对于类似于汉语这种文字种类比较多的语言来说，单字节的表示肯定是不够的，也就是需要多个字节来表示。</p>
<h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><p>对于ASCII码单字节不够使用的问题，不同的国家针对自己的语言会制定不同的编码方式。例如，中国的GB2312编码等。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。<br><br>为了解决乱码问题，Unicode这套统一所有文字的编码方式应运而生。<br><br>Unicode把所有语言都统一到一套编码里，每一个符号对应一个独一无二的二进制数。<br><br>注意：Unicode只是一套编码字符集，它只规定了符号与二进制数之间的映射关系，却没有规定这个二进制数应该如何存储载计算机上。因此，对于二级制数的解码仍然存在问题。比如：</p>
<ol>
<li>如何区分三个字节表示的二进制数是一个符号还是对应的三个符号？</li>
<li>如果固定了字节数，那么对于字节数小于固定字节数的符号的存储来说，会造成内存的极大浪费。</li>
</ol>
<h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF_8编码"></a>UTF_8编码</h3><p>UTF-8是Unicode的一种实现方式。它使用可变长的编码方式，一般是1到4个byte（也可以更长）来表示Unicode中的任何字符。而且其编码中的第一个字节仍与ASCII相容，用来表示字节编码方式：</p>
<ul>
<li>如果首字节以0开头，肯定是单字节编码，编码格式： 0xxxxxxx</li>
<li>如果以110开头，肯定是双字节编码，编码格式：110xxxxx 10xxxxxx</li>
<li>如果是1110开头，肯定是三字节编码，编码格式：1110xxxx 10xxxxxx 10xxxxxx</li>
<li>以此类推：除了单字节外，多字节UTF-8码的后续字节均以10开头。<br>其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示）。</li>
</ul>
<p>关于UTF_8编码为什么字节前两位固定为“10”的问题：<br><br>这是因为标准的utf-8设计，强制要求每个字符的除首字节外都必须为10xxxxxx这样的模式，它让每个字符边界能够自描述。当出现乱码或者位翻转的问题时，可以避免乱码问题。</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>是指多字节数据在计算机内存中存储或者网络传输时的存储顺序。有两种方式</p>
<ol>
<li>大端序BE：将高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
<li>小端序LE：将低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br><br>以unsigned int整型数据0x12345678为例，其大端序、小端序的存储内容如图所示：<table>
<thead>
<tr>
<th>内存地址</th>
<th>BE</th>
<th>LE</th>
</tr>
</thead>
<tbody><tr>
<td>0x01000001</td>
<td>0x12</td>
<td>0x78</td>
</tr>
<tr>
<td>0x01000002</td>
<td>0x34</td>
<td>0x56</td>
</tr>
<tr>
<td>0x01000003</td>
<td>0x56</td>
<td>0x34</td>
</tr>
<tr>
<td>0x01000004</td>
<td>0x78</td>
<td>0x12</td>
</tr>
</tbody></table>
</li>
</ol>
<p>不同的场景使用的字节序的方式是不同的：UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,存储在低地址，因此BE又称作网络字节序。</p>
]]></content>
  </entry>
  <entry>
    <title>Cmake使用笔记</title>
    <url>/2021/03/25/Cmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Redis的主从复制</title>
    <url>/2021/03/24/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>主从复制就是将一台服务器的数据复制到一个或者多个其他服务器中。一般与读写分离一起使用的，以为了提高数据库的高可用高并发性。<br>很多主流的数据库，消息中间件等都支持主从复制，比如：Mysql、Redis、RocketMq，Kafka等。</p>
]]></content>
  </entry>
  <entry>
    <title>内存溢出</title>
    <url>/2021/03/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>断言Assert</title>
    <url>/2021/03/24/%E6%96%AD%E8%A8%80Assert/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在对公司某项目进行代码评审的过程中，发现了断言机制使用不正确的问题。所以来记个笔记以避免自已以及看见这篇文章的同学们踩坑。</p>
<h3 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h3><p>程序一般分为“Debug”版和“Release”版，而断言一般是用于内部调试版，用于检查“不应该存在”的情况。</p>
<p>C和C++的断言机制一般通过调用assert()函数；<br>java类似的断言函数assert需要在断言开关-enableassertions或-ea开启的时候才起作用。为了避免与jdk14之前的assert关键字冲突，所以该开关默认是关闭的。</p>
<h3 id="C-的assert"><a href="#C-的assert" class="headerlink" title="C++的assert"></a>C++的assert</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<p>c++的assert本质是一个宏，原型定义在&lt;assert.h&gt;中。原理是判断表达式expression的值是否为0，如果为0，先向stderr打印一条Error信息，然后调用abort来终止进程。</p>
<h3 id="java的assert"><a href="#java的assert" class="headerlink" title="java的assert"></a>java的assert</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//有两种表示方式</span><br><span class="line"><span class="keyword">assert</span> <span class="type">bool</span>表达式  //当<span class="type">bool</span>表达式为<span class="keyword">false</span>的时候抛出AssertionError，并终止执行</span><br><span class="line"><span class="keyword">assert</span> <span class="type">bool</span>表达式：错误信息 //当<span class="type">bool</span>表达式为<span class="keyword">false</span>的时候抛出AssertionError，输出错误信息，并终止执行</span><br></pre></td></tr></table></figure>
<p><em>注意：java的大部分IDEA都默认assert机制是关闭的，需要手动java -ea打开开关</em></p>
<h3 id="assert的思考"><a href="#assert的思考" class="headerlink" title="assert的思考"></a>assert的思考</h3><p>因为在本次代码评审的过程中，发现了assert使用的两个问题：</p>
<ol>
<li>assert误用：<br> <br>在有些地方，assert被当作if滥用误用。比如一个祖先进程在创建进程时，如果参数读取失败，本来该走的代码逻辑是放弃该进程的创建，向上报异常或者输出Error信息。而该处使用assert直接导致整个程序异常终止。</li>
<li>冗余代码：<br> <br>在c++中如果assert的表达式返回的值是false，那么进程会调用abort终止并退出。因为对这一原理可能不是特别了解，所以评审的代码里出现了： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assert(expression);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">terminate</span>(); </span><br></pre></td></tr></table></figure>
 terminate定义在<exception>中，用于处理异常情况的，其默认实现是调用abort()。所以上面的代码，看出什么问题了么？</exception></li>
</ol>
<p>根据发现的问题以及个人平时的经验，我对assert的使用有以下几点建议：</p>
<ol>
<li>使用 assert() 时，被检测的表达式最好不要太复杂，最好的方式是一次断言只对应一个表达式。这样有助于在Debug调试的时候快速进行问题定位。</li>
<li>不要用会改变环境的语句作为断言的表达式，例如： <figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title"><span class="built_in">assert</span></span>(<span class="variable">i</span>++);</span></span><br></pre></td></tr></table></figure>
在Debug模式下，i的值会进行自增，但是切换到Release版本下，因为assert失效，所以i的值不会改变，可能会造成程序逻辑异常，比如：死循环等。因此，应该改为： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">assert(<span class="selector-tag">i</span>);</span><br><span class="line"><span class="selector-tag">i</span>++;</span><br></pre></td></tr></table></figure></li>
<li>如果是java语言，可以优先使用IDEA的debug调试或者Junit。因为assert的开关默认是关闭的，手动修改开关并不是在什么场合下都可以的，比如对于部署在容器里的Web程序来说就不是很方便。但是注意assert与Junit的判断出发点还是不同的，不能完全替代。前者是用于代码中逻辑条件点的判断，而后者是单元测试。</li>
</ol>
]]></content>
      <categories>
        <category>java、C++</category>
      </categories>
  </entry>
  <entry>
    <title>java.nio.bytebuffer解析</title>
    <url>/2021/03/23/java-nio-bytebuffer%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ByteBuffer继承自抽象类Buffer，用于在堆内存中预留一部分空间对IO数据做临时存储，以提高读写效率。与CharBuffer、IntBuffer等Buffer的其他子类的<br>区别在于数据类型的不同，但是关于缓冲区读写区域的管理全部由父类Buffer负责。<br><br> ByteBuffer类的定义：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="symbol">ByteBuffer</span></span><br><span class="line"><span class="symbol">extends</span> <span class="symbol">Buffer</span></span><br><span class="line"><span class="symbol">implements</span> <span class="symbol">Comparable</span>&lt;<span class="symbol">ByteBuffer</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>ByteBuffer自定义的属性字段：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">** 不为空，仅用于JVM堆缓存区  */</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line"><span class="comment">/** 数组的偏移量 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="comment">/** 是否只读 */</span></span><br><span class="line"><span class="keyword">boolean</span> isReadOnly;   </span><br><span class="line"><span class="comment">/** 是否采用默认排序：默认为大端序，为false时是小端序*/</span></span><br><span class="line"><span class="keyword">boolean</span> bigEndian = <span class="literal">true</span>;                                   <span class="comment">// package-private</span></span><br><span class="line"><span class="comment">// 本缓存的字节数据排列的顺序</span></span><br><span class="line"><span class="keyword">boolean</span> nativeByteOrder = (Bits.byteOrder() == ByteOrder.BIG_ENDIAN);<span class="comment">// package-private</span></span><br></pre></td></tr></table></figure>
<p>继承自父类Buffer的属性字段：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buffer本质上是一个数组，它是通过下面的属性来实现工作区域上数据的读写管理的。</span></span><br><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="comment">// 保存某个时刻的position指针的值，通过调用mark()实现可以与reset()函数搭配使用；当mark被置为负值时，表示废弃标记。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 缓冲区下一个可读/可写的元素的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 表示代操作数据的界限，limit-position=remaining</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="comment">// 表示缓冲空间的总容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ol>
<li>因为Buffer的本质是一个数组，所以在使用Buffer之前需要为其分配内存空间。ByteBuffer的创建可以通过分配内存空间或者将现有的字节数组包装到缓冲区中：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接分配内存，与操作系统的耦合性更高，速度更快，但是分配的开销更大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在java堆上分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将array从offset开始的length长的subArray包装到缓冲区buffer中，buffer的position等于offset，limit=offset+length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] <span class="built_in">array</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(<span class="built_in">array</span>, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将array数组包装到缓冲区，数组和butebuffer的任意一方存在改动都会互相影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>ByteBuffer.warp(byte[])以一个数组创建buffer后，该buffer默认处于读模式，即position=0,limit=capacity。此时若使用put进行写入，将从0位置开始覆盖掉初始化数组的数据。因此，若初始化的数据是有用数据，在写入开始前应使用compact()压实后，从尾部开始写入。</strong></em></p>
<ol start="2">
<li>缓冲区数据的读写<br>Buffer的工作方式主要为向缓冲区写入数据或者从缓冲区读取数据。<br><br>Buffer的缓冲区长度capacity在初始化之后就是不可修改的，只能通过position与limit划分活动区域。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取活动区域的数据长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rem = limit - <span class="built_in">position</span>;</span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该缓冲区是否还存在活动区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">position</span> &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>缓冲区数据的读写方法：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对位置读，读取的字节是该缓冲区的当前position，读完后，position+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 相对位置写，写入的字节是该缓冲区的当前position，写完后，position+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 绝对位置读（绝对位置的读写是不会修改positon的值的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 绝对位置写</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> abstract ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 相对位置读取大块量数据到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; <span class="built_in">end</span>; i++)</span><br><span class="line">        dst[i] = <span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相对位置写入大批量数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">put</span>(src.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; <span class="built_in">end</span>; i++)</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">put</span>(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">put</span>(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Buffer的类型包括了所有的除boolean外的基本数据类型。ByteBuffer可以通过调用asXXXBuffer()转换成XXX类型的Buffer，例如：<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换得到IntBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 对应的还有IntBuffer响应的读写方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
其他方法，一般在读写模式切换前会调用clear()、flip()、compact()等方法：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空缓冲区，该方法并不会真的清除缓冲区的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转方法，向前反转活动区域，一般用于准备数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = <span class="built_in">position</span>;</span><br><span class="line">    <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    mark = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The bytes between the buffer&#x27;s current position and its limit, if any, are copied to the beginning of the buffer. </span></span><br><span class="line"><span class="comment">* That is, the byte at index p = position() is copied to index zero, </span></span><br><span class="line"><span class="comment">*    the byte at index p + 1 is copied to index one, </span></span><br><span class="line"><span class="comment">*    and so forth until the byte at index limit() - 1 is copied to index n = limit() - 1 - p. </span></span><br><span class="line"><span class="comment">* The buffer&#x27;s position is then set to n+1 and its limit is set to its capacity. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 向前压实“活动区域”，准备开始写入。将Buffer中剩余的数据区域移动到头部，再将“活动区域”设置为除数据区域外的末尾部分。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract ByteBuffer <span class="title">compact</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ解析二</title>
    <url>/2021/03/23/RocketMQ%E8%A7%A3%E6%9E%90%E4%BA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>进程创建与退出</title>
    <url>/2021/03/22/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BA/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>最近在参与公司某项目平台组件代码评审的任务，刚好与操作系统的进程创建管理相关。于是，就想就着工作中发现的问题以及自己的一些总结来写点什么，既是复习又是学习。
</code></pre>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><pre><code>老生常谈，各博客平台写烂了的东西。
</code></pre>
<h2 id="Linux系统特殊的进程"><a href="#Linux系统特殊的进程" class="headerlink" title="Linux系统特殊的进程"></a>Linux系统特殊的进程</h2><p>　　在Linux系统中，除了系统启动之后的第一个进程由系统来创建，其余的进程都必须由某个父进程来创建。</p>
<ul>
<li><p>0号进程：<br><br>　　在系统启动及完成初始化之后，Linux自动创建的进程叫做根进程。根进程是Linux中所有进程的祖宗，pid为0的Idle进程。这也是唯一一个不是由fork也不是由kernel_thread创建的进程。</p>
</li>
<li><p>1号进程init：<br><br>　　由Idle进程调用Kernel_thread创建一个内核线程去执行init函数，该内核线程即init进程，pid为1。init函数继续初始化，此时依旧共享父进程即0号进程的资源属性，直至init函数的最后调用系统的execve，以装入用户空间的可执行文件/sbin/init，此时进程pid1拥有自己的属性资源，且内核的初始化和启动过程结束。<br><br>　　<code>kernel_thread(kernel_init, NULL, CLONE_FS);</code><br><br>　　init进程是所有用户进程的祖先。</p>
</li>
<li><p>2号进程kthreadd：<br><br>　　由Idle进程调用Kernel_thread创建，运行在内核空间，负责所有内核进程的调度和管理，pid为2。<br><br>　　<code>pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</code><br><br>　　会循环执行kthread函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中。<br><br>　　该进程是所有内核进程的祖先。</p>
<h3 id="init与systemd"><a href="#init与systemd" class="headerlink" title="init与systemd"></a>init与systemd</h3><p>ubuntu9.10-14.10，系统的启动过程是：<br><br>　　　　开机自检BIOS====》加载MBR中的GRUB引导====》加载内核====》init进程初始化<br>之后，ubuntu对内核的初始化进行了改进，启动过程如下：<br><br>　　　　开机自检BIOS====》加载MBR中的GRUB2引导====》加载内核====》Systemd进程初始化</p>
<p>　　init进程与system进程的区别:</p>
<table>
<thead>
<tr>
<th align="left">init进程</th>
<th align="left">systemd进程</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><br>　　　1. init进程的启动时间长，进程的启动是串行执行的<br>　　　2. 启动脚本复杂，init进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况<br>　　　3. 位于/sbin/init</td>
<td align="left"><br>　　　1. 按需启动服务，减少系统资源消耗<br>　　　2. 尽可能并行启动进程，减少系统启动等待时间<br>　　　3. 位于 /usr/lib/systemd/systemd</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>进程创建首先是在进程表中为进程建立一个进程控制块PCB。<br><br>PCB通常记载进程之相关信息，包括：</p>
<ul>
<li>进程状态：可以是new、ready、running、waiting或 blocked等。</li>
<li>程序计数器：下一条要运行的指令地址。</li>
<li>CPU寄存器：如累加器、变址寄存器、堆栈指针以及一般用途寄存器、状况代码等，</li>
<li>CPU调度算法：优先级、调度队列等指针以及其他参数。</li>
<li>存储器管理：如标签页表等。</li>
<li>输入输出状态：配置进程使用I/O设备，如磁带机等</li>
</ul>
<p>在 Linux 内核中,供用户创建进程的API调用有fork()，vfork()，clone() ，这三个函数的对应的系统调用是：sys_fork()、sys_clone()、sys_vfork()。<br>fork、vfork以及 clone 的区别：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">语法格式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fork</td>
<td align="left">fork创造的子进程是父进程的完整副本，复制了父进程的资源: task_struct,打开文件表，信号，命名空间虚拟地址空间（包括堆栈等）等。（写时复制） <br>fork的实现：do_fork(CLONE_SIGCHLD,…)</td>
</tr>
<tr>
<td align="left">vfork</td>
<td align="left">vfork创建的子进程与父进程共享虚拟地址空间，所以子进程的改变会影响父进程中的数据。vfork创建子进程后，父进程会被阻塞直到子进程调用exec或exit。  <br>vfork的实现：do_fork(CLONE_VFORK</td>
</tr>
<tr>
<td align="left">clone</td>
<td align="left">系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone()是则可以将父进程资源有选择地复制给子进程。<br>具体要复制哪些资源给子进程，由参数列表中的clone_flags决决定。<br>clone的实现：do_fork(CLONE_VM/CLONE_FS/CLONE_FILES/CLONE_SIGCHLD,…)</td>
</tr>
</tbody></table>
<p>fork与vfork都是由clone实现，底层是调用了内核的_do_fork函数。</p>
<h3 id="fork详解"><a href="#fork详解" class="headerlink" title="fork详解"></a>fork详解</h3><ol>
<li>写时复制：在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。<br>当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。<br>
因为当fork()后立即执行exec()，地址空间就无需被复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建一个进程描述符。在一般情况下，进程创建后都为马上运行一个可执行的文件，这种优化，可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)。
***<br>而vfork是连虚拟内存空间都不会创建，直接共享父进程的虚拟空间，即共享父进程的物理空间。***</li>
<li>fork的另一个特性是所有由父进程打开的描述符都被复制到子进程中。父、子进程中相同编号的文件描述符在内核中指向同一个file结构体，也就是说，file结构体的引用计数要增加。</li>
<li>fork创建进程失败返回-1，如果是子进程返回值为0，如果是父进程则返回子进程的pid。一个进程要执行一个不同的程序，比如fork后，子进程调用exec函数。</li>
<li>fork 还有一个特点：子进程不是从 main 函数开始执行的，而是从 fork 返回的地方开始</li>
</ol>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>当进程完成执行最后指令并且通过系统调用 exit() 向操作系统发出请求时，进程终止。这时，进程可以返回退出状态码（通常为整数）给父进程。所有进程资源，如物理和虚拟内存、打开文件和 I/O 缓冲区等，会由操作系统释放。</p>
<p>父进程需要通过调用wait()或者waitpid函数来收集子进程的退出状态。如果父进程未调用该函数来阻塞获取子进程的退出状态，那么子进程就是僵尸进程，会对系统造成危害。<br><br>这是因为即使进程退出时，操作系统会释放其占用的资源，但是它位于进程表中的项还是存在的，需要由父进程进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li>参数pid为欲等待的子进程识别码：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">参数值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pid&lt;-1</td>
<td align="left">等待进程组号为pid绝对值的任何子进程。</td>
</tr>
<tr>
<td align="left">pid=-1</td>
<td align="left">等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。</td>
</tr>
<tr>
<td align="left">pid=0</td>
<td align="left">等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。</td>
</tr>
<tr>
<td align="left">pid&gt;0</td>
<td align="left">等待进程号为pid的子进程。</td>
</tr>
</tbody></table>
<p>pid为0与-1的区别在于：前者是收集所有子进程的退出状态码而后者是收集属于同一个进程组的子进程的退出状态码。父进程的子进程不一定与父进程或者其他兄弟进程同属于一个进程组。</p>
<ol start="2">
<li>而参数*status将保存子进程的状态信息，有了这个信息父进程就可以了解子进程是否正常退出。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WIFEXITED(status)</td>
<td align="left">如果子进程正常结束，它就返回真；否则返回假。</td>
</tr>
<tr>
<td align="left">WEXITSTATUS(status)</td>
<td align="left">如果WIFEXITED(status)为真，则可以用该宏取得子进程exit()返回的结束代码。</td>
</tr>
<tr>
<td align="left">WIFSIGNALED(status)</td>
<td align="left">如果子进程因为一个未捕获的信号而终止，它就返回真；否则返回假。</td>
</tr>
<tr>
<td align="left">WTERMSIG(status)</td>
<td align="left">如果WIFSIGNALED(status)为真，则可以用该宏获得导致子进程终止的信号代码。</td>
</tr>
<tr>
<td align="left">WIFSTOPPED(status)</td>
<td align="left">如果当前子进程被暂停了，则返回真；否则返回假。</td>
</tr>
<tr>
<td align="left">WSTOPSIG(status)</td>
<td align="left">如果WIFSTOPPED(status)为真，则可以使用该宏获得导致子进程暂停的信号代码。</td>
</tr>
</tbody></table>
<ol start="3">
<li>参数options提供了一些另外的选项来控制waitpid()函数的行为。如果不想使用这些选项，则可以把这个参数设为0</li>
</ol>
<p>如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。如果waitpid()函数执行成功，则返回子进程的进程号；如果有错误发生，则返回-1，并且将失败的原因存放在errno变量中。</p>
<h3 id="exec簇"><a href="#exec簇" class="headerlink" title="exec簇"></a>exec簇</h3><p>exec函数一共有六个，其中execve为内核级系统调用，其他都是调用execve的库函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习之__attribute__机制</title>
    <url>/2021/03/17/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B-attribute/</url>
    <content><![CDATA[<p>__attribute__是GNU C特色之一，可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.</p>
<p>语法格式： __attribute __((abute-list))</p>
<p>位置：声明结束符“；”的前面</p>
<p><em>在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</em></p>
<h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。</p>
<p>GNU CC需要使用 –Wall，这是控制警告信息的一个很好的方式。</p>
<p>下面是常见的属性参数：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">语法格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">noreturn</td>
<td align="center">noreturn</td>
<td align="left">该属性通知编译器函数从不返回值。<br>当遇到函数需要返回值却还没运行到返回值处就已退出来的情况，该属性可以避免出现错误信息。<br>C库函数中的abort（）和exit（）的声明格式就采用了这种格式：<br>   (1) extern void  exit(int)   <strong>attribute</strong>( ( noreturn ) );<br>   (2) extern void  abort(void)  <strong>attribute</strong>( ( noreturn ) );</td>
</tr>
<tr>
<td align="left">noinline</td>
<td align="center">noinline</td>
<td align="left">用inline修饰的函数能否形成内联，需要看编译器对该函数定义的具体处理。该参数表示：不内联</td>
</tr>
<tr>
<td align="left">always_inline</td>
<td align="center">always_inline</td>
<td align="left">总是内联</td>
</tr>
<tr>
<td align="left">const</td>
<td align="center">const</td>
<td align="left">该属性只能用于带有数值类型参数的函数上，当重复调用带有数值参数的函数时，由于返回值是相同的。所以此时编译器可以进行优化处理，除第一次需要运算外， 其它只需要返回第一次的结果。<br> <em><strong>const参数不能用在带有指针类型参数的函数中，因为该属性不但影响函数的参数值，同样也影响到了参数指向的数据，它可能会对代码本身产生严重甚至是不可恢复的严重后果。</strong></em></td>
</tr>
<tr>
<td align="left">format</td>
<td align="center">format (archetype, string-index, first-to-check)</td>
<td align="left">该属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。<br>format属性告诉编译器，按照 printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。<br>“archetype”指定是哪种风格；<br>“string-index”指定传入函数的第几个参数是格式化字符串；<br>“first-to-check”指定第一个可变参数所在的索引。</td>
</tr>
<tr>
<td align="left">finstrument-functions</td>
<td align="center">finstrument-functions</td>
<td align="left">该参数可以使程序在编译时，在函数的入口和出口处生成instrumentation调用。增加的这两个函数分别为：<br> <code>void __cyg_profile_func_enter (void *this_fn, void *call_site);</code> <br> <code>void __cyg_profile_func_exit  (void *this_fn, void *call_site);</code><br>其中第一个参数为当前函数的起始地址，第二个参数为返回地址，即caller函数中的地址。</td>
</tr>
<tr>
<td align="left">no_instrument_function</td>
<td align="center">no_instrument_function</td>
<td align="left">gcc加上“-finstrument-functions”选项用来跟踪函数的调用关系，在每个函数的入口和出口处会各增加一个额外的hook函数的调用。如果不想跟踪某个函数，可以给该函数指定“no_instrument_function”属性。</td>
</tr>
<tr>
<td align="left">constructor</td>
<td align="center">constructor/constructor(n)</td>
<td align="left">若函数被设定为constructor属性，则该函数会在 main（）函数执行之前被自动的执行。<br>n表示当存在多个被修饰的函数时，执行的优先级顺序，如果没设置n，则执行顺序不确定，其中[0,100]是系统保留的,不可以调用。数值越小,越先调用。<br><em><strong>执行顺序为:load-&gt;constructor-&gt;main，因为：dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法,然后才调用main函数.</strong></em></td>
</tr>
<tr>
<td align="left">destructor</td>
<td align="center">destructor/destructor(n)</td>
<td align="left">与constructor相似，若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。<br>  拥有此类属性的函数经常隐式的用在程序的初始化数据方面。数值越大,越先调用</td>
</tr>
<tr>
<td align="left">unavailable</td>
<td align="center">unavailable(“错误信息”)</td>
<td align="left">适用于方法、属性。告诉编译器不可用。如果使用了，就会编译失败，提示错误信息</td>
</tr>
<tr>
<td align="left">deprecated</td>
<td align="center">deprecated(“警告信息”)</td>
<td align="left">适用于方法、属性。告诉编译器已经过时，如果使用了，会报过时警告</td>
</tr>
<tr>
<td align="left">nonnull</td>
<td align="center">nonnull(int,int,…)</td>
<td align="left">编译器对函数参数进行NULL的检查,参数类型必须是指针类型(包括对象)</td>
</tr>
<tr>
<td align="left">visibility</td>
<td align="center">visibility(“visibilityType”)</td>
<td align="left">该关键字与gcc编译参数-fvisibility=hidden配合使用。<br>visibility_type 是下列值之一：<br>  <strong>default</strong>:先使用-fvisibility=hidden将所有符号隐藏，然后在需要对外的符号前添加__attribute__((visibility(“default”)))属性来保证符号对外可见;<br>  <strong>hidden</strong>:该符号不存放在动态符号表中，因此，其他可执行文件或共享库都无法直接引用它。使用函数指针可进行间接引用。将-fvisibility设置为”default”或不设置这个属性，默认所有符号都对外可见，然后在不对外可见的函数或变量前添加__attribute__((visibility(“hidden”)))来隐藏该符号。<br>  <strong>internal</strong>:除非由特定于处理器的应用二进制接口 (psABI) 指定，否则，内部可见性意味着不允许从另一模块调用该函数;<br>  <strong>protected</strong>:该符号存放在动态符号表中，但定义模块内的引用将与局部符号绑定。也就是说，另一模块无法覆盖该符号。</td>
</tr>
</tbody></table>
<h2 id="同时使用多个参数"><a href="#同时使用多个参数" class="headerlink" title="同时使用多个参数"></a>同时使用多个参数</h2><p>可以在同一个函数声明里使用多个__attribute__。使用方式上，你可以选择两个单独的__attribute__，或者把它们写在一起，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>  <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format， ...)</span>   __<span class="title">attribute__</span><span class="params">( (noreturn))</span>   __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>)) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>  <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format，...)</span>    __attribute __<span class="params">( (noreturn,  format(<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>)) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果带有该属性的自定义函数被追加到库的头文件里，那么所以调用该函数的程序都要做相应的检查。</p>
<p>需要说明的是，__attribute__适用于函数的声明而不是函数的定义。所以，当需要使用该属性的函数时，必须在同一个文件里进行声明，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format， ... )</span> __attribute __<span class="params">( (noreturn) )</span> __attribute __<span class="params">( ( format(<span class="built_in">printf</span>，<span class="number">1</span>，<span class="number">2</span>) ) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format，... )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 函数定义 */</span>  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h1><p>关键字__attribute__也可以对变量（variable）或结构体成员（structure field）进行属性设置。</p>
<p>下面是常见的属性参数：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">语法格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aligned</td>
<td align="center">aligned(n)</td>
<td align="left">让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。<br> <em><strong>aligned后面必须跟2的次幂，其他的编译器报错。当我们传入1和2的时候，编译器模式都是以4字节对齐的，且只有结构体上下两个字段是char类型的才会将其合并处理</strong></em></td>
</tr>
<tr>
<td align="left">packed</td>
<td align="center">packed</td>
<td align="left">用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中.</td>
</tr>
<tr>
<td align="left">cleanup</td>
<td align="center">cleanup(func)</td>
<td align="left">声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数。<br>   指定的函数传递的参数是变量的地址;<br>   当作用域内有多个cleanup的变量时,遵守先入后出的栈式结构。<br><em><strong>cleanup的执行先于dealloc</strong></em></td>
</tr>
</tbody></table>
<h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><p>关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。</p>
<p>下面是常见的属性参数：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">语法格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aligned</td>
<td align="center">aligned(n)</td>
<td align="left">让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。<br> <em><strong>aligned后面必须跟2的次幂，其他的编译器报错。当我们传入1和2的时候，编译器模式都是以4字节对齐的，且只有结构体上下两个字段是char类型的才会将其合并处理</strong></em></td>
</tr>
<tr>
<td align="left">packed</td>
<td align="center">packed</td>
<td align="left">用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中.</td>
</tr>
<tr>
<td align="left">deprecated</td>
<td align="center">deprecated(“警告信息”)</td>
<td align="left">适用于方法、属性。告诉编译器已经过时，如果使用了，会报过时警告</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ源码解析之RemotingCommand</title>
    <url>/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/</url>
    <content><![CDATA[<p>rocketmq-remoting模块是RocketMQ消息队列中负责网络通信的模块，底层框架是依赖于Netty的。<br><br>为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ自定义了通信协议。</p>
<h1 id="通信协议及编解码方式"><a href="#通信协议及编解码方式" class="headerlink" title="通信协议及编解码方式"></a>通信协议及编解码方式</h1><p>RemotingCommand这个类封装了消息消息传输过程中的所有数据内容，并负责消息的编码和解码操作。</p>
<h2 id="RocketMQ的消息格式"><a href="#RocketMQ的消息格式" class="headerlink" title="RocketMQ的消息格式"></a>RocketMQ的消息格式</h2><p>RocketMQ的一条消息包含四个部分：<br><img src="/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" alt="消息格式.png"></p>
<ol>
<li>消息长度：消息的总长度，占4个字节</li>
<li>序列化类型&amp;消息头长度：占4个字节，第一个字节代表序列化类型，后三个字节为消息头的长度</li>
<li>消息头：RocketMQ定义的通用消息头数据加上不同请求或者响应的自定义字段</li>
<li>消息正文</li>
</ol>
<p>下面是RocketMQ官方定义的消息头的字段：</p>
<table>
<thead>
<tr>
<th>Header字段</th>
<th>类型</th>
<th>Request说明</th>
<th>Response说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td>
<td>应答响应码。0表示成功，非0则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通RPC还是onewayRPC得标志</td>
<td>区分是普通RPC还是onewayRPC得标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p>RemotingCommand类里关于消息Header的数据声明：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应码/请求操作码</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> code;</span><br><span class="line"><span class="comment">// RocketMQ定义的枚举类型，支持JAVA、CPP、PYTHON、GO、OHP、RUBY等</span></span><br><span class="line"><span class="keyword">private</span> LanguageCode language = LanguageCode.JAVA;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> version = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 请求码</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> opaque = requestId.getAndIncrement();</span><br><span class="line"><span class="comment">// flag为0表示request， flag为1表示response， flag为2或者3，表示OneWayRPC</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> remark;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; extFields;</span><br><span class="line"><span class="comment">// 不同请求类型的请求头的特殊字段的序列化处理类，与extFields搭配使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> CommandCustomHeader customHeader;</span><br><span class="line"><span class="comment">// 当前RPC的序列化方式，默认与服务器配置相同。RocketMQ支持两种序列化方式：Json以及自定义的RocketMQ消息</span></span><br><span class="line"><span class="keyword">private</span> SerializeType serializeTypeCurrentRPC = serializeTypeConfigInThisServer;</span><br></pre></td></tr></table></figure>
<h2 id="消息编码"><a href="#消息编码" class="headerlink" title="消息编码"></a>消息编码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 消息编码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1&gt; header length size，RocketMQ消息的长度，占用4个字节</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2&gt; header data length 序列化消息头并获取对应消息头的长度</span></span><br><span class="line">    <span class="keyword">byte</span>[] headerData = <span class="keyword">this</span>.headerEncode();</span><br><span class="line">    length += headerData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3&gt; body data length 消息正文的数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.body != null) &#123;</span><br><span class="line">        length += body.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配4+length个字节的缓冲区，其中4是序列化方式+表示消息头长度的数值占用的字节</span></span><br><span class="line">    ByteBuffer result = ByteBuffer.allocate(<span class="number">4</span> + length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length 编码消息数据，最开始的4个字节是消息长度</span></span><br><span class="line">    result.putInt(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header length 写入序列化类型和消息头长度的数据</span></span><br><span class="line">    result.<span class="built_in">put</span>(markProtocolType(headerData.length, serializeTypeCurrentRPC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header data 写入消息头</span></span><br><span class="line">    result.<span class="built_in">put</span>(headerData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// body data; 写入消息正文数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.body != null) &#123;</span><br><span class="line">        result.<span class="built_in">put</span>(<span class="keyword">this</span>.body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻转Bytebuffer的活动区域为写入的数据</span></span><br><span class="line">    result.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] headerEncode() &#123;</span><br><span class="line">    <span class="keyword">this</span>.makeCustomHeaderToNet();</span><br><span class="line">    <span class="comment">// 根据不同的序列化方式序列化消息头</span></span><br><span class="line">    <span class="keyword">if</span> (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) &#123;</span><br><span class="line">        <span class="keyword">return</span> RocketMQSerializable.rocketMQProtocolEncode(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RemotingSerializable.encode(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用反射获取自定义消息头相关的拓展字段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCustomHeaderToNet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customHeader != null) &#123;</span><br><span class="line">        Field[] fields = getClazzFields(customHeader.getClass());</span><br><span class="line">        <span class="keyword">if</span> (null == <span class="keyword">this</span>.extFields) &#123;</span><br><span class="line">            <span class="keyword">this</span>.extFields = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isStatic(field.<span class="built_in">getModifiers</span>())) &#123;</span><br><span class="line">                <span class="keyword">String</span> name = field.getName();</span><br><span class="line">                <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;this&quot;</span>)) &#123;</span><br><span class="line">                    Object value = null;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 利用反射打开属性的访问权限的开关</span></span><br><span class="line">                        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        value = field.<span class="built_in">get</span>(<span class="keyword">this</span>.customHeader);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="built_in">log</span>.error(<span class="string">&quot;Failed to access field [&#123;&#125;]&quot;</span>, name, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (value != null) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.extFields.<span class="built_in">put</span>(name, value.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编码消息头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">encodeHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> encodeHeader(<span class="keyword">this</span>.body != null ? <span class="keyword">this</span>.body.length : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">encodeHeader</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> bodyLength)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1&gt; header length size</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2&gt; header data length</span></span><br><span class="line">    <span class="keyword">byte</span>[] headerData;</span><br><span class="line">    headerData = <span class="keyword">this</span>.headerEncode();</span><br><span class="line"></span><br><span class="line">    length += headerData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3&gt; body data length</span></span><br><span class="line">    length += bodyLength;</span><br><span class="line">    <span class="comment">// 分配除了正文外的缓冲区</span></span><br><span class="line">    ByteBuffer result = ByteBuffer.allocate(<span class="number">4</span> + length - bodyLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    result.putInt(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header length</span></span><br><span class="line">    result.<span class="built_in">put</span>(markProtocolType(headerData.length, serializeTypeCurrentRPC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header data</span></span><br><span class="line">    result.<span class="built_in">put</span>(headerData);</span><br><span class="line"></span><br><span class="line">    result.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编码消息的序列化类型加消息头长度的信息， 占据4个字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] markProtocolType(<span class="keyword">int</span> source, SerializeType type) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 序列化类型：0表示json而1表示RocketMQ</span></span><br><span class="line">    result[<span class="number">0</span>] = type.getCode();</span><br><span class="line">    result[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((source &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    result[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((source &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    result[<span class="number">3</span>] = (<span class="keyword">byte</span>) (source &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息编码-1"><a href="#消息编码-1" class="headerlink" title="消息编码"></a>消息编码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息解码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RemotingCommand <span class="title">decode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.wrap(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">return</span> decode(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息解码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RemotingCommand <span class="title">decode</span><span class="params">(<span class="keyword">final</span> ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息长度</span></span><br><span class="line">    <span class="keyword">int</span> length = byteBuffer.limit();</span><br><span class="line">    <span class="comment">// 取消息的前四个字节，其中第一个字节表示序列化类型后三个字节表示消息头的长度，byteBuffer的position向后移动四个字节</span></span><br><span class="line">    <span class="keyword">int</span> oriHeaderLen = byteBuffer.getInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> headerLength = getHeaderLength(oriHeaderLen);</span><br><span class="line">    <span class="comment">// 获取消息头数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] headerData = <span class="keyword">new</span> <span class="keyword">byte</span>[headerLength];</span><br><span class="line">    byteBuffer.<span class="built_in">get</span>(headerData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化headerData为RemotingCommand对象</span></span><br><span class="line">    RemotingCommand cmd = headerDecode(headerData, getProtocolType(oriHeaderLen));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息正文的长度：消息的长度减去固定的四个字节（序列化类型+消息头的长度字节）再减去消息头的长度</span></span><br><span class="line">    <span class="keyword">int</span> bodyLength = length - <span class="number">4</span> - headerLength;</span><br><span class="line">    <span class="keyword">byte</span>[] bodyData = null;</span><br><span class="line">    <span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 填充消息正文内容</span></span><br><span class="line">        bodyData = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyLength];</span><br><span class="line">        byteBuffer.<span class="built_in">get</span>(bodyData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充RemotingCommand的body属性</span></span><br><span class="line">    cmd.body = bodyData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeaderLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取最后三个字节，表示消息头的长度</span></span><br><span class="line">    <span class="keyword">return</span> length &amp; <span class="number">0xFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RemotingCommand <span class="title">headerDecode</span><span class="params">(<span class="keyword">byte</span>[] headerData, SerializeType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON:</span><br><span class="line">            RemotingCommand resultJson = RemotingSerializable.decode(headerData, RemotingCommand.class);</span><br><span class="line">            resultJson.setSerializeTypeCurrentRPC(type);</span><br><span class="line">            <span class="keyword">return</span> resultJson;</span><br><span class="line">        <span class="keyword">case</span> ROCKETMQ:</span><br><span class="line">            RemotingCommand resultRMQ = RocketMQSerializable.rocketMQProtocolDecode(headerData);</span><br><span class="line">            resultRMQ.setSerializeTypeCurrentRPC(type);</span><br><span class="line">            <span class="keyword">return</span> resultRMQ;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializeType <span class="title">getProtocolType</span><span class="params">(<span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 截断保留source的第一个字节，表示序列化类型</span></span><br><span class="line">    <span class="keyword">return</span> SerializeType.valueOf((<span class="keyword">byte</span>) ((source &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>链表反转系列</title>
    <url>/2019/04/05/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>限制:</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= 节点个数 &lt;= <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * public <span class="keyword">class</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> next;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) &#123; <span class="keyword">val</span> = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">    public <span class="type">ListNode</span> reverseList(<span class="type">ListNode</span> head) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之extern</title>
    <url>/2019/03/17/C-%E4%B9%8Bextern/</url>
    <content><![CDATA[<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。<br>此外extern也可用来进行链接指定。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ol>
<li><p>与“C”连用进行链接指定</p>
<p>比如: </p>
<p><code>extern &quot;C&quot; void fun(int a, int b);</code></p>
<p> 则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名</p>
</li>
<li><p>extern声明变量</p>
<p> 比如，头文件 testExample.h</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br></pre></td></tr></table></figure>
<p> 源程序 testExample.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>主函数 main.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，a，b的声明也可放在main.c中。此时，就不需要包含 testExample.h这个头文件了。代码如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>extern声明函数</p>
<p>比如，头文件 testExample.h</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>源程序 testExample.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数 main.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(a, b) = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，a，b的声明也可放在main.c中。此时，就不需要包含 testExample.h这个头文件了。代码如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(a, b) = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="extern-与-static"><a href="#extern-与-static" class="headerlink" title="extern 与 static"></a>extern 与 static</h1><p>(1) extern 表明引用外部其他模块/单元定义的变量或者函数。</p>
<p>(2) static 表示静态变量，分配内存的时候, 存储在静态区而不是栈上面。static修饰全局变量的作用域只能是本身的编译单元，所以一般定义static全局变量时，都把它放在原文件中而不是头文件。</p>
<p><em><strong>extern和static不能同时修饰一个变量</strong></em></p>
<h1 id="extern-与-const"><a href="#extern-与-const" class="headerlink" title="extern 与 const"></a>extern 与 const</h1><p>C++中const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中。但是const可以与extern连用来声明该常量可以作用于其他编译模块中。当与extern一起合作的时候，它的特性就跟extern的一样，表示一个定义了的全局变量。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>JVM类加载机制</title>
    <url>/2018/03/24/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>一个.java文件从编码完成到最终执行，一般主要包括两个过程：编译和运行，其中编译就是通过javac编译器将.java文件转换成编译成字节码.class文件；然后运行则是把.class文件交给JVM执行的过程。<br>一个Java类从字节代码到能够在JVM中被使用，需要经过加载、链接和初始化这三个步骤，我们称之为类加载。下面我们就开始详解这三个步骤。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>把class字节码文件通过类加载器装载入内存中的阶段。在该阶段，JVM需要完成：</p>
<ol>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ol>
<p>类加载器可以分为：</p>
<ol>
<li>引导类加载器：最顶层的类加载器，负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被JVM认可（按文件名识别，如rt.jar）的类。</li>
<li>扩展类加载器：负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li>
<li>应用类加载器：可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，该类加载器就是默认的类加载器。</li>
<li>用户自定义的类加载器：继承自java.lang.ClassLoader类。</li>
</ol>
<p>类加载器的工作方式：</p>
<ol>
<li>双亲委派模型：加载过程中会先检查类是否被已加载，检查顺序是自底向上，从用户自定义类加载器到引导类加载器逐层检查，只要某个classloader已加载，就视为已加载此类，保证此类只会被所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</li>
<li>代理模式：指的是一个类加载器既可以自己完成Java类的加载工作，也可以代理给其它的类加载器来完成。由于代理模式的存在，启动一个类的加载过程的类加载器和最终加载这个类的类加载器可能并不是一个。前者称为初始类加载器，而后者称为定义类加载器。一个Java类的定义类加载器是该类所导入的其它Java类的初始类加载器。</li>
</ol>
<p>使用双亲委派模型的意义：</p>
<ol>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>链接阶段又分为验证、准备和解析。<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。如果验证过程出现错误的话，会抛出java.lang.VerifyError错误。主要验证以下几个内容：</li>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范，比如开头是否是以0xCAFEBABE开头，版本号是否是JVM支持处理的，以及常量表中是否存在不被支持的数据类型等</li>
<li>元数据验证：我理解就是语义分析，看是否存在比如继承了final修饰的类的这些不符合java语言规范要求的问题</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行，比如校验符号引用中通过全限定名是否能够找到对应的类，校验符号引用中的访问权限是否可被当前类访问等？</li>
</ol>
<p>验证阶段很重要，但是对于程序的运行期没有影响，所以并非必要的。可以通过-Xverifynone参数来关闭大部分的java类的验证行为，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>该阶段的目的是：为类的静态变量分配内存，并将其初始化为默认值。注意，这里的默认值不是我们在程序中设置的值，而是Java的初始值。JVM对于各数据类型指定的默认值如下：</p>
<ol>
<li>8大基本类型的默认值为0</li>
<li>引用类型的默认值为null</li>
<li><em><strong>被final和static共同修饰的变量（静态常量）的默认值为我们程序中设定的值，</strong></em> 例如：final static int a = 100，则准备阶段中a的初值就是100。<br>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>该阶段的目的是把常量池中的符号引用转换为直接引用。<br><br>符号引用是一个给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息的字面量。<br><br>直接引用可以理解为一个内存地址，或者一个偏移量或一个间接定位到目标的句柄。比如类方法，类变量的直接引用是指向方法区的指针；<br><br>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>该阶段主要为类的静态变量赋予正确的初始值，JVM主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
<p>JVM类初始化步骤</p>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<p>JVM类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ol>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Annotation(java注解)</title>
    <url>/2018/03/18/Annotation-java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>注解提供一种为程序元素设置元数据的方法。元数据就是关于数据的数据，可以用来生成文档，进行代码分析或者使编译器对元数据进行编译检查。<br>可以使用注解解析工具或编译器对其进行解析，也可以指定注解在编译期或运行期有效。<br>　　　　　　　　　　　　　　　　　　　　　　<br>注解的基本原则是：无论增加或者删除一个注解都不能对代码造成干扰。</p>
<h2 id="系统注解"><a href="#系统注解" class="headerlink" title="系统注解"></a>系统注解</h2><p>　　1. Override：保证override函数的正确生明</p>
<p>　　2. Deprecated：对于过时不再使用的函数添加该注解，当该函数被调用时，编译时会提示。与javadoc的@deprecated类似，但前者不可以带参数</p>
<p>　　3. SupressWarnings： 配合参数表示关闭特定的警告信息。参数有：</p>
<p>　　　　　|参数名 | 语法格式 |<br>        | :— |  :—  |<br>     　　| deprecation | 使用了过时的类或者方法的警告  |<br>    　　 | unchecked |  执行了未检查的转换时警告  |<br>        | fallthrough |  switch语句某case下没有break语句直接通往下一个case的警告  |<br>    　　 | path |  在类路径或者源文件路径中存在不存在的路径的警告  |<br>        | finally |  finally语句不能正确执行的警告 |<br>        | all |  关闭所有警告信息  |</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><pre><code>元注解的作用就是负责注解其他注解。Java5定义了4个标准的Meta Annotation类型，它们被用来提供对其它 Annotation类型作说明。
</code></pre>
<p>　　　1. Target</p>
<p>　　　　　　作用：用于描述注解的使用范围，即被描述的注解可以用在什么地方</p>
<p>　　　　　　用法： @Target(ElementType.参数,…)</p>
<p>　　　　　　参数：</p>
<p>　　　　　　　　　CONSTRUCTOR：用于描述构造器</p>
<p>　　　　　　　　　FIELD：用于描述域</p>
<p>　　　　　　　　　LOCAL_VARIABLE：用于描述局部变量</p>
<p>　　　　　　　　　METHOD：用于描述方法</p>
<p>　　　　　　　　　PACKAGE：用于描述包</p>
<p>　　　　　　　　　PARAMETER：用于描述参数</p>
<p>　　　　　　　　　TYPE：用于描述类、接口(包括注解类型) 或enum声明</p>
<p>　　　2. Retention</p>
<p>　　　　　　作用： 标识该Annotation的生命周期</p>
<p>　　　　　　用法：　@Retention(RetentionPolicy.参数)</p>
<p>　　　　　　参数：</p>
<p>　　　　　　　　　SOURCE:在源文件中有效（即源文件保留），被编译器丢弃</p>
<p>　　　　　　　　　CLASS:在class文件中有效（即class保留），编译在class文件中的Annotation可能会被虚拟机忽略</p>
<p>　　　　　　　　　RUNTIME:在运行时有效（即运行时保留）</p>
<p>　　　3. Documented</p>
<p>　　　　　　<em><strong>@Documented是一个标记注解，没有成员</strong></em></p>
<p>　　　　　　作用：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。</p>
<p>　　　4.　Inherited</p>
<p>　　　　　　<em><strong>@Inherited 是一个标记注解。</strong></em></p>
<p>　　　　　  　作用: 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个Annotation将被用于该class的子类。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>　　　Annotation类型使用关键字@interface而非interface，注意开头的@符号。interface可以被实现或者继承，Annotation不可以。</p>
]]></content>
  </entry>
</search>
