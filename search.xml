<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis数据结构之List_1.adlist</title>
    <url>/2021/04/08/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BList_1.adlist/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Redis的底层包含9种基本数据结构：</p>
<ol>
<li>String：</li>
<li>List: 列表对象的编码可以是ziplist或者linkedlist。</li>
<li>Hash</li>
<li>Set</li>
<li>Sorted Set</li>
<li>bitmap</li>
<li>GeoHash</li>
<li>HyperLogLog</li>
<li>Streams</li>
</ol>
<p>本文侧重从源码的角度分析下List的底层数据结构之一——adlist.c。</p>
<h3 id="什么是adlist？"><a href="#什么是adlist？" class="headerlink" title="什么是adlist？"></a>什么是adlist？</h3><p>adlist是 redis 自定义的一种双向链表，3.0及以前运用于list结构中，在3.2以后被quicklist取代。</p>
<h3 id="adlist的数据结构"><a href="#adlist的数据结构" class="headerlink" title="adlist的数据结构"></a>adlist的数据结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">typedef struct listIter &#123;</span><br><span class="line">    listNode *next;</span><br><span class="line">    int direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    listNode *head; &#x2F;&#x2F; 头节点</span><br><span class="line">    listNode *tail; &#x2F;&#x2F; 尾节点</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">    unsigned long len; &#x2F;&#x2F; 链表长度</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="创建一个新的双端链表-listCreate"><a href="#创建一个新的双端链表-listCreate" class="headerlink" title="创建一个新的双端链表 listCreate"></a>创建一个新的双端链表 listCreate</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list *listCreate(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct list *list;</span><br><span class="line"></span><br><span class="line">    if ((list &#x3D; zmalloc(sizeof(*list))) &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    list-&gt;head &#x3D; list-&gt;tail &#x3D; NULL; &#x2F;&#x2F; 头节点和尾节点都指向空</span><br><span class="line">    list-&gt;len &#x3D; 0;</span><br><span class="line">    list-&gt;dup &#x3D; NULL;</span><br><span class="line">    list-&gt;free &#x3D; NULL;</span><br><span class="line">    list-&gt;match &#x3D; NULL;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除链表所有元素-listEmpty"><a href="#移除链表所有元素-listEmpty" class="headerlink" title="移除链表所有元素 listEmpty"></a>移除链表所有元素 listEmpty</h4><p>该函数移除链表所有元素，但是并不释放链表结构体本身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void listEmpty(list *list)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current &#x3D; list-&gt;head;</span><br><span class="line">    len &#x3D; list-&gt;len;</span><br><span class="line">    &#x2F;&#x2F; 遍历释放链表节点</span><br><span class="line">    while(len--) &#123;</span><br><span class="line">        next &#x3D; current-&gt;next;</span><br><span class="line">        if (list-&gt;free) list-&gt;free(current-&gt;value); &#x2F;&#x2F; 在释放节点之前先free其value</span><br><span class="line">        zfree(current);</span><br><span class="line">        current &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;head &#x3D; list-&gt;tail &#x3D; NULL;</span><br><span class="line">    list-&gt;len &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的<code>listRelease</code>函数负责释放整个链表内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void listRelease(list *list)</span><br><span class="line">&#123;</span><br><span class="line">    listEmpty(list);</span><br><span class="line">    zfree(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="新增链表节点"><a href="#新增链表节点" class="headerlink" title="新增链表节点"></a>新增链表节点</h4><ol>
<li>在链表头部添加节点： <code>list *listAddNodeHead(list *list, void *value)</code> </li>
<li>在链表尾部添加节点： <code>list *listAddNodeTail(list *list, void *value)</code></li>
<li>根据after参数决定在old_node的前面还是后面插入。 after &gt; 0： 在后面插入；当after = 0时，插入在前面<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node &#x3D; zmalloc(sizeof(*node))) &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value &#x3D; value;</span><br><span class="line">    if (after) &#123;</span><br><span class="line">        node-&gt;prev &#x3D; old_node;</span><br><span class="line">        node-&gt;next &#x3D; old_node-&gt;next;</span><br><span class="line">        if (list-&gt;tail &#x3D;&#x3D; old_node) &#123;</span><br><span class="line">            list-&gt;tail &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;next &#x3D; old_node;</span><br><span class="line">        node-&gt;prev &#x3D; old_node-&gt;prev;</span><br><span class="line">        if (list-&gt;head &#x3D;&#x3D; old_node) &#123;</span><br><span class="line">            list-&gt;head &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node-&gt;prev !&#x3D; NULL) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node-&gt;next !&#x3D; NULL) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除链表节点"><a href="#删除链表节点" class="headerlink" title="删除链表节点"></a>删除链表节点</h4>需要注意的是待删除的节点是链表的头节点或者尾节点的特殊处理，最后别忘了释放该节点对应的内存空间<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void listDelNode(list *list, listNode *node)</span><br><span class="line">&#123;</span><br><span class="line">    if (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next &#x3D; node-&gt;next;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;head &#x3D; node-&gt;next;</span><br><span class="line">    if (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev &#x3D; node-&gt;prev;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;tail &#x3D; node-&gt;prev;</span><br><span class="line">    if (list-&gt;free) list-&gt;free(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    list-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c</tag>
        <tag>缓存</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode153之寻找旋转排序数组中的最小值</title>
    <url>/2021/04/08/LeetCode%E4%B9%8B%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h3 id="LeetCode153-寻找旋转排序数组中的最小值"><a href="#LeetCode153-寻找旋转排序数组中的最小值" class="headerlink" title="LeetCode153. 寻找旋转排序数组中的最小值"></a>LeetCode153. 寻找旋转排序数组中的最小值</h3><p>题目：<br><br>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br><br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br><br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br><br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]]。<br><br>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<span id="more"></span>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p>提示：<br><br>　　n == nums.length<br><br>　　1 &lt;= n &lt;= 5000<br><br>　　-5000 &lt;= nums[i] &lt;= 5000<br><br>　　nums 中的所有整数 互不相同<br><br>　　nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>老套路，有序数组，查找用什么——<em><strong>二分</strong></em>，上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public int findMin(int[] nums) &#123;</span><br><span class="line">    int low &#x3D; 0, high &#x3D; nums.length -1, middle &#x3D; 0;</span><br><span class="line">    while (low &lt;&#x3D; high) &#123;</span><br><span class="line">        if (nums[low] &lt;&#x3D; nums[high]) &#123;  &#x2F;&#x2F; 判断是否原排序数组，如果是，第一个元素就是最小元素</span><br><span class="line">            return nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        middle &#x3D; (high - low) &#x2F; 2 + low;</span><br><span class="line">        &#x2F;&#x2F; 上面判断过不是原数组，所以通过比较得出有序区间，找最小值应对应的区间</span><br><span class="line">        if (nums[middle] &gt;&#x3D; nums[low]) &#123; </span><br><span class="line">            low &#x3D; middle + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            high &#x3D; middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode之搜索旋转排序数组I&amp;II</title>
    <url>/2021/04/07/LeetCode%E4%B9%8B%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84I&amp;II/</url>
    <content><![CDATA[<h3 id="LeetCode33-搜索旋转排序数组I"><a href="#LeetCode33-搜索旋转排序数组I" class="headerlink" title="LeetCode33 搜索旋转排序数组I"></a>LeetCode33 搜索旋转排序数组I</h3><p>题目：<br><br>　　整数数组 nums 按升序排列，数组中的值互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p>提示：<br><br>　　1 &lt;= nums.length &lt;= 5000<br><br>　　-10^4 &lt;= nums[i] &lt;= 10^4<br><br>　　nums 中的每个值都 独一无二<br><br>　　题目数据保证 nums 在预先未知的某个下标上进行了旋转<br><br>　　-10^4 &lt;= target &lt;= 10^4</p>
<p>进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>虽然用暴力解题法只要通过遍历，时间复杂度O(n)就可以完成，但是别忘了有序数组的查找用二分的小技巧哦。<br>废话不多说，上二分代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int search1(int[] nums, int target) &#123;</span><br><span class="line">        if (nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; nums.length -1;</span><br><span class="line">        int middle &#x3D; 0;</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            middle &#x3D; (high-low)&#x2F;2+low;</span><br><span class="line">            if (nums[middle] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return middle;</span><br><span class="line">            &#125; else if (nums[middle] &lt; nums[high]) &#123;</span><br><span class="line">                if (nums[middle] &lt; target &amp;&amp; nums[high] &gt;&#x3D; target) &#123;</span><br><span class="line">                    low &#x3D; middle +1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    high &#x3D; middle -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (nums[middle] &gt; target &amp;&amp; nums[low] &lt;&#x3D; target) &#123;</span><br><span class="line">                    high &#x3D; middle -1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    low &#x3D; middle +1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return  -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>二分的细节才是核心，请注意 <code>while (low &lt;= high)</code> 中的等号。</p>
<h3 id="LeetCode81-搜索旋转排序数组-II"><a href="#LeetCode81-搜索旋转排序数组-II" class="headerlink" title="LeetCode81 搜索旋转排序数组 II"></a>LeetCode81 搜索旋转排序数组 II</h3><p>题目：<br><br>　　已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 <br>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>提示：<br><br>　　1 &lt;= nums.length &lt;= 5000<br><br>　　-104 &lt;= nums[i] &lt;= 104<br><br>　　题目数据保证 nums 在预先未知的某个下标上进行了旋转<br><br>　　-104 &lt;= target &lt;= 104</p>
<p>进阶：<br><br>　　这是搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br><br>　　这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>依旧是二分查找，确定有序区间，如果确定不了的话就左右指针各移动以下，缩圈再分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean search2(int[] nums, int target) &#123;</span><br><span class="line">    if (nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int low &#x3D; 0, high &#x3D; nums.length-1, middl &#x3D; 0;</span><br><span class="line">    while (low &lt;&#x3D; high) &#123;</span><br><span class="line">        middl &#x3D; (high - low) &#x2F; 2 + low;</span><br><span class="line">        if (nums[middl] &#x3D;&#x3D; target || nums[low] &#x3D;&#x3D; target || nums[high] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            return  true;</span><br><span class="line">        &#125; else if (nums[middl] &gt; nums[low]) &#123;</span><br><span class="line">            if ((target &lt; nums[middl] ) &amp;&amp; (target &gt;&#x3D; nums[low])) &#123;</span><br><span class="line">                high &#x3D; middl -1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                low &#x3D; middl + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (nums[middl] &lt; nums[high]) &#123;</span><br><span class="line">            if ((target &lt;&#x3D; nums[high] ) &amp;&amp; (target &gt; nums[middl])) &#123;</span><br><span class="line">                low &#x3D; middl + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high &#x3D; middl - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于时间复杂度是有影响的。假设极端情况下假设全是与target不同的重复字符，那么按照上述程序的时间复杂度应该为O(n).</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>功能安全ISO26262-4</title>
    <url>/2021/04/06/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8ISO26262-4/</url>
    <content><![CDATA[<p>Part 4: Product development at the system level<br>本文件由技术委员会ISO/TC22、道路车辆小组委员会、SC32、电气和电子元件以及一般系统方面编写。</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>ISO26262系列标准改编IEC61508系列标准，以满足道路车辆内电气和/或电子（E/E）系统的行业特定需求。<br>此改编功能适用于由电气、电子和软件组件组成的安全相关系统的安全生命周期内的所有活动。<br>安全是道路车辆发展中的关键问题之一。汽车功能的开发和集成加强了对功能安全的需求和提供满足功能安全目标的证据的需求。<br><br>随着技术复杂性、软件内容和机电实现的增长趋势，系统故障和随机硬件故障的风险不断增加，这些风险被考虑在功能安全范围内。ISO26262系列标准包括:通过提供适当的要求和流程来降低这些风险的指导。<br><br>为了达到功能安全的目的，ISO26262系列标准：</p>
<ol>
<li>为汽车安全生命周期提供参考，并支持在生命周期阶段要开展的活动的定制化，即开发、生产、运营、服务和退役；</li>
<li>提供基于汽车特定风险来确定完整性等级的方法（ASILS）；</li>
<li>使用ASILS指定使用ISO26262哪些要求适用于避免不合理的剩余风险；</li>
<li>为功能安全管理、设计、实现、检验、验证和确认措施提供要求；</li>
<li>为客户和供应商间的关系提供要求。<span id="more"></span>
ISO26262系列标准关注通过包括安全机制在内的安全措施达到的E/E系统的功能安全。它还提供了一个框架，其他技术（比如机械、液压和启动设备等）的安全相关的系统可以在该框架上考虑。<br><br>功能安全的实现受开发过程（包括需求规范、设计、实施、集成、验证、验证和配置等活动）、生产服务过程和管理过程的影响。<br><br>安全与共同的功能导向和质量导向的活动和工作产品交织在一起。ISO26262系列标准解决了这些活动和工作产品的安全相关方面。<br><br>图1显示了ISO26262系列标准的总体结构。ISO26262系列标准是基于v型模型，作为产品开发不同阶段的参考过程模型。在下图中：</li>
</ol>
<ul>
<li>阴影“V”表示ISO26262-3、ISO26262-4、ISO26262-5、ISO26262-6和ISO26262-7之间的互连；</li>
<li>对于摩托车：<ul>
<li>ISO26262-12：2018，第8条支持ISO26262-3；</li>
<li>ISO26262-12：2018，第9条和第10条支持ISO26262-4；</li>
</ul>
</li>
<li>具体条款以如下方式表示：m-n，其中m表示特定部分的数量，n表示该部分内的条款数量。</li>
</ul>
<p><img src="/2021/04/06/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8ISO26262-4/Figure1.png" alt="Figure 1 — Overview of the ISO 26262 series of standards.png"></p>
<h3 id="1-Scope"><a href="#1-Scope" class="headerlink" title="1 Scope"></a>1 Scope</h3><p>本文件旨在适用于安全相关系统，包括一个或多个电气和/或电子（E/E）系统，并以及那些安装在系列生产道路车辆上（不包括轻便摩托车）的系统。本文件不涉及特殊车辆上的独特机电系统，如为残疾司机设计的机电系统。</p>
<p><strong>注意：</strong> 存在其他专用应用专用安全标准，可补充ISO26262系列标准，反之亦然。</p>
<p>在本文件发布日期前发布的系统及其组件，或在本文件发布日期之前已经在开发的系统及其组件，不受本版本的范围的限制。本文档基于更改通过定制安全生命周期，解决了在本文档发布前发布的现有系统及其组件的更改，并解决了未根据本文档开发的现有系统和根据本文档开发的系统的集成问题。</p>
<p>本文件阐述了由安全相关的E/E系统的故障行为所造成的可能危险，包括系统间交互。它不处理与触电、火灾、烟雾、热、辐射、毒性、易燃性、反应性、腐蚀、能量释放和类似危险相关的危险，除非这些危险是由安全相关的E/E系统的故障行为直接引起。</p>
<p>本文件描述了一个功能安全的框架，以帮助开发与安全相关的机电系统。该框架旨在将功能安全活动集成到公司特定的开发框架中。有些要求对实现产品的功能安全具有明确的技术关注；其他要求则涉及开发过程，因此可被视为证明组织在功能安全方面的能力的过程要求。</p>
<p>本文件未处理E/E系统的名义上的性能。</p>
<p>本文件规定了汽车应用在系统级别上的产品开发需求，包括：</p>
<ul>
<li>系统级别产品开发启动的一般主题</li>
<li>技术安全需求的规范</li>
<li>技术安全的概念</li>
<li>系统架构设计</li>
<li>项目集成和测试</li>
<li>安全验证</li>
</ul>
<h3 id="2-Normative-reference"><a href="#2-Normative-reference" class="headerlink" title="2 Normative reference"></a>2 Normative reference</h3><p>文本中提到下列文件，其部分或全部内容构成本文件的要求。对于有日期的参考文献，仅对所引用的版本适用。对于未注明日期的参考文件，适用参考文件的最新版本（包括任何修订版）。</p>
<p>ISO 26262-1:2018, Road vehicles — Functional safety — Part 1: Vocabulary</p>
<p>ISO 26262-2:2018, Road vehicles — Functional safety — Part 2: Management of functional safety</p>
<p>ISO 26262-3:2018, Road vehicles — Functional safety — Part 3: Concept phase</p>
<p>ISO 26262-5:2018, Road vehicles — Functional safety — Part 5: Product development at the hardware level</p>
<p>ISO 26262-6:2018, Road vehicles — Functional safety — Part 6: Product development at the software level</p>
<p>ISO 26262-7:2018, Road vehicles — Functional safety — Part 7: Production, operation, service and decommissioning</p>
<p>ISO 26262-8:2018, Road vehicles — Functional safety — Part 8: Supporting processes</p>
<p>ISO 26262-9:2018, Road vehicles — Functional safety — Part 9: Automotive Safety Integrity Level (ASIL)-oriented and safety-oriented analyses</p>
<h3 id="3-Terms-and-definitions"><a href="#3-Terms-and-definitions" class="headerlink" title="3 Terms and definitions"></a>3 Terms and definitions</h3><p>在本文件中，在ISO26262-1：2018中给出的术语、定义和缩写术语均适用。</p>
<p>ISO和IEC维护术语数据库进行标准化：</p>
<ul>
<li>IEC电子百科：在<a href="http://www.electropedia.org/">http://www.electropedia.org/</a></li>
<li>ISO在线浏览平台：在<a href="https://www.iso.org/obp">https://www.iso.org/obp</a></li>
</ul>
<h3 id="4-Requirements-for-compliance"><a href="#4-Requirements-for-compliance" class="headerlink" title="4 Requirements for compliance"></a>4 Requirements for compliance</h3><h4 id="4-1-purpose"><a href="#4-1-purpose" class="headerlink" title="4.1 purpose"></a>4.1 purpose</h4><p>本条款描述了如何：</p>
<ol>
<li>实现符合ISO26262系列标准；</li>
<li>解释ISO26262系列标准中使用的表；以及</li>
<li>解释每个条款的适用性，具体取决于相关的ASIL。</li>
</ol>
<h4 id="4-2-General-requirements"><a href="#4-2-General-requirements" class="headerlink" title="4.2 General requirements"></a>4.2 General requirements</h4><p>当要求符合ISO26262系列标准时，应满足每项要求，除非应用了以下其中一条：</p>
<ol>
<li>根据ISO26262-2定制安全活动，表明该要求不适用；</li>
<li>不符合的理由可接受，并根据ISO26262-2进行评估。</li>
</ol>
<p>信息性内容，包括说明和示例，仅用于理解或澄清相关要求的指导，不得解释为要求本身或完整或详尽。</p>
<p>安全活动的结果将作为工作产品提供。“先决条件”是作为上阶段工作产品提供的信息。鉴于一个条款的某些要求是依赖于ASIL的，或者可能是定制的，对应的工作产品可能不需要作为先决条件。</p>
<p>“进一步支持信息”是可以考虑的信息，但在某些情况下，ISO26262系列标准不要求这些信息作为先前阶段的工作产品，并可由不同的负责职能安全活动的人员或组织的外部来源提供。</p>
<h3 id="4-3-Interpretations-of-tables"><a href="#4-3-Interpretations-of-tables" class="headerlink" title="4.3 Interpretations of tables"></a>4.3 Interpretations of tables</h3><p>表是规范性的或信息丰富的。表中列出的不同方法有助于对实现符合相应要求的信心水平。表中的每个方法都是：</p>
<ol>
<li>一个连续的条目（由最左列中的序列号标记，例如。1,2、3)或</li>
<li>一个替代条目(在最左的列中标记有一个数字，后面跟着一个字母，例如。2a，2b，2c)。</li>
</ol>
<p>对于连续的条目，所有列出的根据ASIL应用高度推荐和推荐的方法。允许替代表中未列出的其他人高度推荐或推荐的方法，在这种情况下，应说明这些方法符合相应要求的原因。如果可以在不选择所有条目的情况下，给出符合相应要求的理由，则不需要对省略的方法提供进一步的理由。</p>
<p>对于可替代的条目，应按照指示的ASIL采用适当的方法组合，不管它们是否存在方法列表中。如果列出的方法的ASIL的推荐程度不同，则应该优先选择推荐度较高的方法。应该给出选定的组合方法或者单一的方法符合相应要求的说明。</p>
<p><strong>注意：</strong> 基于列表中给出的方法的说明是充分的，但是这并不意味着对列表中未列出的方法存在偏差。</p>
<p>对于每一个方法，相应方法使用的推荐程度取决于ASIL，其分类如下：</p>
<ol>
<li>“++”表示强烈建议对已识别的ASIL使用该方法。</li>
<li>“+“表示对已识别的ASIL推荐使用该方法。</li>
<li>”o“表示该方法不推荐支持或者反对将该方法用于已识别的ASIL。</li>
</ol>
<h4 id="4-4-ASIL-dependent-requirements-and-recommendations"><a href="#4-4-ASIL-dependent-requirements-and-recommendations" class="headerlink" title="4.4 ASIL-dependent requirements and recommendations"></a>4.4 ASIL-dependent requirements and recommendations</h4>]]></content>
      <categories>
        <category>功能安全</category>
      </categories>
      <tags>
        <tag>Road vehicles — Functional safety</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之递归</title>
    <url>/2021/04/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h4 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h4><p>用我弟弟最爱挂在嘴边哄孩子的一个故事来阐述下什么是递归吧：<br>从前有座山，<br>山里有座庙，<br>庙里有个老和尚，<br>老和尚给小和尚讲故事：<br>从前有座山，<br>山里有座庙<br>…<br>(其实我每次听我弟讲这个故事的时候，我就想拿小锤锤揍他…）。<br>这个故事阐述了一种递归的特性，就是<code>不停的自我调用</code>。与递归算法唯一的不同点就是该故事是没有结尾的，是一个死循环。 所以我们总结以下什么是递归算法：</p>
<p><code>递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解</code></p>
<h4 id="递归算法的设计要素"><a href="#递归算法的设计要素" class="headerlink" title="递归算法的设计要素"></a>递归算法的设计要素</h4><ol>
<li>明确递归终止条件（不然就像上面的故事一样，死循环）</li>
<li>给出递归终止时的处理办法；</li>
<li>提取重复的逻辑，缩小问题规模。<span id="more"></span>
<h4 id="递归的模板函数"><a href="#递归的模板函数" class="headerlink" title="递归的模板函数"></a>递归的模板函数</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"> domethod（level, para1, para2...） &#123;</span><br><span class="line">    <span class="regexp">//</span> 判断终止条件</span><br><span class="line">    <span class="keyword">if</span> (level 达到终止条件) &#123;</span><br><span class="line">        <span class="regexp">//</span> doSomthing</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    processData(para1, para2, ...); <span class="regexp">//</span> 真正的功能</span><br><span class="line">    domethod（level+<span class="number">1</span>， v1，v2，...） <span class="regexp">//</span> 往下递归</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>processData</code>与<code>domethod</code>的顺序按照具体业务逻辑的设计是可以调换的。</li>
</ol>
<h4 id="递归需要注意的问题："><a href="#递归需要注意的问题：" class="headerlink" title="递归需要注意的问题："></a>递归需要注意的问题：</h4><ol>
<li>可能会出现重复的子问题，需要记忆操作，否则会造成大量重复计算</li>
<li>递归的深度过深的时候，会造成StackOverFlow问题。</li>
</ol>
<h4 id="递归的经典算法题"><a href="#递归的经典算法题" class="headerlink" title="递归的经典算法题"></a>递归的经典算法题</h4><ol>
<li>斐波拉契函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int fib(int N) &#123;</span><br><span class="line">    if (N &#x3D;&#x3D; 0 || N &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return N;</span><br><span class="line">    &#125;</span><br><span class="line">    return fib(N - 1) + fib(N - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码就是出现了大量的重复计算，代码简洁但是效率较低，优化后的代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int fib(int n) &#123;</span><br><span class="line">    if (n &lt; 2) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    int a &#x3D; 0, b &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; n ; i++) &#123;</span><br><span class="line">       b +&#x3D; a;</span><br><span class="line">       a &#x3D; b - a;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LeetCode50 计算x的n次方问题<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static double myPow(double x, int n) &#123;</span><br><span class="line">    if(n&#x3D;&#x3D;0)  return 1;</span><br><span class="line">    if(n&#x3D;&#x3D;1)  return x;</span><br><span class="line">    if(n&#x3D;&#x3D;-1) return 1&#x2F;x;</span><br><span class="line"></span><br><span class="line">    double half&#x3D;myPow(x,n&#x2F;2);</span><br><span class="line">    double rest&#x3D;myPow(x,n%2);</span><br><span class="line">    return half*half*rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>snprintf与sprintf</title>
    <url>/2021/04/01/snprintf%E4%B8%8Esprintf/</url>
    <content><![CDATA[<h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h3><p>原型： <code> int snprintf(char *str, int n, char * format [, argument, ...]);</code><br>参数：</p>
<ol>
<li>str – 目标字符串。</li>
<li>n – 拷贝字节数(Bytes)。</li>
<li>format – 格式化成字符串。</li>
<li>… – 可变参数。</li>
</ol>
<p>函数功能：将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，n 为要写入的字符的最大数目，超过 size 会被截断：</p>
<ol>
<li>如果格式化后的字符串长度小于等于 n，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0；</li>
<li>如果格式化后的字符串长度大于 n，超过 n 的部分会被截断，只将其中的 (n-1) 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度。<span id="more"></span>
<h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h3>原型： <code>  int sprintf(char *str, const char *format, ...)；</code><br>参数：</li>
<li>str – 目标字符串。</li>
<li>format – 格式化成字符串。</li>
<li>… – 可变参数。</li>
</ol>
<p>函数功能：将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中；<br><br>返回值：如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p>
<h3 id="snprintf-与-sprintf的区别："><a href="#snprintf-与-sprintf的区别：" class="headerlink" title="snprintf 与 sprintf的区别："></a>snprintf 与 sprintf的区别：</h3><ol>
<li>越界判断：<ol>
<li>sprintf进行处理时不会进行越界判断，如果欲写入的字符串长度大于等于字符数组长度,会直接对之后的内存进行覆盖，极不安全。</li>
<li>snprintf则会考虑到字符数组的长度，若字符数组长度为n字节，则最多写入n-1字节，然后再在后面加上’\0’。不会越界操作，这也是其被作为sprintf的替代函数的理由。</li>
</ol>
</li>
<li>返回值：<ol>
<li>sprinf返回的是实际写入的字符串长度。 </li>
<li>snprintf返回的是欲写入的字符串长度。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>sysconf操作</title>
    <url>/2021/04/01/sysconf%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在学习redis的源码过程中认识了一个系统函数sysconf()，因为对其知之甚少，所以抽点时间来了解下该函数的原理以及作用。</p>
<h3 id="什么是sysconf函数"><a href="#什么是sysconf函数" class="headerlink" title="什么是sysconf函数"></a>什么是sysconf函数</h3><p>因为sysconf是一个系统调用函数，所以可以通过man操作来了解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SYSCONF(3)                                                                            Linux Programmer&#39;s Manual                                                                            SYSCONF(3)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       sysconf - get configuration information at run time</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">       long sysconf(int name);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       POSIX allows an application to test at compile or run time whether certain options are supported, or what the value is of certain configurable constants or limits.</span><br><span class="line"></span><br><span class="line">       At compile time this is done by including &lt;unistd.h&gt; and&#x2F;or &lt;limits.h&gt; and testing the value of certain macros.</span><br><span class="line"></span><br><span class="line">       At  run  time, one can ask for numerical values using the present function sysconf().  One can ask for numerical values that may depend on the filesystem in which a file resides using fpath‐</span><br><span class="line">       conf(3) and pathconf(3).  One can ask for string values using confstr(3).</span><br><span class="line"></span><br><span class="line">       The values obtained from these functions are system configuration constants.  They do not change during the lifetime of a process.</span><br><span class="line"></span><br><span class="line">       For options, typically, there is a constant _POSIX_FOO that may be defined in &lt;unistd.h&gt;.  If it is undefined, one should ask at run time.  If it is defined to -1, then  the  option  is  not</span><br><span class="line">       supported.   If  it is defined to 0, then relevant functions and headers exist, but one has to ask at run time what degree of support is available.  If it is defined to a value other than -1</span><br><span class="line">       or 0, then the option is supported.  Usually the value (such as 200112L) indicates the year and month of the POSIX revision describing the option.  Glibc uses the value 1 to indicate support</span><br><span class="line">       as long as the POSIX revision has not been published yet.  The sysconf() argument will be _SC_FOO.  For a list of options, see posixoptions(7).</span><br><span class="line"></span><br><span class="line">       For  variables  or limits, typically, there is a constant _FOO, maybe defined in &lt;limits.h&gt;, or _POSIX_FOO, maybe defined in &lt;unistd.h&gt;.  The constant will not be defined if the limit is un‐</span><br><span class="line">       specified.  If the constant is defined, it gives a guaranteed value, and a greater value might actually be supported.  If an application wants to take advantage of values  which  may  change</span><br><span class="line">       between systems, a call to sysconf() can be made.  The sysconf() argument will be _SC_FOO.</span><br><span class="line"></span><br><span class="line">   POSIX.1 variables</span><br><span class="line">       We give the name of the variable, the name of the sysconf() argument used to inquire about its value, and a short description.</span><br><span class="line"></span><br><span class="line">       First, the POSIX.1 compatible values.</span><br><span class="line"></span><br><span class="line">       ARG_MAX - _SC_ARG_MAX</span><br><span class="line">              The maximum length of the arguments to the exec(3) family of functions.  Must not be less than _POSIX_ARG_MAX (4096).</span><br><span class="line"></span><br><span class="line">       CHILD_MAX - _SC_CHILD_MAX</span><br><span class="line">              The maximum number of simultaneous processes per user ID.  Must not be less than _POSIX_CHILD_MAX (25).</span><br><span class="line"></span><br><span class="line">       HOST_NAME_MAX - _SC_HOST_NAME_MAX</span><br><span class="line">              Maximum length of a hostname, not including the terminating null byte, as returned by gethostname(2).  Must not be less than _POSIX_HOST_NAME_MAX (255).</span><br><span class="line"></span><br><span class="line">       LOGIN_NAME_MAX - _SC_LOGIN_NAME_MAX</span><br><span class="line">              Maximum length of a login name, including the terminating null byte.  Must not be less than _POSIX_LOGIN_NAME_MAX (9).</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>根据man操作的结果可以得到该函数是包含在头文件”unistd.h“中的，用来获取运行是的配置信息，例如页大小、最大页数、cpu个数、打开句柄的最大个数等等。在下表中，列出了部分变量和常量。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值(Name Value)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_SC_THREADS</td>
<td>_POSIX_THREADS</td>
<td>支持线程</td>
</tr>
<tr>
<td>_SC_THREAD_ATTR_STACKADDR</td>
<td>_POSIX_THREAD_ATTR_STACKADDR</td>
<td>支持线程栈地址属性</td>
</tr>
<tr>
<td>_SC_THREAD_ATTR_STACKSIZE</td>
<td>_POSIX_THREAD_ATTR_STACKSIZE</td>
<td>支持线程栈大小属性</td>
</tr>
<tr>
<td>_SC_THREAD_STACK_MIN</td>
<td>PTHREAD_STACK_MIN</td>
<td>线程栈存储区的最小大小，以字节为单位</td>
</tr>
<tr>
<td>_SC_THREAD_THREADS_MAX</td>
<td>PTHREAD_THREADS_MAX</td>
<td>每个进程的最大线程数</td>
</tr>
<tr>
<td>_SC_THREAD_KEYS_MAX</td>
<td>PTHREAD_KEYS_MAX</td>
<td>每个进程关键字的最大数目</td>
</tr>
<tr>
<td>_SC_THREAD_PRIO_INHERIT</td>
<td>_POSIX_THREAD_PRIO_INHERIT</td>
<td>支持优先级继承选项</td>
</tr>
<tr>
<td>_SC_THREAD_PRIO</td>
<td><em>POSIX_THREAD_PRIO</em></td>
<td>支持线程优先级选项</td>
</tr>
<tr>
<td>_SC_THREAD_PRIORITY_SCHEDULING</td>
<td>_POSIX_THREAD_PRIORITY_SCHEDULING</td>
<td>支持线程优先级调度选项</td>
</tr>
<tr>
<td>_SC_THREAD_PROCESS_SHARED</td>
<td>_POSIX_THREAD_PROCESS_SHARED</td>
<td>支持进程共享同步</td>
</tr>
<tr>
<td>_SC_THREAD_SAFE_FUNCTIONS</td>
<td>_POSIX_THREAD_SAFE_FUNCTIONS</td>
<td>支持线程安全函数</td>
</tr>
<tr>
<td>_SC_THREAD_DESTRUCTOR_ITERATIONS</td>
<td>_PTHREAD_THREAD_DESTRUCTOR_ITERATIONS</td>
<td>决定在线程退出时尝试销毁线程特定数据的尝试次数</td>
</tr>
<tr>
<td>_SC_CHILD_MAX</td>
<td>CHILD_MAX</td>
<td>每个UID允许的最大进程数目</td>
</tr>
<tr>
<td>_SC_PRIORITY_SCHEDULING</td>
<td>_POSIX_PRIORITY_SCHEDULING</td>
<td>支持进程调度</td>
</tr>
<tr>
<td>_SC_REALTIME_SIGNALS</td>
<td>_POSIX_REALTIME_SIGNALS</td>
<td>支持实时信号</td>
</tr>
<tr>
<td>_SC_XOPEN_REALTIME_THREADS</td>
<td>_XOPEN_REALTIME_THREADS</td>
<td>支持X/Open POSIX实时线程特性组</td>
</tr>
<tr>
<td>_SC_STREAM_MAX</td>
<td>STREAM_MAX</td>
<td>决定进程能够打开的流的数目</td>
</tr>
<tr>
<td>_SC_SEMAPHORES</td>
<td>_POSIX_SEMAPHORES</td>
<td>支持信号量</td>
</tr>
<tr>
<td>_SC_SEM_NSEMS_MAX</td>
<td>SEM_NSEMS_MAX</td>
<td>决定线程能够拥有的信号量的最大数目</td>
</tr>
<tr>
<td>_SC_SEM_VALUE_MAX</td>
<td>SEM_VALUE_MAX</td>
<td>决定信号量的最大值</td>
</tr>
<tr>
<td>_SC_SHARED_MEMORY_OBJECTS</td>
<td>_POSIX_SHARED_MEMORY_OBJECTS</td>
<td>支持共享内存对象</td>
</tr>
</tbody></table>
<p>返回值：如果出错，那么函数返回 -1 ，并适当地设置 errno 。当没有错误发生时， -1 也是一个合法的返回值。因此，程序要检查错误，应该在调用 sysconf() 之前将 errno 设置为 0 ，然后，如果返回 -1，则检验到错误。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>位操作</title>
    <url>/2021/04/01/%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="基本的位操作"><a href="#基本的位操作" class="headerlink" title="基本的位操作"></a>基本的位操作</h3><ol>
<li><p>与：&amp; 每一位进行比较，两位都为1，结果为1，否则为0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 0 1 1 1 --&gt;(23)[10]</span><br><span class="line">&amp; 1 1 0 0 1 --&gt;(25)[10]</span><br><span class="line">------------------------------</span><br><span class="line">  1 0 0 0 1 --&gt;(17)[10]</span><br></pre></td></tr></table></figure></li>
<li><p>或：| 每一位进行比较，两位有一位是1，结果就是1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 0 1 1 1 --&gt;(23)[10]</span><br><span class="line">| 1 1 0 0 1 --&gt;(25)[10]</span><br><span class="line">------------------------------</span><br><span class="line">  1 1 1 1 1 --&gt;(31)[10]</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>非：~ 每一位进行比较，按位取反（符号位也要取反）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ 1 0 1 1 1 --&gt;(23)[10]</span><br><span class="line">------------------------------</span><br><span class="line">  0 1 0 0 0 --&gt;(8)[10]</span><br></pre></td></tr></table></figure></li>
<li><p>异或：^ 每一位进行比较，相同为0，不同为1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 0 1 1 1 --&gt;(23)[10]</span><br><span class="line">^ 1 1 0 0 1 --&gt;(25)[10]</span><br><span class="line">------------------------------</span><br><span class="line">  0 1 1 1 0 --&gt;(14)[10]</span><br></pre></td></tr></table></figure></li>
<li><p>左移: &lt;&lt; 整体左移，右边空出位补零，左边位舍弃。(<strong>可用于乘法运算，速度更快性能更高，左移一位相当于乘以2</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 8;</span><br><span class="line">a &lt;&lt; 3;</span><br><span class="line">移位前：0000 0000 0000 0000 0000 0000 0000 1000 --&gt;(8)[10]</span><br><span class="line">移位后：0000 0000 0000 0000 0000 0000 0100 0000 --&gt;(64)[10]  相当于 X 2^3</span><br></pre></td></tr></table></figure></li>
<li><p>右移：&gt;&gt; 整体右移，左边空出位补零或补1（负数补1，整数补0），右边位舍弃。(<strong>可用于除法运算，速度更快性能更高，右移一位相当于除以2</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int a &#x3D; 8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">移位前：0000 0000 0000 0000 0000 0000 0000 1000 --&gt;(8)[10]</span><br><span class="line">移位后：0000 0000 0000 0000 0000 0000 0000 0001 --&gt;(1)[10] 相当于 &#x2F; 2^3</span><br><span class="line"></span><br><span class="line">int a &#x3D; -8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">移位前：1111 1111 1111 1111 1111 1111 1111 1000 --&gt;(-8)[10]</span><br><span class="line">移位前：1111 1111 1111 1111 1111 1111 1111 1111 --&gt;(-1)[10] </span><br></pre></td></tr></table></figure></li>
<li><p>无符号右移: &gt;&gt;&gt; 不管正数还是负数都左边位都补0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned int a &#x3D; 8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">移位前：0000 0000 0000 0000 0000 0000 0000 1000 --&gt;(8)[10]</span><br><span class="line">移位后：0000 0000 0000 0000 0000 0000 0000 0001 --&gt;(1)[10] 相当于 &#x2F; 2^3</span><br><span class="line"></span><br><span class="line">int a &#x3D; -8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">移位前：1111 1111 1111 1111 1111 1111 1111 1000 --&gt;(-8)[10]</span><br><span class="line">移位前：0001 1111 1111 1111 1111 1111 1111 1111 --&gt;(536870911)[10] </span><br></pre></td></tr></table></figure>
<h3 id="进阶位运算"><a href="#进阶位运算" class="headerlink" title="进阶位运算"></a>进阶位运算</h3><p>位运算很多情况下都是很二进制扯上关系的，所以我们要判断是否是否位运算，很多情况下都会把他们拆分成二进制，然后观察特性，或者就是利用与，或，异或的特性来观察。</p>
</li>
<li><p>判断奇偶数:<br>常见的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( n % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; n 是个奇数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位运算：如果把 n 以二进制的形式展示的话，我们只需要通过判断最后一个二进制位是 1 还是 0 就行了。如果是 1 的话，代表是奇数，如果是 0 则代表是偶数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (n &amp; 1 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; n 是个奇数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>交换两个数:<br>传统的做法是利用一个临时变量，比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int tmp &#x3D; x;</span><br><span class="line">x &#x3D; y;</span><br><span class="line">y &#x3D; tmp;</span><br></pre></td></tr></table></figure>
<p>但是如果不允许借助临时变量时，那么就可以通过位运算来操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; x ^ y   &#x2F;&#x2F; （1）</span><br><span class="line">y &#x3D; x ^ y   &#x2F;&#x2F; （2）</span><br><span class="line">x &#x3D; x ^ y </span><br></pre></td></tr></table></figure></li>
<li><p>计算x的n次方，废话不多说，上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pow(int n)&#123;</span><br><span class="line">    int sum &#x3D; 1;</span><br><span class="line">    int tmp &#x3D; x;</span><br><span class="line">    while(n !&#x3D; 0)&#123;</span><br><span class="line">        if(n &amp; 1 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            sum *&#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp *&#x3D; tmp;</span><br><span class="line">        n &#x3D; n &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Redis内存分配_zmalloc</title>
    <url>/2021/04/01/Redis%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-zmalloc/</url>
    <content><![CDATA[<p>zmalloc是一个对内存分配进行简单封装的库。</p>
<h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>从zmalloc.h文件中可以看到如下的宏定义：可以看到redis的内存分配根据不同的宏定义分别是对不同的库：google的tcmalloc、jemalloc以及libc的malloc进行了封装。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_TCMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">&quot;tcmalloc-&quot;</span> __xstr(TC_VERSION_MAJOR) <span class="meta-string">&quot;.&quot;</span> __xstr(TC_VERSION_MINOR))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;google/tcmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TC_VERSION_MAJOR == 1 &amp;&amp; TC_VERSION_MINOR &gt;= 6) || (TC_VERSION_MAJOR &gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) tc_malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Newer version of tcmalloc required&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(USE_JEMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB (<span class="meta-string">&quot;jemalloc-&quot;</span> __xstr(JEMALLOC_VERSION_MAJOR) <span class="meta-string">&quot;.&quot;</span> __xstr(JEMALLOC_VERSION_MINOR) <span class="meta-string">&quot;.&quot;</span> __xstr(JEMALLOC_VERSION_BUGFIX))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jemalloc/jemalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (JEMALLOC_VERSION_MAJOR == 2 &amp;&amp; JEMALLOC_VERSION_MINOR &gt;= 1) || (JEMALLOC_VERSION_MAJOR &gt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) je_malloc_usable_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Newer version of jemalloc required&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__APPLE__)  操作系統提供的宏，如果打开就可以提供一个 malloc_size ()，用于查看指针指向内存的大小，该函数是libc不提供的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZMALLOC_LIB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZMALLOC_LIB <span class="meta-string">&quot;libc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GLIBC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_MALLOC_SIZE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zmalloc_size(p) malloc_usable_size(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_JEMALLOC) &amp;&amp; defined(JEMALLOC_FRAG_HINT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_DEFRAG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>tcmalloc：由google用于优化C++多线程应用而开发。Redis 需要1.6以上的版本。</li>
<li>jemalloc：第一次用在FreeBSD 的allocator，于2005年释出的版本。强调降低碎片化，可扩展的并行支持。Redis需要2.1以上版本。</li>
<li>libc：最常使用的libc库。GNU libc，默认使用此allocator。<span id="more"></span>
<h4 id="获取分配器信息"><a href="#获取分配器信息" class="headerlink" title="获取分配器信息"></a>获取分配器信息</h4><code>zmalloc_get_allocator_info</code>仅在使用jemalloc时有效<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_JEMALLOC)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *active,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *resident)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> epoch = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">    *allocated = *resident = *active = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Update the statistics cached by mallctl. */</span></span><br><span class="line">    sz = <span class="keyword">sizeof</span>(epoch);</span><br><span class="line">    je_mallctl(<span class="string">&quot;epoch&quot;</span>, &amp;epoch, &amp;sz, &amp;epoch, sz);</span><br><span class="line">    sz = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="comment">/* Unlike RSS, this does not include RSS from shared libraries and other non</span></span><br><span class="line"><span class="comment">     * heap mappings. */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.resident&quot;</span>, resident, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike resident, this doesn&#x27;t not include the pages jemalloc reserves</span></span><br><span class="line"><span class="comment">     * for re-use (purge will clean that). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.active&quot;</span>, active, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Unlike zmalloc_used_memory, this matches the stats.resident by taking</span></span><br><span class="line"><span class="comment">     * into account all allocations done by this process (not only zmalloc). */</span></span><br><span class="line">    je_mallctl(<span class="string">&quot;stats.allocated&quot;</span>, allocated, &amp;sz, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 该情况下没什么作用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zmalloc_get_allocator_info</span><span class="params">(<span class="keyword">size_t</span> *allocated,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *active,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">size_t</span> *resident)</span> </span>&#123;</span><br><span class="line">    *allocated = *resident = *active = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="1-zmalloc"><a href="#1-zmalloc" class="headerlink" title="1. zmalloc"></a>1. zmalloc</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(<span class="built_in">size</span>); <span class="comment">// 内存分配失败，则调用oom处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));  <span class="comment">// 更新已经分配的内存大小变量used_memory，zmalloc_size会返回ptr指向的内存大小</span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = <span class="built_in">size</span>;</span><br><span class="line">    update_zmalloc_stat_alloc(<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分，用来表示当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0) <span class="comment">// tcmalloc和jemalloc函数族提供了计算已分配空间大小的函数（分别是tcmallocsize和mallocsize），所以就不需要单独分配一段空间记录大小了。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long)) 对于sun os，使用sizeof(long long)定长字段记录。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t)) <span class="comment">// 对于linux，使用sizeof(sizet)定长字段记录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>update_zmalloc_stat_alloc：更新全局变量used_memory(redis内存使用情况)的值，注意需要字节对齐<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    size_t _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="built_in">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="built_in">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="built_in">long</span>)<span class="number">-1</span>)); \ <span class="comment">// 判断内存是否对齐以进行对齐填充</span></span><br><span class="line">    atomicIncr(used_memory,__n); \ <span class="comment">// redis自己实现原子操作函数</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
与之对应的还有一个<code>#define update_zmalloc_stat_free(__n)</code></li>
</ol>
<h4 id><a href="#" class="headerlink" title></a></h4><p>功能与zmalloc一样，区别在于zcalloc对分配的内存进行初始化，为0</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(<span class="built_in">size</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = <span class="built_in">size</span>;</span><br><span class="line">    update_zmalloc_stat_alloc(<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>malloc (size) 功能：在内存的动态存储区中分配一块长度为”size” 字节的连续区域。</li>
<li>calloc(n,size) 功能：在内存动态存储区中分配n块长度为“size”字节的连续区域，返回值为该区域的首地址。<h4 id="zrealloc"><a href="#zrealloc" class="headerlink" title="zrealloc"></a>zrealloc</h4>调整内存大小：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span> &amp;&amp; ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        zfree(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(<span class="built_in">size</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">// 强转取值</span></span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = <span class="built_in">size</span>;</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    update_zmalloc_stat_alloc(<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
realloc(void* ptr, unsigned newsize)：给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度。<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><h4 id="zfree"><a href="#zfree" class="headerlink" title="zfree"></a>zfree</h4>释放内存并减少全局变量used_memory的值<figure class="highlight plain"><figcaption><span>zfree(void *ptr) &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifndef HAVE_MALLOC_SIZE</span><br><span class="line">    void *realptr;</span><br><span class="line">    size_t oldsize;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (ptr &#x3D;&#x3D; NULL) return;</span><br><span class="line">#ifdef HAVE_MALLOC_SIZE</span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    free(ptr);</span><br><span class="line">#else</span><br><span class="line">    realptr &#x3D; (char*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize &#x3D; *((size_t*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    free(realptr);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="zmalloc-get-rss"><a href="#zmalloc-get-rss" class="headerlink" title="zmalloc_get_rss"></a>zmalloc_get_rss</h3>该函数本意是获取实际使用的内存大小，依赖于特定平台的，实现细节如下，对应于不同的宏定义：<h4 id="HAVE-PROC-STAT"><a href="#HAVE-PROC-STAT" class="headerlink" title="HAVE_PROC_STAT"></a>HAVE_PROC_STAT</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROC_STAT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE); <span class="comment">// sysconf函数是根据参数获取系统执行的配置信息，这里指页大小</span></span><br><span class="line">    <span class="keyword">size_t</span> rss;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">&quot;/proc/%d/stat&quot;</span>,getpid()); <span class="comment">//将格式化的数据写入字符串filename，并返回字符串长度</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 以只读模式打开 /proc/&lt;pid&gt;/stat 文件。然后从中读入4096个字符到字符数组buf中。如果失败就关闭文件描述符fd</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>); </span><br><span class="line">    rss *= page; <span class="comment">// rss获得的是内存页的页数，而page保存的是每个内存页的大小，相乘之后就表示RSS实际的内存大小了。</span></span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HAVE-TASKINFO"><a href="#HAVE-TASKINFO" class="headerlink" title="HAVE_TASKINFO"></a>HAVE_TASKINFO</h4>ios的操作系统函数么？不是很懂，等抽空再刷<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HAVE_TASKINFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">task_t</span> task = MACH_PORT_NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> <span class="title">t_info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> t_info_count = TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task_for_pid(current_task(), getpid(), &amp;task) != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    task_info(task, TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)&amp;t_info, &amp;t_info_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t_info.resident_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FreeBSD"><a href="#FreeBSD" class="headerlink" title="FreeBSD"></a><strong>FreeBSD</strong></h4>__FreeBSD__是C/C++的预编译宏，一种类似于UNIX的操作系统<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__FreeBSD__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kinfo_proc</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> infolen = <span class="keyword">sizeof</span>(info);</span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">4</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_KERN;</span><br><span class="line">    mib[<span class="number">1</span>] = KERN_PROC;</span><br><span class="line">    mib[<span class="number">2</span>] = KERN_PROC_PID;</span><br><span class="line">    mib[<span class="number">3</span>] = getpid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">4</span>, &amp;info, &amp;infolen, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)info.ki_rssize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h4>在没有任何宏定义开关的情况下，该函数直接返回全局使用的内存大小的值，即used_memory_size<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* If we can&#x27;t get the RSS in an OS-specific way for this system just</span></span><br><span class="line"><span class="comment">     * return the memory usage we estimated in zmalloc()..</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Fragmentation will appear to be always 1 (no fragmentation)</span></span><br><span class="line"><span class="comment">     * of course... */</span></span><br><span class="line">    <span class="keyword">return</span> zmalloc_used_memory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取进程-proc-pid-smaps某个字段的字节大小"><a href="#获取进程-proc-pid-smaps某个字段的字节大小" class="headerlink" title="获取进程/proc/pid/smaps某个字段的字节大小"></a>获取进程/proc/pid/smaps某个字段的字节大小</h3>当pid为-1时，指向当前进程/proc/self/smaps<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PROC_SMAPS)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        fp = fopen(<span class="string">&quot;/proc/self/smaps&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(filename,<span class="keyword">sizeof</span>(filename),<span class="string">&quot;/proc/%ld/smaps&quot;</span>,pid);</span><br><span class="line">        fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// fgets函数;从指定的流fp读取一行，并把它存储在line所指向的字符串内。</span></span><br><span class="line">    <span class="comment">// 当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">line</span>,<span class="keyword">sizeof</span>(<span class="built_in">line</span>),fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="built_in">line</span>,field,flen) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(<span class="built_in">line</span>,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                bytes += strtol(<span class="built_in">line</span>+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>; <span class="comment">// line+flen（要查询的字段的长度）所指向的位置就是字段名后面的空格处了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* Get sum of the specified field from libproc api call.</span></span><br><span class="line"><span class="comment"> * As there are per page value basis we need to convert</span></span><br><span class="line"><span class="comment"> * them accordingly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that AnonHugePages is a no-op as THP feature</span></span><br><span class="line"><span class="comment"> * is not supported in this platform</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field, <span class="keyword">long</span> pid)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_regioninfo</span> <span class="title">pri</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (proc_pidinfo(pid, PROC_PIDREGIONINFO, <span class="number">0</span>, &amp;pri, PROC_PIDREGIONINFO_SIZE) ==</span><br><span class="line">	PROC_PIDREGIONINFO_SIZE) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(field, <span class="string">&quot;Private_Dirty:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">size_t</span>)pri.pri_pages_dirtied * <span class="number">4096</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(field, <span class="string">&quot;Rss:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">size_t</span>)pri.pri_pages_resident * <span class="number">4096</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(field, <span class="string">&quot;AnonHugePages:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ((<span class="keyword">void</span>) field);</span><br><span class="line">    ((<span class="keyword">void</span>) pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c</tag>
        <tag>缓存</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存结构与Java对象的内存布局</title>
    <url>/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天跟老大讨论C++的char*与char[]的内存大小的计算方式，引申出指针和对象的问题，也就顺便扯到了java没有指针只有对象的特性。<br>既然扯到了java的对象，那么我就来扯一扯java的内存结构以及java对象在内存中的布局。</p>
<h3 id="java的内存结构"><a href="#java的内存结构" class="headerlink" title="java的内存结构"></a>java的内存结构</h3><p><img src="/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM内存结构.png"><br>JVM的运行时数据区主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中程序计数器，虚拟机栈，本地方法栈是线程私有的；而堆和方法区属于线程共享区域。</p>
<span id="more"></span>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>也就是我们常说的PC寄存器。<br>每个线程刚创建时，会创建一个程序计数器，它的生命周期跟线程的生命周期一致，属于线程私有的。<br><strong>主要作用：</strong> 保存着当前线程执行的虚拟机字节码指令的内存地址，是当前线程所执行程序的字节码的行号指示器，通过它可以获取下一条需要执行的字节码指令。<br>程序计数器是唯一一个在Java规范中没有规定任何OutOfMemory场景的区域。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>所有线程共享的一块内存区域，对象实例几乎都在这分配内存。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。</p>
<h3 id="java对象在内存中的布局"><a href="#java对象在内存中的布局" class="headerlink" title="java对象在内存中的布局"></a>java对象在内存中的布局</h3><p><img src="/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="对象实例内存结构.png"></p>
<p>如上图所示，共分为三个部分：对象头、实例数据以及对齐填充(非必须项)。</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。元素的对象头共分为两个部分：markword与类型指针，但是数组元素还存在第三个部分——数组长度。</p>
<ol>
<li>MarkWord：用于存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。<br><img src="/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/MarKWord.png" alt="MarKWord.png"><ul>
<li>锁标志位：用于区分锁状态或者GC，只有为11时表示对象等待GC回收，其余都是锁状态</li>
<li>是否偏向锁：由于无锁和偏向锁的锁标识都是 01，所以引入一位的偏向锁标识位用来区分。</li>
<li>分代年龄：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li>
<li>对象的hashcode：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。</li>
<li>偏向锁的线程ID（JavaThread）：偏向锁模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</li>
<li>epoch：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li>
<li>指向栈中锁记录的指针：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。</li>
<li>指向互斥锁的指针：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。</li>
</ul>
</li>
<li>类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4>主要是存放类的数据信息，父类的信息，对象字段属性信息。<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4>为了字节对齐，填充的数据，不是必须的。<br>默认情况下，Java虚拟机堆中对象的起始地址需要对齐至8的倍数。如果一个对象用不到8N个字节则需要对其填充，以此来补齐对象头和实例数据占用内存之后剩余的空间大小。如果对象头和实例数据已经占满了JVM所分配的内存空间，那么就不用再进行对齐填充了。</li>
</ol>
]]></content>
      <categories>
        <category>JVM原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化与反序列化</title>
    <url>/2021/04/01/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨儿评审公司项目的某通信模块的设计，本次评审的着重点在于序列化的设计，因此结束后趁热打铁的总结下序列化与反序列化。</p>
<h3 id="什么是序列化以及为什么要学序列化"><a href="#什么是序列化以及为什么要学序列化" class="headerlink" title="什么是序列化以及为什么要学序列化"></a>什么是序列化以及为什么要学序列化</h3><p><strong>序列化：</strong> 将对象转换成二进制数据的过程<br><br><strong>反序列化：</strong> 把字节序列还原为对象的过程</p>
<p>序列化最终的目的是为了对象可以跨平台存储，和进行网络传输，即IO。而支持的数据格式是字节数组，因此对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，即序列化与反序列化。</p>
<h3 id="常见的序列化框架"><a href="#常见的序列化框架" class="headerlink" title="常见的序列化框架"></a>常见的序列化框架</h3><p>序列化框架的核心就是设计可以将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个新的对象，来完成反序列化的协议。</p>
<span id="more"></span>
<h4 id="1-Json"><a href="#1-Json" class="headerlink" title="1. Json"></a>1. Json</h4><p>JSON 是典型的 Key-Value 方式，没有数据类型，是一种文本型序列化框架。<br><br><strong>优点：</strong>　简单、可读性高<br><br><strong>缺点：</strong>　</p>
<ol>
<li>空间开销大,意味着需要巨大的内存和磁盘开销；</li>
<li>JSON 没有类型，对Java这种强类型语言不太友好，因为后者需要通过反射统一解决，所以性能不会太好。</li>
</ol>
<h4 id="2-Hessian"><a href="#2-Hessian" class="headerlink" title="2. Hessian"></a>2. Hessian</h4><p>Hessian是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。<br><br><strong>优点：</strong> 空间开销小，兼容性和稳定性比较高<br><br><strong>缺点：</strong> 缺少对Java部分数据类型的支持，比如：</p>
<ol>
<li>Linked 系列，LinkedHashMap、LinkedHashSet 等，但是可以通过扩展 CollectionDeserializer 类修复；</li>
<li>Locale 类，可以通过扩展 ContextSerializerFactory 类修复；</li>
<li>Byte/Short 反序列化的时候变成 Integer。</li>
</ol>
<h4 id="3-Protobuf"><a href="#3-Protobuf" class="headerlink" title="3. Protobuf"></a>3. Protobuf</h4><p>Protobuf是Google提出的一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，支持 Java、Python、C++、Go 等语言。<br><br>Protobuf定义了一种文件类型.proto，定义了文件格式；然后使用不同语言的 IDL 编译器将上面的文件生成序列化工具类<br><br><strong>优点：</strong></p>
<ol>
<li>序列化后体积相比 JSON、Hessian 小很多；</li>
<li>IDL 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器；</li>
<li>序列化反序列化速度很快，不需要通过反射获取类型；</li>
<li>消息格式升级和兼容性不错，可以做到向后兼容。</li>
</ol>
<h3 id="如何选择序列化？"><a href="#如何选择序列化？" class="headerlink" title="如何选择序列化？"></a>如何选择序列化？</h3><p>从以下几个点考虑来选择序列化框架：</p>
<ol>
<li>性能和效率：因为序列化与反序列化过程是网络通信数据传输中一个必不可少的环节。</li>
<li>空间开销：因为序列化生成的文件大小对网络传输的性能有影响，序列化的文件过大还会导致网络传输延迟。</li>
<li>通用性和兼容性：因为序列化协议的通用性和兼容性直接关系到服务调用的稳定性和可用率的，因此对于服务的性能来说，服务的可靠性显然更加重要。</li>
<li>安全性：存在漏洞的序列化协议会带来服务入侵的风险。</li>
</ol>
]]></content>
      <categories>
        <category>编码</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
        <tag>RPC</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之sizeof</title>
    <url>/2021/03/31/Linux%E7%9A%84load-average/C++%E4%B9%8BsizeOf%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在看Redis6.0的源码，发现一个出现频率还不低的C库函数，再加上自己之前的了解不够全面，于是就在复习与学习中不断总结与收获啦。<br><br>题外话：Redis是一个存储在内存上的缓存数据库，所以会对内存的使用是抠之又抠。</p>
<h3 id="什么是sizeof"><a href="#什么是sizeof" class="headerlink" title="什么是sizeof"></a>什么是sizeof</h3><p>sizeof是C语言中保留的关键字，也可以认为是一种单目运算符，其作用是返回一个对象或者类型所占的内存字节数。<br><br>MSDN上的解释为：<br>　　The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type (including aggregate types).<br>This keyword returns a value of type size_t.<br>　　sizeof关键字给出了变量或者类型（包含聚合类型）存储时的字节数，其返回值类型为size_t。</p>
<span id="more"></span>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>sizeof有三种语法形式，如下：</p>
<ol>
<li>sizeof( object ); // sizeof( 对象 )，对象可以是各种类型的变量，以及表达式。</li>
<li>sizeof( type_name ); // sizeof( 类型 );</li>
<li>sizeof object; // sizeof 对象；等价于1<br><br>sizeof对对象求内存大小，最终都是转换为对对象的数据类型进行求值；用于表达式时，值为表达式的最终结果的数据类型的大小<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4>　　基本数据类型是指short、int、long、float、double等简单内置数据类型。由于它们的内存大小是和系统相关的，所以在不同的系统下取值可能不同。<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4>　　结构体成员按照定义时的顺序依次存储在连续的内存空间，但是结构体的大小并不是简单的把所有成员大小相加，而是需要考虑到系统的字节对齐问题。<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">    字节对齐: 计算机存储系统中以<span class="keyword">Byte</span>为单位存储数据，不同数据类型所占的空间不同。计算机为了快速的读写数据，默认情况下将数据存放在某个地址的起始位置，如：<span class="keyword">int</span>默认存储在地址能被</span><br><span class="line"><span class="number">4</span>整除的起始位置，<span class="keyword">char</span>可以存放在任何地址位置（被<span class="number">1</span>整除）等。这样字节对齐有助于加快 计算机的取数速度，否则就得多花指令周期了。</span><br></pre></td></tr></table></figure>
结构体的字节对齐一般满足三个准则：</li>
<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li>
<li>结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节<br><br><em><strong>即结构体大小结果要为成员中最大字节的整数倍。</strong></em><br><br> 示例1如下，sizeof（stu1）的结果是12。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu1</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">     <span class="keyword">int</span> i;  </span><br><span class="line">     <span class="keyword">char</span> c;  </span><br><span class="line">     <span class="keyword">int</span> j;  </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
示例2如下，sizeof（stu3）的结果是12而sizeof（stu4）的结果是8。<br><br><strong>考虑到字节对齐，因此结构体成员的顺序会影响结构体存储在内存中的大小。</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu3</span>  </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">       <span class="keyword">char</span> c1;   </span><br><span class="line">       <span class="keyword">int</span> i;  </span><br><span class="line">       <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu4</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">       <span class="keyword">char</span> c1;  </span><br><span class="line">       <span class="keyword">char</span> c2;  </span><br><span class="line">       <span class="keyword">int</span> i;  </span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>Redis数据结构之SDS</title>
    <url>/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Redis的底层包含9种基本数据结构：</p>
<ol>
<li>String：使用一种叫简单动态字符串（SDS）的数据类型来实现。</li>
<li>List</li>
<li>Hash</li>
<li>Set</li>
<li>Sorted Set</li>
<li>bitmap</li>
<li>GeoHash</li>
<li>HyperLogLog</li>
<li>Streams</li>
</ol>
<p>本文侧重从源码的角度分析下String的底层数据结构——sds.c。</p>
<h3 id="什么是sds"><a href="#什么是sds" class="headerlink" title="什么是sds"></a>什么是sds</h3><p>字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p><img src="/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/SDS%E7%BB%93%E6%9E%84.png" alt="SDS结构.png"></p>
<span id="more"></span>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在3.2版本以前SDS只有一种数据结构，到了3.2版本以后SDS根据存储的内容会选择不同的数据结构，以到达节省内存的效果！<br><br>3.2版本以前的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用的字节数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，存储字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.2版本以后：利用（__attribute __(( __packed __))这个声明来告诉编译器取消内存对齐优化，节省内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">// 已经使用的长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">//buf 分配的长度，等于buf[]的总长度-1，因为buf有包括一个/0的结束符</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">//只有3位有效位，因为类型的表示就是0到4，所有这个8位的flags 有5位没有被用到</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="创建sds字符串"><a href="#创建sds字符串" class="headerlink" title="创建sds字符串"></a>创建sds字符串</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">sds sdsnewlen(<span class="keyword">const</span> void *init, size_t initlen) &#123;</span><br><span class="line">    void *<span class="keyword">sh</span>; <span class="comment">// 指向整个sds开始的地方</span></span><br><span class="line">    sds s; <span class="comment">// 指向sds的buf开始的位置</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">type</span> = sdsReqType(initlen); <span class="comment">// 根据buffer长度来确定使用的sds类型</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> == SDS_TYPE_5 &amp;&amp; initlen == 0) <span class="keyword">type</span> = SDS_TYPE_8;</span><br><span class="line">    int hdrlen = sdsHdrSize(<span class="keyword">type</span>); <span class="comment">// 获取对应类型的结构体的长度</span></span><br><span class="line">    unsigned <span class="keyword">char</span> *fp; <span class="comment">// struct中的flag指针，表示结构体类型</span></span><br><span class="line">    <span class="keyword">sh</span> = s_malloc(hdrlen+initlen+1); <span class="comment">// 给sds分配内存空间：String头加上字符缓冲区长度以及缓冲区的‘\0’结束符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sh</span> == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT) <span class="comment">//判断是否是init阶段，非init阶段则初始化内存空间为0</span></span><br><span class="line">        init = NULL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        memset(<span class="keyword">sh</span>, 0, hdrlen+initlen+1);</span><br><span class="line">    s = (<span class="keyword">char</span>*)<span class="keyword">sh</span>+hdrlen; <span class="comment">// s指向buf的开始位置</span></span><br><span class="line">    fp = ((unsigned <span class="keyword">char</span>*)s)-1; <span class="comment">// flag指向buf前一个字节的位置</span></span><br><span class="line">    switch(<span class="keyword">type</span>) &#123;</span><br><span class="line">        case SDS_TYPE_5: &#123;</span><br><span class="line"><span class="comment">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(8,s);</span><br><span class="line">            <span class="keyword">sh</span>-&gt;len = initlen;</span><br><span class="line">            <span class="keyword">sh</span>-&gt;alloc = initlen;</span><br><span class="line"><span class="comment">            *fp = type;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(16,s);</span><br><span class="line">            <span class="keyword">sh</span>-&gt;len = initlen;</span><br><span class="line">            <span class="keyword">sh</span>-&gt;alloc = initlen;</span><br><span class="line"><span class="comment">            *fp = type;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(32,s);</span><br><span class="line">            <span class="keyword">sh</span>-&gt;len = initlen;</span><br><span class="line">            <span class="keyword">sh</span>-&gt;alloc = initlen;</span><br><span class="line"><span class="comment">            *fp = type;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(64,s);</span><br><span class="line">            <span class="keyword">sh</span>-&gt;len = initlen;</span><br><span class="line">            <span class="keyword">sh</span>-&gt;alloc = initlen;</span><br><span class="line"><span class="comment">            *fp = type;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(s, init, initlen); <span class="comment">//给buf赋值初始化</span></span><br><span class="line">    s[initlen] = &#x27;\0&#x27;;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建字符串对应的几个静态函数：</p>
<ol>
<li>获取结构体类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span></span><br></pre></td></tr></table></figure></li>
<li>获取结构体的长度，用于构建StringHeader<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span></span></span><br></pre></td></tr></table></figure></li>
<li>动态内存分配：<br><br>s_malloc只是一个宏定义别名<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_malloc zmalloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_realloc zrealloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_free zfree</span></span><br></pre></td></tr></table></figure>
redis的zmalloc是对malloc进行了封装，该模块会在后面的文章中进行分析。 <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// PREFIX_SIZE 宏代表了当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。这里我们可以简称这个 PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分。</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="comment">// 内存分配失败，则调用oom处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(<span class="built_in">size</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 更新已经分配的内存大小变量used_memory，zmalloc_size会返回ptr指向的内存大小</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = <span class="built_in">size</span>;</span><br><span class="line">    update_zmalloc_stat_alloc(<span class="built_in">size</span>+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其他的与创建初始化sds相关的函数：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span>(<span class="params"><span class="keyword">void</span></span>) <span class="comment">// 创建空的sds</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *<span class="keyword">init</span></span>) <span class="comment">// sdsnewlen的上层封装</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span>(<span class="params"><span class="keyword">const</span> sds s</span>)  <span class="comment">// sds的深拷贝</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SDS的扩容"><a href="#SDS的扩容" class="headerlink" title="SDS的扩容"></a>SDS的扩容</h4><p>　　sdscat、sdscatsds是sds字符串的拼接函数，在拼接之前会检查是否需要扩容，如果需要扩容，则还会<code>预分配空间</code>。其次，SDS拼接字符串之前会先通过free字段检测剩余空间能否满足需求，不能满足需求的就会扩容，杜绝缓冲区溢出的问题。<br><br>SDS的扩容函数sdsMakeRoomFor:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;</span><br><span class="line">    void *sh, *<span class="keyword">new</span><span class="type">sh</span>;</span><br><span class="line">    size_t avail = sdsavail(s); <span class="comment">// 获取buf的剩余长度</span></span><br><span class="line">    size_t len, <span class="keyword">new</span><span class="type">len</span>;</span><br><span class="line">    char type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK; <span class="comment">// 字符串的扩容可能会导致sds的数据结构类型发生变化</span></span><br><span class="line">    int hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s; <span class="comment">// 如果剩余长度大于等于需要扩容的长度，不扩容，直接返回</span></span><br><span class="line"></span><br><span class="line">    len = sdslen(s); <span class="comment">// 获取buf的使用长度</span></span><br><span class="line">    sh = (char*)s-sdsHdrSize(oldtype); <span class="comment">// 获取到String的起始地址</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">len</span> = (len+addlen); <span class="comment">// 最小需要的字节长度，小于阈值的，就按照该值进行二倍扩容，否则加上阈值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">len</span> &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="keyword">new</span><span class="type">len</span> *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">len</span> += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(<span class="keyword">new</span><span class="type">len</span>); <span class="comment">// 获取新的长度对应的结构类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type); <span class="comment">// 获取新的结构体长度</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123; <span class="comment">// 结构类型不改变时，在起始地址的基础上分配更多的空间</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">sh</span> = s_realloc(sh, hdrlen+<span class="keyword">new</span><span class="type">len</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">sh</span> == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        s = (char*)<span class="keyword">new</span><span class="type">sh</span>+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">sh</span> = s_malloc(hdrlen+<span class="keyword">new</span><span class="type">len</span>+<span class="number">1</span>); <span class="comment">//类型改变时，重新分配内存进行数据复制并释放之前的内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">sh</span> == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        memcpy((char*)<span class="keyword">new</span><span class="type">sh</span>+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (char*)<span class="keyword">new</span><span class="type">sh</span>+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len); <span class="comment">// 设置len为buf的使用长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, <span class="keyword">new</span><span class="type">len</span>); <span class="comment">//设置新的alloc的值</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与扩容相关的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> <span class="comment">//将sds扩充至指定长度，未使用的空间以 0 字节填充。</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> <span class="comment">// 将len长度的t字符串,追加到s</span></span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> <span class="comment">// 将len长度的t复制到s中,会覆盖s内容,内存不足则重新分配</span></span></span><br></pre></td></tr></table></figure>
<h4 id="SDS内存收缩"><a href="#SDS内存收缩" class="headerlink" title="SDS内存收缩"></a>SDS内存收缩</h4><p>sdsRemoveFreeSpace：通过释放多余的可用空间，使之刚好保存sdslen大小的数据。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sds sds<span class="constructor">RemoveFreeSpace(<span class="params">sds</span> <span class="params">s</span>)</span> &#123;</span><br><span class="line">    void *sh, *newsh;</span><br><span class="line">    <span class="built_in">char</span> <span class="keyword">type</span>, oldtype = s<span class="literal">[-<span class="number">1</span>]</span> &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="built_in">int</span> hdrlen, oldhdrlen = sds<span class="constructor">HdrSize(<span class="params">oldtype</span>)</span>;</span><br><span class="line">    size_t len = sdslen(s); <span class="comment">// buf已使用长度</span></span><br><span class="line">    size_t avail = sdsavail(s); <span class="comment">// buf剩余空间</span></span><br><span class="line">    sh = (<span class="built_in">char</span>*)s-oldhdrlen; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is no space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail<span class="operator"> == </span><span class="number">0</span>) return s; <span class="comment">// 没有剩余空间时返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check what would be the minimum SDS header that is just good enough to</span></span><br><span class="line"><span class="comment">     * fit this string. */</span></span><br><span class="line">    <span class="keyword">type</span> = sds<span class="constructor">ReqType(<span class="params">len</span>)</span>; <span class="comment">// 根据使用的buf长度获取数据结构类型以及结构体长度</span></span><br><span class="line">    hdrlen = sds<span class="constructor">HdrSize(<span class="params">type</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the type is the same, or at least a large enough type is still</span></span><br><span class="line"><span class="comment">     * required, we just realloc(), letting the allocator to do the copy</span></span><br><span class="line"><span class="comment">     * only if really needed. Otherwise if the change is huge, we manually</span></span><br><span class="line"><span class="comment">     * reallocate the string to use the different header type. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype<span class="operator"> == </span><span class="keyword">type</span><span class="operator"> || </span><span class="keyword">type</span> &gt; SDS_TYPE_8) &#123; <span class="comment">// 类型不变或者类型大于8的就调整缓存大小</span></span><br><span class="line">        newsh = s<span class="constructor">_realloc(<span class="params">sh</span>, <span class="params">oldhdrlen</span>+<span class="params">len</span>+1)</span>;</span><br><span class="line">        <span class="keyword">if</span> (newsh<span class="operator"> == </span>NULL) return NULL;</span><br><span class="line">        s = (<span class="built_in">char</span>*)newsh+oldhdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//内存重分配，复制数据并释放之前的结构体</span></span><br><span class="line">        newsh = s<span class="constructor">_malloc(<span class="params">hdrlen</span>+<span class="params">len</span>+1)</span>;</span><br><span class="line">        <span class="keyword">if</span> (newsh<span class="operator"> == </span>NULL) return NULL;</span><br><span class="line">        memcpy((<span class="built_in">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s<span class="constructor">_free(<span class="params">sh</span>)</span>;</span><br><span class="line">        s = (<span class="built_in">char</span>*)newsh+hdrlen;</span><br><span class="line">        s<span class="literal">[-<span class="number">1</span>]</span> = <span class="keyword">type</span>;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他的一些函数"><a href="#其他的一些函数" class="headerlink" title="其他的一些函数"></a>其他的一些函数</h4><ol>
<li>通过对内部数据调用strlen来更新sds的长度，一般情况下，这个接口用于减少sds的len字段的值，但是该接口调用不会对buf中的数据进行修改。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>用于清空一个sds数据的内容，不会释放或者修改已经存在的缓存。仅仅是将sdshdr.len长度字段清零，但是空间还在。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>获取整个String的长度以及对应的指向该String首地址的指针<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">size_t sds<span class="constructor">AllocSize(<span class="params">sds</span> <span class="params">s</span>)</span></span><br><span class="line">void *sds<span class="constructor">AllocPtr(<span class="params">sds</span> <span class="params">s</span>)</span></span><br></pre></td></tr></table></figure></li>
<li>增减sds的len值，同时会导致sds的可用空间减少。该接口只负责处理sds数据的长度，而不会改动buf的数据。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void sds<span class="constructor">IncrLen(<span class="params">sds</span> <span class="params">s</span>, <span class="params">ssize_t</span> <span class="params">incr</span>)</span></span><br></pre></td></tr></table></figure></li>
<li>类型转换相关接口：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> <span class="comment">// 将long long类型value转成string,然后根据value新建sds</span></span></span><br></pre></td></tr></table></figure></li>
<li>接受一个 SDS 和一个 C 字符串作为参数，从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符<br><br> <code>惰性删除</code>：并不会直接释放空间，只是修改len长度，对应的多余的空间还是保留下来了<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sds sdstrim(sds s, const char *cset) &#123;</span><br><span class="line"> char *<span class="built_in">start</span>, *<span class="keyword">end</span>, *<span class="built_in">sp</span>, *ep;</span><br><span class="line"> size_t len;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">sp</span> = <span class="built_in">start</span> = s;</span><br><span class="line"> ep = <span class="keyword">end</span> = s+sdslen(s)<span class="literal">-1</span>;</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">sp</span> &lt;= <span class="keyword">end</span> &amp;&amp; strchr(cset, *<span class="built_in">sp</span>)) <span class="built_in">sp</span>++; // strchr函数功能为在一个串中查找给定字符的第一个匹配之处</span><br><span class="line"> <span class="keyword">while</span>(ep &gt; <span class="built_in">sp</span> &amp;&amp; strchr(cset, *ep)) ep--;</span><br><span class="line"> len = (<span class="built_in">sp</span> &gt; ep) ? <span class="number">0</span> : ((ep<span class="literal">-sp</span>)+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (s != <span class="built_in">sp</span>) memmove(s, <span class="built_in">sp</span>, len);</span><br><span class="line"> s[<span class="type">len</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> sdssetlen(s,len);</span><br><span class="line"> <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>截断start~end字符<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">ssize_t</span> start, <span class="keyword">ssize_t</span> <span class="built_in">end</span>)</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>与传统的C字符相比，SDS的特性有：</p>
<ol>
<li>常数复杂度获取字符串长度<br><br>　　传统的C字符想要获取长度，是需要遍历该字符串直到遇到’\n’结束符，复杂度为O(n);<br><br>　　而SDS的结构体有len属性表示缓冲区的字符长度，复杂度O(1)</li>
<li>杜绝缓冲区溢出:<br><br>　　对于C字符串的操作函数来说，如果在修改字符串的时候忘了为字符串分配足够的空间，就有可能出现缓冲区溢出的情况。<br><br>　　而SDS在修改之前，都会调用<code>sdsMakeRoomFor</code>接口判断它是否有足够的空间，没有的话就会扩容再修改</li>
<li>空间预分配：<br><br>　　SDS扩容时会判断最小所需的字符长度是否超过1M。没有的话，就按照最小所需空间的二倍进行扩容；超过1M时，就在最小所需空间的基础上加上1M进行扩容。</li>
<li>惰性空间释放<br><br>　　如果操作后减少了字符串的大小，只是在最后修改len属性，不会马上释放多余的空间，而是继续保留多余的空间，这样在下次需要增加sds字符串的大小时，就不需要再为其分配空间了。当然，也可以调用<code>sdsRemoveFreeSpace</code>函数主动释放多余的空间。</li>
<li>二进制安全<br><br>　　二进制安全指的是只关心二进制化的字符串，严格的按照二进制的数据存取，不关注数据格式更不会妄图以某种特殊格式解析数据。比如遇到’\0’字符不会停止解析。<br><br>　　对于C字符串来说，strlen是判断遇到’\0’之前的字符数量。如果二进制数据本身就存在’\0’时，所获取的长度就不正确。<br><br>　　SDS字符串是通过len属性保存字符串的大小，所以它是二进制安全的。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c</tag>
        <tag>缓存</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的load_average</title>
    <url>/2021/03/30/Linux%E7%9A%84load-average/</url>
    <content><![CDATA[<p>前段时间公司项目需求要写一个负载均衡的demo。在研究负载均衡的计算条件时，不可避免地考虑到了一些linux平台的性能指标，其中就有常被用来和负载均衡load-balance混淆的平均负载load-avearge。</p>
<h3 id="什么是load-average？"><a href="#什么是load-average？" class="headerlink" title="什么是load average？"></a>什么是load average？</h3><p>平均负载是指cpu在一段时间内正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度的统计信息。也可以说是一段时间内活跃进程的统计信息。</p>
<h3 id="怎样查看linux系统当前的平均负载"><a href="#怎样查看linux系统当前的平均负载" class="headerlink" title="怎样查看linux系统当前的平均负载"></a>怎样查看linux系统当前的平均负载</h3><p>load average参数后的数值就代表系统当前的平均负载。具体的查看命令有：</p>
<ol>
<li>top命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VirtualBox:~$ top：最常见的命令了。</span><br><span class="line"></span><br><span class="line">top - 17:52:47 up 1 min,  1 user,  load average: 1.83, 0.63, 0.22</span><br><span class="line">Tasks: 191 total,   2 running, 189 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 17.2 us,  1.4 sy,  0.0 ni, 80.7 id,  0.3 wa,  0.0 hi,  0.3 si,  0.0 st</span><br><span class="line">MiB Mem :   3936.0 total,   2012.7 free,    678.1 used,   1245.2 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   3011.9 avail Mem </span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li>W命令：用于查看当前平均负载以及当前有哪些用户，分别占用了哪些终端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VirtualBox:~$ w</span><br><span class="line"> 19:38:53 up 1 min,  1 user,  load average: 0.78, 0.32, 0.11</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">test    :0       :0               19:37   ?xdm?  22.41s  0.00s &#x2F;usr&#x2F;lib&#x2F;gdm3&#x2F;g</span><br></pre></td></tr></table></figure></li>
<li>uptime：查看平均负载的最简单的命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VirtualBox:~$ uptime</span><br><span class="line"> 19:40:21 up 3 min,  1 user,  load average: 0.19, 0.25, 0.10</span><br></pre></td></tr></table></figure>
<h3 id="怎么解释load-average的参数呢？"><a href="#怎么解释load-average的参数呢？" class="headerlink" title="怎么解释load average的参数呢？"></a>怎么解释load average的参数呢？</h3>从上面的命令输出的结果可以看到：load balance的参数带有单个值，分别对应1分钟、5分钟以及15分钟内cpu的平均负载。对参数值的解释有：</li>
<li>如果平均值为 0.0，意味着系统处于空闲状态</li>
<li>如果 1min 平均值高于 5min 或 15min 平均值，则负载正在增加</li>
<li>如果 1min 平均值低于 5min 或 15min 平均值，则负载正在减少</li>
</ol>
<p>其次，需要注意的是loadbalance本身的值是没有具体意义的，它与机器内核数有关。</p>
<ol>
<li>以一个单核的机器为例：<ol>
<li>load=0.5，表示CPU还有一半的资源可以处理其他的线程请求 </li>
<li>load=1表示CPU所有的资源都在处理请求，没有剩余的资源可以利用了</li>
<li>load=2则表示CPU已经超负荷运作，另外还有一倍的线程正在等待处理。 </li>
</ol>
</li>
<li>对于双核处理器来说：<ol>
<li>load=2表示CPU所有的资源都在处理请求，没有剩余的资源可以利用了。</li>
</ol>
</li>
</ol>
<p><strong>结论：</strong> 多核处理器中，Load average不应该高于处理器核心的总数量。如果它们高于处理器核心的数量，那么系统很可能会遇到性能问题。</p>
<h3 id="如何排查load-average过高的问题呢？"><a href="#如何排查load-average过高的问题呢？" class="headerlink" title="如何排查load average过高的问题呢？"></a>如何排查load average过高的问题呢？</h3><ol>
<li>首先我们可以确认当前load balance的值：watch -d uptime<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Every 2.0s: uptime       iauto-VirtualBox: Tue Apr  6 20:19:45 2021</span><br><span class="line"></span><br><span class="line"> 20:19:45 up 42 min,  1 user,  load average: 1.00, 0.82, 0.48</span><br></pre></td></tr></table></figure></li>
<li>查看当前系统cpu的核心数以及是否开启了超核线程：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo (获取你系统上的每个处理器的信息。如果你只想得到数字，那么就使用下面的命令：grep &#39;model name&#39; &#x2F;proc&#x2F;cpuinfo | wc -l)</span><br></pre></td></tr></table></figure>
查看当前系统cpu的核心数: 单核<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VirtualBox:~$ cat &#x2F;proc&#x2F;cpuinfo |grep &quot;cpu core&quot;|wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
查看是否开启了超核线程：因为cpu核心数也是1，所以没有开启<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VirtualBox:~$ cat &#x2F;proc&#x2F;cpuinfo | grep &quot;processor&quot; | wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
<li>每五秒打印一次cpu的使用率：可以看到是近乎于百分百的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mpstat -P ALL 5</span><br><span class="line">Linux 5.8.0-43-generic (VirtualBox) 	2021年04月06日 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">20时16分06秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">20时16分11秒  all   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">20时16分11秒    0   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line">20时16分11秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">20时16分16秒  all   98.80    0.00    1.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">20时16分16秒    0   98.80    0.00    1.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure></li>
<li>打印进程id号，查看使用cpu最高的进程，可以看到是Stress，因为我之前用stress进行了压力测试<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidstat -u 5 1</span><br><span class="line">Linux 5.8.0-43-generic (VirtualBox) 	2021年04月06日 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">20时16分42秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">20时16分47秒  1000      1286    0.20    0.00    0.00    0.00    0.20     0  Xorg</span><br><span class="line">20时16分47秒  1000      1420    0.00    0.20    0.00    0.00    0.20     0  VBoxClient</span><br><span class="line">20时16分47秒  1000      1497    0.40    0.00    0.00    0.40    0.40     0  gnome-shell</span><br><span class="line">20时16分47秒  1000      2406    0.20    0.00    0.00    0.00    0.20     0  gnome-terminal-</span><br><span class="line">20时16分47秒  1000     25441   98.60    0.00    0.00    1.20   98.60     0  stress</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式协议之2pc与3pc</title>
    <url>/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8B2pc%E4%B8%8E3pc/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode74.搜索二维矩阵</title>
    <url>/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>题目（LeetCode摘抄）：<br><br>　　编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ol>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ol>
<p>示例1：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="number">13</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">m == <span class="built_in">matrix</span>.<span class="built_in">length</span></span><br><span class="line">n == <span class="built_in">matrix</span>[i].<span class="built_in">length</span></span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">100</span></span><br><span class="line">-<span class="number">104</span> &lt;= <span class="built_in">matrix</span>[i][j], target &lt;= <span class="number">104</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>解题思路：因为条件设置行是升序的且每一行的开头元素大于上一行结尾元素，所以果断二分查找。</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line">public class search2Marchix &#123;</span><br><span class="line">    public static boolean searchMatrix(<span class="keyword">int</span>[][] <span class="keyword">matrix</span>, <span class="keyword">int</span> <span class="built_in">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> locationLine = binarySearchRow(<span class="keyword">matrix</span>, <span class="built_in">target</span>);</span><br><span class="line">        <span class="keyword">return</span> locationLine &lt; <span class="number">0</span> ? false : binarySearchCol(<span class="keyword">matrix</span>, <span class="built_in">target</span>, locationLine);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean binarySearchCol(<span class="keyword">int</span>[][] <span class="keyword">matrix</span>, <span class="keyword">int</span> <span class="built_in">target</span>, <span class="keyword">int</span> locationLine) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">col</span> = <span class="keyword">matrix</span>[locationLine].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= <span class="built_in">col</span>) &#123;</span><br><span class="line">            middle = (<span class="built_in">col</span>-low)/<span class="number">2</span>+low;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">matrix</span>[locationLine][middle] == <span class="built_in">target</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> true;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">matrix</span>[locationLine][middle] &lt; <span class="built_in">target</span>) &#123;</span><br><span class="line">                low = middle+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">col</span> = middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static <span class="keyword">int</span> binarySearchRow(<span class="keyword">int</span>[][] <span class="keyword">matrix</span>, <span class="keyword">int</span> <span class="built_in">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (null == <span class="keyword">matrix</span> || <span class="number">0</span> == <span class="keyword">matrix</span>.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">row</span> = <span class="keyword">matrix</span>.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; <span class="built_in">row</span>) &#123;</span><br><span class="line">            middle = (<span class="built_in">row</span>-low+<span class="number">1</span>)/<span class="number">2</span>+low;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">matrix</span>[middle][<span class="number">0</span>] == <span class="built_in">target</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">matrix</span>[middle][<span class="number">0</span>] &lt; <span class="built_in">target</span>) &#123;</span><br><span class="line">                low = middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">row</span> = middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：binarySearchRow函数中隐藏了一个小心机，就是在使用二分判断的时候使用每行的第一列元素。这样该函数也使用于每行长度不相同的矩阵，可扩展性比使用结尾元素更高，因为后者你需要获取每一行的长度。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>_builtin_expect</title>
    <url>/2021/03/29/builtin-expect/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>今天在看项目代码的时候看到了unliekly和likely的使用，往上追溯代码的时候找到了如下的宏定义：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#if</span> <span class="selector-tag">defined</span> <span class="selector-tag">__GNUC__</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">likely</span>(x) <span class="selector-tag">__builtin_expect</span>((x), <span class="number">1</span>)    </span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">unlikely</span>(x) <span class="selector-tag">__builtin_expect</span>((x), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>对于__builtin_expect因为了解的不多，于是就打算整理下笔记，认真学习下这个宏定义。</p>
<h5 id="builtin-expect作用"><a href="#builtin-expect作用" class="headerlink" title="__builtin_expect作用"></a>__builtin_expect作用</h5><p>该指令是由gcc引入的，其作用是允许程序员将”分支转移”的信息告诉编译器，以便编译器对代码进行优化，来减少指令跳转带来的性能下降问题。<br><br>原型为：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">__builtin_expect(<span class="built_in">exp</span>, <span class="built_in">N</span>)</span><br></pre></td></tr></table></figure>
<p>表示exp==N的概率很大。</p>
<span id="more"></span>
<p><br>这里，我给出一个测试用例来说明下该指令的作用：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> x, y;</span><br><span class="line"> <span class="attribute">if</span>(unlikely(x &gt; <span class="number">0</span>))</span><br><span class="line">    <span class="attribute">y</span> = <span class="number">1</span>; </span><br><span class="line"><span class="attribute">else</span> </span><br><span class="line">    <span class="attribute">y</span> = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>该用例表示x&gt;0为false的概率比较大，即走else分支的概率比较大，因此gcc编译的指令会预先读取 y = -1 这条指令。<br><br>说明：在日常的编码过程中，条件判断都是有偏向性的。比如：在使用if-else结构时，程序员经常通过else分支来补充一些意外性的情况。此时，该程序更多的是期待执行if分支的指令。因此，__builtin_expect指令可以利用该偏向特点提醒编译器在汇编曾进行指令优化。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编译优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeroMQ源码解析之消息存储方式</title>
    <url>/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>ZeroMQ的消息队列主要由yqueue.hpp与ypipe.hpp两个类构成。<br><br>在yqueue中有一个重要的结构体chunk_t，他是yqueue高效的关键因素。内存的申请和释放非常浪费效率，yqueue为了避免频繁的内存操作，每次不会申请一个元素大小的内存空间，而是申请一批，这一批元素就保存在chunk_t结构体中.</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct chunk_t</span><br><span class="line">&#123;</span><br><span class="line">    T values[N]<span class="comment">;</span></span><br><span class="line">    chunk_t *prev<span class="comment">;</span></span><br><span class="line">    chunk_t *next<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>yqueue分别用三个指针和三个游标来记录chunk以及在chunk内有效的数据的索引。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  当对列为空的时候，back poisiton指向一个无效的值，而begin或者end position永远是一个有效值。</span></span><br><span class="line"><span class="comment">//  begin是用来在读取数据的时候使用的；而end是在入队的时候使用的游标</span></span><br><span class="line"><span class="keyword">chunk_t</span> *_begin_chunk;</span><br><span class="line"><span class="keyword">int</span> _begin_pos;</span><br><span class="line"><span class="keyword">chunk_t</span> *_back_chunk;</span><br><span class="line"><span class="keyword">int</span> _back_pos; <span class="comment">// 当队列为空的时候该值</span></span><br><span class="line"><span class="keyword">chunk_t</span> *_end_chunk;</span><br><span class="line"><span class="keyword">int</span> _end_pos;</span><br></pre></td></tr></table></figure>
<p>yqueue还有一个特殊的变量_spare_chunk,这是因为往往生产者和消费者的速率达成一致时，使用_spare_chunk保存刚刚释放的chunk，这样当需要申请新的chunk时就可以直接使用_spare_chunk所记录的chunk了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">atomic_ptr_t</span>&lt;<span class="keyword">chunk_t</span>&gt; _spare_chunk;</span><br></pre></td></tr></table></figure>
<p>yqueue的主要操作有pop、puhs、unpush:</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Adds an element to the back end of the queue.</span></span><br><span class="line">inline void push ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">_back_chunk</span> = <span class="variable">_end_chunk</span>;</span><br><span class="line">    <span class="variable">_back_pos</span> = <span class="variable">_end_pos</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++<span class="variable">_end_pos</span> != N)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    chunk_t *sc = <span class="variable">_spare_chunk</span>.xchg (NULL);</span><br><span class="line">    <span class="keyword">if</span> (sc) &#123;</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next = sc;</span><br><span class="line">        sc-&gt;prev = <span class="variable">_end_chunk</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next = allocate_chunk ();</span><br><span class="line">        alloc_assert (<span class="variable">_end_chunk</span>-&gt;next);</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next-&gt;prev = <span class="variable">_end_chunk</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">_end_chunk</span> = <span class="variable">_end_chunk</span>-&gt;next;</span><br><span class="line">    <span class="variable">_end_pos</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpush是指回滚上一次入队的消息，调用者需要释放回滚的信息的内存。</span></span><br><span class="line">inline void unpush ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  First, move &#x27;back&#x27; one position backwards.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_back_pos</span>)</span><br><span class="line">        --<span class="variable">_back_pos</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_back_pos</span> = N - <span class="number">1</span>;</span><br><span class="line">        <span class="variable">_back_chunk</span> = <span class="variable">_back_chunk</span>-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Now, move &#x27;end&#x27; position backwards. Note that obsolete end chunk</span></span><br><span class="line">    <span class="comment">//  is not used as a spare chunk. The analysis shows that doing so</span></span><br><span class="line">    <span class="comment">//  would require free and atomic operation per chunk deallocated</span></span><br><span class="line">    <span class="comment">//  instead of a simple free.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_end_pos</span>)</span><br><span class="line">        --<span class="variable">_end_pos</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_end_pos</span> = N - <span class="number">1</span>;</span><br><span class="line">        <span class="variable">_end_chunk</span> = <span class="variable">_end_chunk</span>-&gt;prev;</span><br><span class="line">        free (<span class="variable">_end_chunk</span>-&gt;next);</span><br><span class="line">        <span class="variable">_end_chunk</span>-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Removes an element from the front end of the queue.</span></span><br><span class="line">inline void pop ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (++<span class="variable">_begin_pos</span> == N) &#123;</span><br><span class="line">        chunk_t *o = <span class="variable">_begin_chunk</span>;</span><br><span class="line">        <span class="variable">_begin_chunk</span> = <span class="variable">_begin_chunk</span>-&gt;next;</span><br><span class="line">        <span class="variable">_begin_chunk</span>-&gt;prev = NULL;</span><br><span class="line">        <span class="variable">_begin_pos</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  &#x27;o&#x27; has been more recently used than _spare_chunk,</span></span><br><span class="line">        <span class="comment">//  so for cache reasons we&#x27;ll get rid of the spare and</span></span><br><span class="line">        <span class="comment">//  use &#x27;o&#x27; as the spare.</span></span><br><span class="line">        chunk_t *cs = <span class="variable">_spare_chunk</span>.xchg (o);</span><br><span class="line">        free (cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看下ypipe：ypipe继承自ypipe_base_t，ypipe_base_t抽象出了ypipe和ypipe_conflate（后面分析）的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">ypipe_base_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="keyword">ypipe_base_t</span> () &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write</span> <span class="params">(<span class="keyword">const</span> T &amp;value_, <span class="keyword">bool</span> incomplete_)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">unwrite</span> <span class="params">(T *value_)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">flush</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">check_read</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span> <span class="params">(T *value_)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">probe</span> <span class="params">(<span class="keyword">bool</span> (*fn)(<span class="keyword">const</span> T &amp;))</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ypipe包含了一个yqueue队列和四个非常重要的指针，下面是ypipe的成员变量定义：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>  Allocation-efficient queue to store pipe items.</span><br><span class="line"><span class="regexp">//</span>  Front of the queue points to the first prefetched item, back of</span><br><span class="line"><span class="regexp">//</span>  the pipe points to last un-flushed item. Front is used only by</span><br><span class="line"><span class="regexp">//</span>  reader thread, <span class="keyword">while</span> back is used only by writer thread.</span><br><span class="line">yqueue_t &lt;T, N&gt; queue;</span><br><span class="line"></span><br><span class="line">T *w;</span><br><span class="line">T *r;</span><br><span class="line">T *f; <span class="regexp">//</span>f指针指向了当前未做flush操作的第一个元素，如果是写入了一条完整消息，那f指向的就是结束符。</span><br><span class="line">atomic_ptr_t &lt;T&gt; c; <span class="regexp">//</span>c只能有两个值，要么等于w，要么为空，当c为空时说明之前的check_read操作没有读到元素，check_read返回false同时将c置为空。</span><br></pre></td></tr></table></figure>
<p>ypipe管道的读写操作：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void write (const T &amp;value_, <span class="built_in">bool</span> incomplete_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Place the value to the queue, add new terminator element.</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span> = value_;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>push <span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Move the &quot;flush up to here&quot; poiter.</span></span><br><span class="line">    <span class="keyword">if</span> (!incomplete_)</span><br><span class="line">        _f = &amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Pop an incomplete item from the pipe. Returns true if such</span></span><br><span class="line"><span class="comment">//  item exists, false otherwise.</span></span><br><span class="line"><span class="built_in">bool</span> unwrite (T *value_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_f<span class="operator"> == </span>&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>unpush <span class="literal">()</span>;</span><br><span class="line">    *value_ = <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>back <span class="literal">()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Flush all the completed items into the pipe. Returns false if</span></span><br><span class="line"><span class="comment">//  the reader thread is sleeping. In that case, caller is obliged to</span></span><br><span class="line"><span class="comment">//  wake the reader up before using the pipe again.</span></span><br><span class="line"><span class="built_in">bool</span> flush <span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  If there are no un-flushed items, do nothing.</span></span><br><span class="line">    <span class="keyword">if</span> (_w<span class="operator"> == </span>_f)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Try to set &#x27;c&#x27; to &#x27;f&#x27;.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">_c</span>.</span></span>cas (_w, _f) != _w) &#123;</span><br><span class="line">        <span class="comment">//  Compare-and-swap was unseccessful because &#x27;c&#x27; is NULL.</span></span><br><span class="line">        <span class="comment">//  This means that the reader is asleep. Therefore we don&#x27;t</span></span><br><span class="line">        <span class="comment">//  care about thread-safeness and update c in non-atomic</span></span><br><span class="line">        <span class="comment">//  manner. We&#x27;ll return false to let the caller know</span></span><br><span class="line">        <span class="comment">//  that reader is sleeping.</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_c</span>.</span></span>set (_f);</span><br><span class="line">        _w = _f;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Reader is alive. Nothing special to do now. Just move</span></span><br><span class="line">    <span class="comment">//  the &#x27;first un-flushed item&#x27; pointer to &#x27;f&#x27;.</span></span><br><span class="line">    _w = _f;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*check_read操作，它的返回值标记了队列中是否有数据，他使用r指针来标记当前可以读到的位置：</span></span><br><span class="line"><span class="comment">*如果r指针不在front位置处，说明有元素可读。</span></span><br><span class="line"><span class="comment">*否则就用c和front对比来判断当前是否有元素，如果没有将c置为空，表明读操作处于睡眠状态。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">bool</span> check_read <span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Was the value prefetched already? If so, return.</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span> != _r<span class="operator"> &amp;&amp; </span>_r)</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  There&#x27;s no prefetched value, so let us prefetch more values.</span></span><br><span class="line">    <span class="comment">//  Prefetching is to simply retrieve the</span></span><br><span class="line">    <span class="comment">//  pointer from c in atomic fashion. If there are no</span></span><br><span class="line">    <span class="comment">//  items to prefetch, set c to NULL (using compare-and-swap).</span></span><br><span class="line">    _r = <span class="module-access"><span class="module"><span class="identifier">_c</span>.</span></span>cas (&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span>, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  If there are no elements prefetched, exit.</span></span><br><span class="line">    <span class="comment">//  During pipe&#x27;s lifetime r should never be NULL, however,</span></span><br><span class="line">    <span class="comment">//  it can happen during pipe shutdown when items</span></span><br><span class="line">    <span class="comment">//  are being deallocated.</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span><span class="operator"> == </span>_r<span class="operator"> || </span>!_r)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  There was at least one value prefetched.</span></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Reads an item from the pipe. Returns false if there is no value.</span></span><br><span class="line"><span class="comment">//  available.</span></span><br><span class="line"><span class="built_in">bool</span> read (T *value_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  Try to prefetch a value.</span></span><br><span class="line">    <span class="keyword">if</span> (!check_read <span class="literal">()</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  There was at least one value prefetched.</span></span><br><span class="line">    <span class="comment">//  Return it to the caller.</span></span><br><span class="line">    *value_ = <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>pop <span class="literal">()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Applies the function fn to the first elemenent in the pipe</span></span><br><span class="line"><span class="comment">//  and returns the value returned by the fn.</span></span><br><span class="line"><span class="comment">//  The pipe mustn&#x27;t be empty or the function crashes.</span></span><br><span class="line"><span class="built_in">bool</span> probe (<span class="built_in">bool</span> (*fn_) (const T &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    const <span class="built_in">bool</span> rc = check_read <span class="literal">()</span>;</span><br><span class="line">    zmq_assert (rc);</span><br><span class="line"></span><br><span class="line">    return (*fn_) (<span class="module-access"><span class="module"><span class="identifier">_queue</span>.</span></span>front <span class="literal">()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ZeroMQ</category>
      </categories>
      <tags>
        <tag>消息队列， C++</tag>
      </tags>
  </entry>
  <entry>
    <title>BIO与NIO和AIO三种reactor模型</title>
    <url>/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++11之default与delete关键字</title>
    <url>/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在讲default与delete关键字之前，我们先了解下C++的几个特殊函数。<br><br>C++98编译器会隐式的产生四个函数：缺省构造函数，析构函数，拷贝构造函数和拷贝赋值运算符，它们称为特殊成员函数，负责创建、初始化、销毁，或者拷贝类的对象。<br>在 C++11 中，除了上面四个外，特殊成员函数还有两个：移动构造函数和移动赋值算符。例：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">class <span class="built_in">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span> ();                  <span class="comment">// 缺省构造函数</span></span><br><span class="line">    ~<span class="built_in">Data</span> ();                 <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span> (const <span class="built_in">Data</span> &amp; rhs);         　 　  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Data</span> &amp; operator=(const <span class="built_in">Data</span> &amp; rhs);    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span> (const <span class="built_in">Data</span> &amp;&amp; rhs);         <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Data</span> &amp; operator=(<span class="built_in">Data</span> &amp;&amp; rhs);    <span class="comment">// 移动赋值算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="C-的特殊成员函数"><a href="#C-的特殊成员函数" class="headerlink" title="C++的特殊成员函数"></a>C++的特殊成员函数</h3><h4 id="缺省构造函数与析构函数"><a href="#缺省构造函数与析构函数" class="headerlink" title="缺省构造函数与析构函数"></a>缺省构造函数与析构函数</h4><p>缺省构造函数指不需要参数就能初始化的构造函数，包含无参和所有参数有默认值两种类型的构造函数。 一个缺省的构造函数只有在类中没有声明任何构造函数的情况下才会被编译器自动生成。<br><br>特殊成员函数被隐式生成为public和inline，并且它们是nonvirtual，除非是在派生类中的析构函数，并且这个派生类继承自带virtual析构函数的基类。在这种情况下，派生类中，编译器生成的析构函数也是virtual。</p>
<span id="more"></span>
<h4 id="拷贝构造与拷贝赋值运算符"><a href="#拷贝构造与拷贝赋值运算符" class="headerlink" title="拷贝构造与拷贝赋值运算符"></a>拷贝构造与拷贝赋值运算符</h4><p>拷贝构造是指用已经存在的对象创建出一个新的对象。因为创建一个对象首先是进行内存分配然后是调用构造函数对其初始化，即对分配的内存进行首次赋值。而拷贝构造就是利用其它对象的数据来初始化新对象的内存。<br><br>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p>
<ol>
<li><p>为什么必须是当前类的引用呢？<br><br>　　如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。<br>因此只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p>
</li>
<li><p>为什么是 const 引用呢？<br><br>　　拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。其次，因为非const类型可以转换为const类型而const类型不能转换为非const类型，所以如果没有使用const修饰时，就不能将const对象传递给形参了。<br><br>换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。<br><br>如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。<br><br>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员，此时，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据（深拷贝）。例如：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo():num(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数,采用深拷贝的方式拷贝d.num指针成员</span></span><br><span class="line">    demo(<span class="keyword">const</span> demo &amp;d):num(<span class="keyword">new</span> <span class="keyword">int</span>(*d.num))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~demo()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序中定义了一个可返回demo对象的get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
</li>
<li><p>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</p>
</li>
<li><p>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</p>
</li>
<li><p>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</p>
</li>
<li><p>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。<br><br>示例程序摘抄自<a href="http://c.biancheng.net/view/7847.html%E3%80%82">http://c.biancheng.net/view/7847.html。</a></p>
<h4 id="移动拷贝构造与移动拷贝赋值运算符"><a href="#移动拷贝构造与移动拷贝赋值运算符" class="headerlink" title="移动拷贝构造与移动拷贝赋值运算符"></a>移动拷贝构造与移动拷贝赋值运算符</h4><p>因为拷贝构造函数的深拷贝涉及到临时对象的创建与销毁，对应的是内存的不停分配与释放，当对象占用内存比较大时，程序的效率就会大大降低。因此C++11提出了移动拷贝构造的概念。<br><br>移动指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象，也就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。因为，程序执行过程中产生的临时对象往往只用于传递数据，并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。<br>例如，在上面的例子上我们手动添加一个移动拷贝函数：</p>
 <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">//添加移动构造函数</span><br><span class="line"><span class="built_in">demo</span>(<span class="built_in">demo</span> &amp;&amp;d):<span class="built_in">num</span>(d.<span class="built_in">num</span>)&#123;</span><br><span class="line">    d.<span class="built_in">num</span> = NULL;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
</li>
</ol>
<p><em><strong>当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</strong></em></p>
<h3 id="default与delete关键字"><a href="#default与delete关键字" class="headerlink" title="default与delete关键字"></a>default与delete关键字</h3><h4 id="default关键字"><a href="#default关键字" class="headerlink" title="default关键字"></a>default关键字</h4><p>C++11的新特性，仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。 程序员只需在函数声明后加上”=default;”，就可将该函数声明为defaulted函数，编译器将为显式声明的defaulted函数自动生成函数体。<br><br>defaulted函数既可以在类体里(inline)定义，也可以在类体外(out-of-line)定义。</p>
<h4 id="delete-关键字"><a href="#delete-关键字" class="headerlink" title="delete 关键字"></a>delete 关键字</h4><p>C++11 中，可在想要 “禁止使用” 的特殊成员函数声明后加 “= delete”，而需要保留的加 “= default” 或者不采取操作.<br><br>与default关键字不同的是，delete 关键字可用于任何函数，不仅仅局限于类成员函数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode190.颠倒二进制位</title>
    <url>/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<p>题目（LeetCode摘抄）：<br><br>颠倒给定的 32 位无符号整数的二进制位。<br><br>提示：<br><br>　　请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。<br><br>进阶:如果多次调用这个函数，你将如何优化你的算法？</p>
<span id="more"></span>
<p>解法一：利用位操作取每一位上的数字，再根据二进制转十进制的规则进行计算相加得到最后需要的结果。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBit</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">doMethod</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            result+= (n &amp; <span class="number">1</span>) * Math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>-i);</span><br><span class="line">            n=n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(doMethod(<span class="number">4326159</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：利用位操作：左移位加上右移位</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">int</span> doMethod1(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="literal">result</span> |= (n &amp; <span class="number">1</span>)&lt;&lt;(<span class="number">31</span>-i);</span><br><span class="line">        n=n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>pthread_key_create</title>
    <url>/2021/03/26/pthread-key-create/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在工作中重新深入认识了一个函数pthread_key_create。深入挖掘该函数源码，才发现这就是java中的ThreadLocal。<br><br>其实这就是线程本地变量的概念。因为在多线程的程序中，线程是共享程序中的全局变量的。而对于线程本地变量，每一个变量是拥有该全局变量的一个副本，各线程对该变量的修改是线程内可见，线程间不影响。</p>
<h3 id="pthread-key-create"><a href="#pthread-key-create" class="headerlink" title="pthread_key_create"></a>pthread_key_create</h3><p>函数声明：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">int pthread_key_create(pthread_key_t *key, void <span class="comment">(*destructor)(void*)</span>);</span><br></pre></td></tr></table></figure>
<p>参数1：pthread_key_t *key，pthread_key_create函数从 TSD ((Thread-specific Data) 池中分配一项，将其地址值赋给 key 供以后访问使用。<br><br>参数2：是一个清理函数，用来在线程退出(调用 pthread_exit() 函数)时将以 key 锁关联的数据作为参数调用它，以释放分配的缓冲区，或是关闭文件流等。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。该函数成功返回0.其他任何返回值都表示出现了错误。</p>
<span id="more"></span>

<p>与线程本地变量数据相关的几个函数：</p>
<ol>
<li>pthread_key_create</li>
<li>pthread_key_delete： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_key_delete(<span class="params">pthread_key_t</span> <span class="params">key</span>)</span>;</span><br></pre></td></tr></table></figure>
该函数的目的是销毁key键并释放与该key关联的所有内存。因为该函数是不会主动调用任何析构函数去释放资源，所以在调用该函数之前必须释放所有线程的特定资源。<br><br>需要注意的是反复调用pthread_key_create与pthread_key_delete可能会产生问题。对于每个所需的键，应当只调用pthread_key_create一次。</li>
<li>pthread_setspecific(): <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> pthread<span class="constructor">_setspecific(<span class="params">pthread_key_t</span> <span class="params">key</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">value</span>)</span>;</span><br></pre></td></tr></table></figure>
当线程中需要存储特殊值的时候，可以调用 pthread_setspcific() 。该函数有两个参数，第一个为前面声明的pthread_key_t变量，第二个为void*变量，这样你可以存储任何类型的值。</li>
<li>pthread_getspecific():<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure>
该函数返回的是与key相关联数据的指针。需要注意的是：因为pthread_setspecific()存储的数据是void*，所以在利用该函数返回的指针时，虽然知道关联的数据地址，但并不知道指向的数据类型，因此要对其进行强制类型转换。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeroMQ概念入门</title>
    <url>/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在代码评审的过程中，接触到了一个新的之前没接触过的通信框架——ZeroMQ。所以打算借助代码评审的过程对该框架进行学习，并写些博客作为心得笔记。</p>
<h3 id="什么是ZeroMQ"><a href="#什么是ZeroMQ" class="headerlink" title="什么是ZeroMQ"></a>什么是ZeroMQ</h3><p>ZeroMQ是一个用于分布式或者并发环境下的高性能的异步通信框架。它支持在多种协议上进行消息传递，比如TCP、进程内、进程间、组播以及socket通信等。<br><br>Zero支持的通信模型有：发布订阅、请求响应、推拉模式以及Router/Dealer模式等。ZeroMQ支持多种语言，比如C、C++、Java、Python等。</p>
<span id="more"></span>

<h3 id="请求响应模式"><a href="#请求响应模式" class="headerlink" title="请求响应模式"></a>请求响应模式</h3><p>程序员的入门方式一定是以“HelloWord”开始的，这里我们以ZeroMQ官方给出的例子来简单解释下其请求响应方式下的工作流程。<br><br>首先新建一个client和server，client向server发送“hello”请求，而server在接收到该请求的时候回复“world”。<br><br><div align="center"><img src="/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/req-reply.png" alt="req-reply.png"></div><br>客户端代码(C++)：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zmq.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// initialize the zmq context with a single IO thread</span></span><br><span class="line">    zmq::<span class="keyword">context_t</span> context&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a REQ (request) socket and connect to interface</span></span><br><span class="line">    zmq::<span class="keyword">socket_t</span> socket&#123;context, zmq::socket_type::req&#125;;</span><br><span class="line">    socket.<span class="built_in">connect</span>(<span class="string">&quot;tcp://localhost:5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up some static data to send</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> data&#123;<span class="string">&quot;Hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> request_num = <span class="number">0</span>; request_num &lt; <span class="number">10</span>; ++request_num) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// send the request message</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sending Hello &quot;</span> &lt;&lt; request_num &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        socket.send(zmq::<span class="built_in">buffer</span>(data), zmq::send_flags::none);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// wait for reply from server</span></span><br><span class="line">        zmq::<span class="keyword">message_t</span> reply&#123;&#125;;</span><br><span class="line">        socket.recv(reply, zmq::recv_flags::none);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received &quot;</span> &lt;&lt; reply.to_string(); </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; request_num &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server端代码(C++)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="comment">//  Hello World server in C++</span></span><br><span class="line"><span class="comment">//  Binds REP socket to tcp://*:5555</span></span><br><span class="line"><span class="comment">//  Expects &quot;Hello&quot; from client, replies with &quot;World&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zmq.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sleep(n)	Sleep(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  Prepare our context and socket</span></span><br><span class="line">    <span class="function">zmq::<span class="keyword">context_t</span> <span class="title">context</span> <span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">zmq::<span class="keyword">socket_t</span> <span class="title">socket</span> <span class="params">(context, ZMQ_REP)</span></span>;</span><br><span class="line">    socket.bind (<span class="string">&quot;tcp://*:5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        zmq::<span class="keyword">message_t</span> request;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Wait for next request from client</span></span><br><span class="line">        socket.recv (&amp;request);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Received Hello&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Do some &#x27;work&#x27;</span></span><br><span class="line">    	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Send reply back to client</span></span><br><span class="line">        <span class="function">zmq::<span class="keyword">message_t</span> <span class="title">reply</span> <span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">        <span class="built_in">memcpy</span> (reply.data (), <span class="string">&quot;World&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        socket.send (reply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：ZeroMQ的请求应答模型的消息发送是有一定规则的，client需要以整体一次或者循环调用zmq_send()和zmq_recv()，如果连续发送两次zmq_send()将会报错返回-1；同样的在server端也是需要依次调用zmq_recv()和zmq_send()。</p>
<h3 id="特殊的命名方式"><a href="#特殊的命名方式" class="headerlink" title="特殊的命名方式"></a>特殊的命名方式</h3><p>ZeroMQ源码中以s_开头的表示是静态方法或者静态变量</p>
]]></content>
      <categories>
        <category>网络通信</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>网络通信</tag>
        <tag>消息队列</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos</title>
    <url>/2021/03/26/Paxos%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Paxos is a consensus algorithm executed by a set of processes, termed replicas, to agree on a single value in the presence of failures.<br><br>Lamport提出的Paxos算法用于解决分布式系统中一致性问题：将所有节点都写入同一个值，且被写入后不再更改。Paxos算法又分为两种：</p>
<ol>
<li>Basic Paxos算法：描述多节点如何就某个提案Value达成共识</li>
<li>Multi-Paxos算法：描述执行多个Basic Paxos的实例如何就一系列值达成共识。<br><br>Paxos算法的变种有：Fast Paxos、Cheap Paxos、Raft算法等。</li>
</ol>
<h3 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h3><ol>
<li><p>角色是Basic Paxos算法中最核心的三个功能的抽象：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>提议者Proposer</td>
<td>提议一个用于投票表决的值，即提案Value。在大多数的分布式场景下，集群中收到客户端请求的节点会是一个Proposer。</td>
<td>接入和协调功能：在收到客户端请求后，发起二阶段提交，进行共识协商</td>
</tr>
<tr>
<td>接受者Acceptor</td>
<td>负责对每个提议的值进行投票，并存储接受的值。一般来说，集群中的所有节点都在扮演Acceptor的角色，参与共识协商并接受和存储数据。</td>
<td>投票协商与数据存储功能：对提案Value进行投票，并接受达成共识的值，存储保存</td>
</tr>
<tr>
<td>学习者Learner</td>
<td>被通知投票的结果，接受并存储达成共识的值，不参与投票过程。一般来说，集群中的数据备份节点，比如主从结构宏的从节点是Learner，被动接受并保存数据，进行容灾备份。</td>
<td>数据存储功能：不参与共识协商，只进行达成共识的值接受与存储</td>
</tr>
</tbody></table>
</li>
</ol>
<p>在一致性协议框架中，集群中的节点可以同时承担以上多种角色。</p>
<span id="more"></span>
<ol start="2">
<li>如何达成共识？<br><br>Basic Paxos算法采用带有编号和提议值的提案代表一个提议，编号是用来区分不同的提议者。整个共识协商的过程共分为两个阶段：<ol>
<li>准备阶段<ol>
<li>提议者分别向所有接受者发送包含提案编号的准备请求（该阶段的请求中不携带具体的提议值）</li>
<li>接收节点接收到准备请求的处理也分为两种case：<ol>
<li>如果接收节点之前没有通过任何提案，则返回一个“尚无提案”的响应，并承诺不再响应提案编号小于等于当前提案编号的请求，不会通过编号小于当前编号的提案</li>
<li>如果接收到小于之前响应的准备请求的提案编号的提案，则丢弃该准备请求，不响应</li>
<li>如果接受者之前已经有通过提案，接受者会在准备请求的响应中包含已经通过的最大编号的提案。</li>
</ol>
</li>
</ol>
</li>
<li>接受阶段<ol>
<li>提议者在接收到大多数节点的准备响应之后，<em><strong>会根据响应中提案编号最大的提案的值，设置接受请求中的值（如果之前已经有达成共识的提议值，则不会修改该值）</strong></em>并发送接受请求</li>
<li>接受者收到接受请求值根据自己承诺过的提案值来选择接受或者拒绝，并将接受结果通知给所有学习者</li>
<li>学习者发现大多数的接受者都通过某个提案，它也通过该提案并接受该提议值<br><br>从上面的分析中可以看出：Basic Paxos是利用二阶段提交的方式来达成共识的，且由于“大多数”的概念的存在，意味着Basic Paxos算法还实现了容错，即在少于一半的节点出现故障时，集群依旧可以工作。<br><br>paxos将提议与leader进行分离，第一阶段选举leader而第二阶段选举最终提议。保证了当最初的共识方案提议者出故障的情况下，该提议也会被接受者发给后续提议者去继承。</li>
</ol>
</li>
</ol>
</li>
<li>basic Paxos的局限性：<ol>
<li>活锁问题：<br><br>　　Paxos理论上存在一个不能终结协议的活锁竞争问题。比如：当一个proposer提交的提议因为编号过低被拒绝时, 该proposer可能会提高编号重新提交。 如果同时有两个proposer都发现自己的方案编号过低, 从而轮流提出更高编号的proposal而导致对方被拒, 就可能会导致死循环(或活锁)。</li>
<li>恶意节点：<br><br>　　Paxos是假设所有节点都遵守协议的规定，不存在恶意节点的。</li>
<li>提案冲突:<br><br>  Basic Paxos实际上是一个无主（leader）的算法，可以有多个提议者，如果同一时刻多个提议者同时发起准备请求，提案编号相同的提案可能会存在平分票数的问题。</li>
</ol>
</li>
</ol>
<h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h3><p>Lamport的Multi-Paxos算法只是一个思想，没有提供具体的实现细节或者编程细节。不同的实现者实现出来的Multi-Paxos的实现细节是不同的。 Multi-Paxos的设计动机是解决Basic Paxos只能就单一提案Value达成共识的局限性，来实现一系列提案Value的共识。</p>
]]></content>
      <categories>
        <category>分布式协议</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>binlog与redolog</title>
    <url>/2021/03/26/binlog%E4%B8%8Eredolog/</url>
    <content><![CDATA[<p>日志是Mysql数据库的重要组成部分，记录着数据库运行期间各种状态信息。Mysql的日志系统主要有错误日志、查询日志、慢查询日志、事务日志（redolog和undolog）、二进制日志（binlog）几大类。<br><br>其中：事务日志是InnoDB存储引擎层的日志，而二进制日志binlog是MysqlServer层记录的日志。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="什么是binlog？"><a href="#什么是binlog？" class="headerlink" title="什么是binlog？"></a>什么是binlog？</h4><p>binlog是属于数据库Server层面的逻辑日志，又称归档日志,使用任何存储引擎的Mysql数据库都会记录binlog日志。<br><br>binlog以二进制的形式记录数据库执行的写入性操作(不包括查询，即select与show等执行语句)信息<br><br>binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<h6 id="逻辑日志与物理日志"><a href="#逻辑日志与物理日志" class="headerlink" title="逻辑日志与物理日志"></a>逻辑日志与物理日志</h6><ol>
<li>逻辑日志：可以简单理解为记录的就是sql语句。</li>
<li>物理日志：因为Mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更。<h4 id="binlog的使用场景"><a href="#binlog的使用场景" class="headerlink" title="binlog的使用场景"></a>binlog的使用场景</h4>在实际应用中，binlog的主要使用场景有两个，分别是主从复制和数据恢复：</li>
<li>主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端relay binlog从而达到主从数据一致。</li>
<li>数据恢复：通过使用mysqlbinlog工具来恢复数据。<h4 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h4>对于InnoDB存储引擎而言，只有在事务提交时才会记录binlog，此时记录还在内存中，那么binlog是什么时候刷到磁盘中的呢？<br><br>Mysql通过sync_binlog参数控制biglog的刷盘时机，取值范围是0-N：</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>不去强制要求，由系统自行判断何时写入磁盘</td>
</tr>
<tr>
<td>1</td>
<td>每次commit的时候都要将binlog写入磁盘</td>
</tr>
<tr>
<td>N</td>
<td>每N个事务，才会将binlog写入磁盘</td>
</tr>
</tbody></table>
<p><br>从上面可以看出，sync_binlog最安全的是设置是1，这也是MySQL 5.7.7之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p>
<h4 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h4><p>binlog日志有三种格式，分别为STATMENT、ROW和MIXED。<br><br>在 MySQL5.7.7之前，默认的格式是STATEMENT；而MySQL5.7.7之后，默认值是ROW。日志格式通过binlog-format指定。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>STATMENT</td>
<td>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。</td>
<td>不需要记录每一行的变化，减少了binlog日志量，节约了IO, 从而提高了性能</td>
<td>在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等。</td>
</tr>
<tr>
<td>ROW</td>
<td>基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了。</td>
<td>不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题；</td>
<td>会产生大量的日志，尤其是alter table的时候会让日志暴涨</td>
</tr>
<tr>
<td>MIXED</td>
<td>基于STATMENT和ROW两种模式的混合复制(mixed-based replication, MBR)。一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><p><br>WAL技术：<br><br>　　对于Mysql，如果每一次的更新操作都需要写入磁盘，然后磁盘需要对应找到该记录并更新，那么IO的成本以及磁盘文件查找的成本都会很高。所以Mysql利用WAL技术，即先写日志再写磁盘的技术来提升整个更新效率。</p>
<h4 id="什么是redolog？"><a href="#什么是redolog？" class="headerlink" title="什么是redolog？"></a>什么是redolog？</h4><p>redolog是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。<br><br>redolog包括两部分：一个是内存中的日志缓冲(redolog buffer)，另一个是磁盘上的日志文件(redolog file)。Mysql每执行一条DML语句，先将记录写入redolog buffer，后续某个时间点再一次性将多个操作记录写到redolog file中。<br><br>redolog是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</p>
<h4 id="redolog刷盘时机"><a href="#redolog刷盘时机" class="headerlink" title="redolog刷盘时机"></a>redolog刷盘时机</h4><p>Mysql支持三种将redolog buffer写入redolog file的时机，可以通过innodb_flush_log_at_trx_commit参数配置，各参数值含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>每次提交事务都只把redolog留在redolog buffer中</td>
</tr>
<tr>
<td>1</td>
<td>每次提交事务都将redolog 持久化到磁盘上（write+fsync）</td>
</tr>
<tr>
<td>2</td>
<td>每次都把redolog写到系统的page cache中（只write，不fsync）</td>
</tr>
</tbody></table>
<h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。<br><br>属于逻辑日志，根据每行记录进行记录。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化之大端小端序</title>
    <url>/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天写一个跨域跨模型通信的Demo演示程序时，服务端对应的函数调用就是没有触发。Debug的时候发现，两端的通信连接是建立成功的，但是当客户端发起服务调用时，服务端总是提示反序列化失败的提示。<br>既然是反序列化失败，就去找序列化的代码。然后发现，因为是跨模型通信，走的是同一个协议的两种通信框架，而这两种框架又分别采用大端序和小端序的字节存储方式，所以就造成了信息解码失败的问题。<br>所以想趁此机会，写一篇博客来详解下字节编码的字节序问题。</p>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>在计算机底层，所有的数据在存储和运算时都使用二进制表示。而对于同一组二进制数据，不同的个体定义的编码方式可能会将其解析成不同的符号。因此通信双方需要使用同一种编码方式才不会造成数据解析混乱。</p>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>ASCII码一共规定了128个字符的编码，只占用了一个字节的后面7位，最前面的1位统一规定为0。比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。<br><br>ASCII码主要用于表示英语和其它西欧语言。英语用128个符号便可以表示所有，但是用来表示其它语言，128个符号是不够的。于是，一些欧洲国家就决定，将字节最高位设为1，拓展到256个符号：其中0~127表示的符号是一样的，不一样的只是128 ~ 255的这一段。 这又引入了新的问题，同一个最高位为1的二进制字节在不同的国家中表示不同的符号。<br><br>而且对于类似于汉语这种文字种类比较多的语言来说，单字节的表示肯定是不够的，也就是需要多个字节来表示。</p>
<h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><p>对于ASCII码单字节不够使用的问题，不同的国家针对自己的语言会制定不同的编码方式。例如，中国的GB2312编码等。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。<br><br>为了解决乱码问题，Unicode这套统一所有文字的编码方式应运而生。<br><br>Unicode把所有语言都统一到一套编码里，每一个符号对应一个独一无二的二进制数。<br><br>注意：Unicode只是一套编码字符集，它只规定了符号与二进制数之间的映射关系，却没有规定这个二进制数应该如何存储载计算机上。因此，对于二级制数的解码仍然存在问题。比如：</p>
<ol>
<li>如何区分三个字节表示的二进制数是一个符号还是对应的三个符号？</li>
<li>如果固定了字节数，那么对于字节数小于固定字节数的符号的存储来说，会造成内存的极大浪费。</li>
</ol>
<h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF_8编码"></a>UTF_8编码</h3><p>UTF-8是Unicode的一种实现方式。它使用可变长的编码方式，一般是1到4个byte（也可以更长）来表示Unicode中的任何字符。而且其编码中的第一个字节仍与ASCII相容，用来表示字节编码方式：</p>
<ul>
<li>如果首字节以0开头，肯定是单字节编码，编码格式： 0xxxxxxx</li>
<li>如果以110开头，肯定是双字节编码，编码格式：110xxxxx 10xxxxxx</li>
<li>如果是1110开头，肯定是三字节编码，编码格式：1110xxxx 10xxxxxx 10xxxxxx</li>
<li>以此类推：除了单字节外，多字节UTF-8码的后续字节均以10开头。<br>其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示）。</li>
</ul>
<p>关于UTF_8编码为什么字节前两位固定为“10”的问题：<br><br>这是因为标准的utf-8设计，强制要求每个字符的除首字节外都必须为10xxxxxx这样的模式，它让每个字符边界能够自描述。当出现乱码或者位翻转的问题时，可以避免乱码问题。</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>是指多字节数据在计算机内存中存储或者网络传输时的存储顺序。有两种方式</p>
<ol>
<li>大端序BE：将高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
<li>小端序LE：将低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br><br>以unsigned int整型数据0x12345678为例，其大端序、小端序的存储内容如图所示：<table>
<thead>
<tr>
<th>内存地址</th>
<th>BE</th>
<th>LE</th>
</tr>
</thead>
<tbody><tr>
<td>0x01000001</td>
<td>0x12</td>
<td>0x78</td>
</tr>
<tr>
<td>0x01000002</td>
<td>0x34</td>
<td>0x56</td>
</tr>
<tr>
<td>0x01000003</td>
<td>0x56</td>
<td>0x34</td>
</tr>
<tr>
<td>0x01000004</td>
<td>0x78</td>
<td>0x12</td>
</tr>
</tbody></table>
</li>
</ol>
<p>不同的场景使用的字节序的方式是不同的：UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,存储在低地址，因此BE又称作网络字节序。</p>
]]></content>
  </entry>
  <entry>
    <title>Cmake使用笔记</title>
    <url>/2021/03/25/Cmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Redis的主从复制</title>
    <url>/2021/03/24/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>主从复制就是将一台服务器的数据复制到一个或者多个其他服务器中。一般与读写分离一起使用的，以为了提高数据库的高可用高并发性。<br>很多主流的数据库，消息中间件等都支持主从复制，比如：Mysql、Redis、RocketMq，Kafka等。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c</tag>
        <tag>缓存</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>内存溢出</title>
    <url>/2021/03/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>断言Assert</title>
    <url>/2021/03/24/%E6%96%AD%E8%A8%80Assert/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在对公司某项目进行代码评审的过程中，发现了断言机制使用不正确的问题。所以来记个笔记以避免自已以及看见这篇文章的同学们踩坑。</p>
<h3 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h3><p>程序一般分为“Debug”版和“Release”版，而断言一般是用于内部调试版，用于检查“不应该存在”的情况。</p>
<p>C和C++的断言机制一般通过调用assert()函数；<br>java类似的断言函数assert需要在断言开关-enableassertions或-ea开启的时候才起作用。为了避免与jdk14之前的assert关键字冲突，所以该开关默认是关闭的。</p>
<h3 id="C-的assert"><a href="#C-的assert" class="headerlink" title="C++的assert"></a>C++的assert</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>
<p>c++的assert本质是一个宏，原型定义在&lt;assert.h&gt;中。原理是判断表达式expression的值是否为0，如果为0，先向stderr打印一条Error信息，然后调用abort来终止进程。</p>
<h3 id="java的assert"><a href="#java的assert" class="headerlink" title="java的assert"></a>java的assert</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//有两种表示方式</span><br><span class="line"><span class="keyword">assert</span> <span class="type">bool</span>表达式  //当<span class="type">bool</span>表达式为<span class="keyword">false</span>的时候抛出AssertionError，并终止执行</span><br><span class="line"><span class="keyword">assert</span> <span class="type">bool</span>表达式：错误信息 //当<span class="type">bool</span>表达式为<span class="keyword">false</span>的时候抛出AssertionError，输出错误信息，并终止执行</span><br></pre></td></tr></table></figure>
<p><em>注意：java的大部分IDEA都默认assert机制是关闭的，需要手动java -ea打开开关</em></p>
<h3 id="assert的思考"><a href="#assert的思考" class="headerlink" title="assert的思考"></a>assert的思考</h3><p>因为在本次代码评审的过程中，发现了assert使用的两个问题：</p>
<ol>
<li>assert误用：<br> <br>在有些地方，assert被当作if滥用误用。比如一个祖先进程在创建进程时，如果参数读取失败，本来该走的代码逻辑是放弃该进程的创建，向上报异常或者输出Error信息。而该处使用assert直接导致整个程序异常终止。</li>
<li>冗余代码：<br> <br>在c++中如果assert的表达式返回的值是false，那么进程会调用abort终止并退出。因为对这一原理可能不是特别了解，所以评审的代码里出现了： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assert(expression);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">terminate</span>(); </span><br></pre></td></tr></table></figure>
 terminate定义在<exception>中，用于处理异常情况的，其默认实现是调用abort()。所以上面的代码，看出什么问题了么？</exception></li>
</ol>
<p>根据发现的问题以及个人平时的经验，我对assert的使用有以下几点建议：</p>
<ol>
<li>使用 assert() 时，被检测的表达式最好不要太复杂，最好的方式是一次断言只对应一个表达式。这样有助于在Debug调试的时候快速进行问题定位。</li>
<li>不要用会改变环境的语句作为断言的表达式，例如： <figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title"><span class="built_in">assert</span></span>(<span class="variable">i</span>++);</span></span><br></pre></td></tr></table></figure>
在Debug模式下，i的值会进行自增，但是切换到Release版本下，因为assert失效，所以i的值不会改变，可能会造成程序逻辑异常，比如：死循环等。因此，应该改为： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">assert(<span class="selector-tag">i</span>);</span><br><span class="line"><span class="selector-tag">i</span>++;</span><br></pre></td></tr></table></figure></li>
<li>如果是java语言，可以优先使用IDEA的debug调试或者Junit。因为assert的开关默认是关闭的，手动修改开关并不是在什么场合下都可以的，比如对于部署在容器里的Web程序来说就不是很方便。但是注意assert与Junit的判断出发点还是不同的，不能完全替代。前者是用于代码中逻辑条件点的判断，而后者是单元测试。</li>
</ol>
]]></content>
      <categories>
        <category>java、C++</category>
      </categories>
  </entry>
  <entry>
    <title>java.nio.bytebuffer解析</title>
    <url>/2021/03/23/java-nio-bytebuffer%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ByteBuffer继承自抽象类Buffer，用于在堆内存中预留一部分空间对IO数据做临时存储，以提高读写效率。与CharBuffer、IntBuffer等Buffer的其他子类的<br>区别在于数据类型的不同，但是关于缓冲区读写区域的管理全部由父类Buffer负责。<br><br> ByteBuffer类的定义：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="symbol">ByteBuffer</span></span><br><span class="line"><span class="symbol">extends</span> <span class="symbol">Buffer</span></span><br><span class="line"><span class="symbol">implements</span> <span class="symbol">Comparable</span>&lt;<span class="symbol">ByteBuffer</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>ByteBuffer自定义的属性字段：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">** 不为空，仅用于JVM堆缓存区  */</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line"><span class="comment">/** 数组的偏移量 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="comment">/** 是否只读 */</span></span><br><span class="line"><span class="keyword">boolean</span> isReadOnly;   </span><br><span class="line"><span class="comment">/** 是否采用默认排序：默认为大端序，为false时是小端序*/</span></span><br><span class="line"><span class="keyword">boolean</span> bigEndian = <span class="literal">true</span>;                                   <span class="comment">// package-private</span></span><br><span class="line"><span class="comment">// 本缓存的字节数据排列的顺序</span></span><br><span class="line"><span class="keyword">boolean</span> nativeByteOrder = (Bits.byteOrder() == ByteOrder.BIG_ENDIAN);<span class="comment">// package-private</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>继承自父类Buffer的属性字段：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Buffer本质上是一个数组，它是通过下面的属性来实现工作区域上数据的读写管理的。</span></span><br><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="comment">// 保存某个时刻的position指针的值，通过调用mark()实现可以与reset()函数搭配使用；当mark被置为负值时，表示废弃标记。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 缓冲区下一个可读/可写的元素的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 表示代操作数据的界限，limit-position=remaining</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="comment">// 表示缓冲空间的总容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ol>
<li>因为Buffer的本质是一个数组，所以在使用Buffer之前需要为其分配内存空间。ByteBuffer的创建可以通过分配内存空间或者将现有的字节数组包装到缓冲区中：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接分配内存，与操作系统的耦合性更高，速度更快，但是分配的开销更大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在java堆上分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将array从offset开始的length长的subArray包装到缓冲区buffer中，buffer的position等于offset，limit=offset+length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] <span class="built_in">array</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(<span class="built_in">array</span>, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将array数组包装到缓冲区，数组和butebuffer的任意一方存在改动都会互相影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>ByteBuffer.warp(byte[])以一个数组创建buffer后，该buffer默认处于读模式，即position=0,limit=capacity。此时若使用put进行写入，将从0位置开始覆盖掉初始化数组的数据。因此，若初始化的数据是有用数据，在写入开始前应使用compact()压实后，从尾部开始写入。</strong></em></p>
<ol start="2">
<li>缓冲区数据的读写<br>Buffer的工作方式主要为向缓冲区写入数据或者从缓冲区读取数据。<br><br>Buffer的缓冲区长度capacity在初始化之后就是不可修改的，只能通过position与limit划分活动区域。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取活动区域的数据长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rem = limit - <span class="built_in">position</span>;</span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该缓冲区是否还存在活动区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">position</span> &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>缓冲区数据的读写方法：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相对位置读，读取的字节是该缓冲区的当前position，读完后，position+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 相对位置写，写入的字节是该缓冲区的当前position，写完后，position+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 绝对位置读（绝对位置的读写是不会修改positon的值的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 绝对位置写</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> abstract ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 相对位置读取大块量数据到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; <span class="built_in">end</span>; i++)</span><br><span class="line">        dst[i] = <span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相对位置写入大批量数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">put</span>(src.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; <span class="built_in">end</span>; i++)</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">put</span>(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">put</span>(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Buffer的类型包括了所有的除boolean外的基本数据类型。ByteBuffer可以通过调用asXXXBuffer()转换成XXX类型的Buffer，例如：<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换得到IntBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">IntBuffer <span class="title">asIntBuffer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 对应的还有IntBuffer响应的读写方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">ByteBuffer <span class="title">putInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
其他方法，一般在读写模式切换前会调用clear()、flip()、compact()等方法：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空缓冲区，该方法并不会真的清除缓冲区的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转方法，向前反转活动区域，一般用于准备数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = <span class="built_in">position</span>;</span><br><span class="line">    <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    mark = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** The bytes between the buffer&#x27;s current position and its limit, if any, are copied to the beginning of the buffer. </span></span><br><span class="line"><span class="comment">* That is, the byte at index p = position() is copied to index zero, </span></span><br><span class="line"><span class="comment">*    the byte at index p + 1 is copied to index one, </span></span><br><span class="line"><span class="comment">*    and so forth until the byte at index limit() - 1 is copied to index n = limit() - 1 - p. </span></span><br><span class="line"><span class="comment">* The buffer&#x27;s position is then set to n+1 and its limit is set to its capacity. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 向前压实“活动区域”，准备开始写入。将Buffer中剩余的数据区域移动到头部，再将“活动区域”设置为除数据区域外的末尾部分。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> abstract ByteBuffer <span class="title">compact</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ解析二</title>
    <url>/2021/03/23/RocketMQ%E8%A7%A3%E6%9E%90%E4%BA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>进程创建与退出</title>
    <url>/2021/03/22/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BA/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>最近在参与公司某项目平台组件代码评审的任务，刚好与操作系统的进程创建管理相关。于是，就想就着工作中发现的问题以及自己的一些总结来写点什么，既是复习又是学习。
</code></pre>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><pre><code>老生常谈，各博客平台写烂了的东西。
</code></pre>
<h2 id="Linux系统特殊的进程"><a href="#Linux系统特殊的进程" class="headerlink" title="Linux系统特殊的进程"></a>Linux系统特殊的进程</h2><p>　　在Linux系统中，除了系统启动之后的第一个进程由系统来创建，其余的进程都必须由某个父进程来创建。</p>
<ul>
<li><p>0号进程：<br><br>　　在系统启动及完成初始化之后，Linux自动创建的进程叫做根进程。根进程是Linux中所有进程的祖宗，pid为0的Idle进程。这也是唯一一个不是由fork也不是由kernel_thread创建的进程。<br>&lt;!-more&gt;</p>
</li>
<li><p>1号进程init：<br>　　由Idle进程调用Kernel_thread创建一个内核线程去执行init函数，该内核线程即init进程，pid为1。init函数继续初始化，此时依旧共享父进程即0号进程的资源属性，直至init函数的最后调用系统的execve，以装入用户空间的可执行文件/sbin/init，此时进程pid1拥有自己的属性资源，且内核的初始化和启动过程结束。<br>　　<code>kernel_thread(kernel_init, NULL, CLONE_FS);</code><br>　　init进程是所有用户进程的祖先。</p>
</li>
<li><p>2号进程kthreadd：<br>　　由Idle进程调用Kernel_thread创建，运行在内核空间，负责所有内核进程的调度和管理，pid为2。<br>　　<code>pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</code><br>　　会循环执行kthread函数，该函数的作用就是运行kthread_create_list全局链表中维护的kthread, 当我们调用kernel_thread创建的内核线程会被加入到此链表中。<br>　　该进程是所有内核进程的祖先。</p>
<h3 id="init与systemd"><a href="#init与systemd" class="headerlink" title="init与systemd"></a>init与systemd</h3><p>ubuntu9.10-14.10，系统的启动过程是：<br>　　　　开机自检BIOS====》加载MBR中的GRUB引导====》加载内核====》init进程初始化</p>
<p>之后，ubuntu对内核的初始化进行了改进，启动过程如下：<br>　　　　开机自检BIOS====》加载MBR中的GRUB2引导====》加载内核====》Systemd进程初始化</p>
<p>　　init进程与system进程的区别:</p>
<table>
<thead>
<tr>
<th align="left">init进程</th>
<th align="left">systemd进程</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><br>　　　1. init进程的启动时间长，进程的启动是串行执行的<br>　　　2. 启动脚本复杂，init进程只是执行启动脚本，不管其他事情，脚本需要自己处理各种情况<br>　　　3. 位于/sbin/init</td>
<td align="left"><br>　　　1. 按需启动服务，减少系统资源消耗<br>　　　2. 尽可能并行启动进程，减少系统启动等待时间<br>　　　3. 位于 /usr/lib/systemd/systemd</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>进程创建首先是在进程表中为进程建立一个进程控制块PCB。<br><br>PCB通常记载进程之相关信息，包括：</p>
<ul>
<li>进程状态：可以是new、ready、running、waiting或 blocked等。</li>
<li>程序计数器：下一条要运行的指令地址。</li>
<li>CPU寄存器：如累加器、变址寄存器、堆栈指针以及一般用途寄存器、状况代码等，</li>
<li>CPU调度算法：优先级、调度队列等指针以及其他参数。</li>
<li>存储器管理：如标签页表等。</li>
<li>输入输出状态：配置进程使用I/O设备，如磁带机等</li>
</ul>
<p>在 Linux 内核中,供用户创建进程的API调用有fork()，vfork()，clone() ，这三个函数的对应的系统调用是：sys_fork()、sys_clone()、sys_vfork()。<br>fork、vfork以及 clone 的区别：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">语法格式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fork</td>
<td align="left">fork创造的子进程是父进程的完整副本，复制了父进程的资源: task_struct,打开文件表，信号，命名空间虚拟地址空间（包括堆栈等）等。（写时复制） <br>fork的实现：do_fork(CLONE_SIGCHLD,…)</td>
</tr>
<tr>
<td align="left">vfork</td>
<td align="left">vfork创建的子进程与父进程共享虚拟地址空间，所以子进程的改变会影响父进程中的数据。vfork创建子进程后，父进程会被阻塞直到子进程调用exec或exit。  <br>vfork的实现：do_fork(CLONE_VFORK</td>
</tr>
<tr>
<td align="left">clone</td>
<td align="left">系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone()是则可以将父进程资源有选择地复制给子进程。<br>具体要复制哪些资源给子进程，由参数列表中的clone_flags决决定。<br>clone的实现：do_fork(CLONE_VM/CLONE_FS/CLONE_FILES/CLONE_SIGCHLD,…)</td>
</tr>
</tbody></table>
<p>fork与vfork都是由clone实现，底层是调用了内核的_do_fork函数。</p>
<h3 id="fork详解"><a href="#fork详解" class="headerlink" title="fork详解"></a>fork详解</h3><ol>
<li>写时复制：在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。<br>当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。<br>
因为当fork()后立即执行exec()，地址空间就无需被复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建一个进程描述符。在一般情况下，进程创建后都为马上运行一个可执行的文件，这种优化，可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)。
***<br>而vfork是连虚拟内存空间都不会创建，直接共享父进程的虚拟空间，即共享父进程的物理空间。***</li>
<li>fork的另一个特性是所有由父进程打开的描述符都被复制到子进程中。父、子进程中相同编号的文件描述符在内核中指向同一个file结构体，也就是说，file结构体的引用计数要增加。</li>
<li>fork创建进程失败返回-1，如果是子进程返回值为0，如果是父进程则返回子进程的pid。一个进程要执行一个不同的程序，比如fork后，子进程调用exec函数。</li>
<li>fork 还有一个特点：子进程不是从 main 函数开始执行的，而是从 fork 返回的地方开始</li>
</ol>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>当进程完成执行最后指令并且通过系统调用 exit() 向操作系统发出请求时，进程终止。这时，进程可以返回退出状态码（通常为整数）给父进程。所有进程资源，如物理和虚拟内存、打开文件和 I/O 缓冲区等，会由操作系统释放。</p>
<p>父进程需要通过调用wait()或者waitpid函数来收集子进程的退出状态。如果父进程未调用该函数来阻塞获取子进程的退出状态，那么子进程就是僵尸进程，会对系统造成危害。<br><br>这是因为即使进程退出时，操作系统会释放其占用的资源，但是它位于进程表中的项还是存在的，需要由父进程进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>参数pid为欲等待的子进程识别码：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">参数值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pid&lt;-1</td>
<td align="left">等待进程组号为pid绝对值的任何子进程。</td>
</tr>
<tr>
<td align="left">pid=-1</td>
<td align="left">等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。</td>
</tr>
<tr>
<td align="left">pid=0</td>
<td align="left">等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。</td>
</tr>
<tr>
<td align="left">pid&gt;0</td>
<td align="left">等待进程号为pid的子进程。</td>
</tr>
</tbody></table>
<p>pid为0与-1的区别在于：前者是收集所有子进程的退出状态码而后者是收集属于同一个进程组的子进程的退出状态码。父进程的子进程不一定与父进程或者其他兄弟进程同属于一个进程组。</p>
<ol start="2">
<li>而参数*status将保存子进程的状态信息，有了这个信息父进程就可以了解子进程是否正常退出。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WIFEXITED(status)</td>
<td align="left">如果子进程正常结束，它就返回真；否则返回假。</td>
</tr>
<tr>
<td align="left">WEXITSTATUS(status)</td>
<td align="left">如果WIFEXITED(status)为真，则可以用该宏取得子进程exit()返回的结束代码。</td>
</tr>
<tr>
<td align="left">WIFSIGNALED(status)</td>
<td align="left">如果子进程因为一个未捕获的信号而终止，它就返回真；否则返回假。</td>
</tr>
<tr>
<td align="left">WTERMSIG(status)</td>
<td align="left">如果WIFSIGNALED(status)为真，则可以用该宏获得导致子进程终止的信号代码。</td>
</tr>
<tr>
<td align="left">WIFSTOPPED(status)</td>
<td align="left">如果当前子进程被暂停了，则返回真；否则返回假。</td>
</tr>
<tr>
<td align="left">WSTOPSIG(status)</td>
<td align="left">如果WIFSTOPPED(status)为真，则可以使用该宏获得导致子进程暂停的信号代码。</td>
</tr>
</tbody></table>
<ol start="3">
<li>参数options提供了一些另外的选项来控制waitpid()函数的行为。如果不想使用这些选项，则可以把这个参数设为0。<br>如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。如果waitpid()函数执行成功，则返回子进程的进程号；如果有错误发生，则返回-1，并且将失败的原因存放在errno变量中。</li>
</ol>
<h3 id="exec簇"><a href="#exec簇" class="headerlink" title="exec簇"></a>exec簇</h3><p>exec函数一共有六个，其中execve为内核级系统调用，其他都是调用execve的库函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习之__attribute__机制</title>
    <url>/2021/03/17/Linux%E7%9A%84load-average/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B-attribute/</url>
    <content><![CDATA[<p>__attribute__是GNU C特色之一，可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.</p>
<p>语法格式： __attribute __((abute-list))</p>
<p>位置：声明结束符“；”的前面</p>
<p><em>在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</em></p>
<h1 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h1><p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。</p>
<p>GNU CC需要使用 –Wall，这是控制警告信息的一个很好的方式。</p>
<p>下面是常见的属性参数：</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">语法格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">noreturn</td>
<td align="center">noreturn</td>
<td align="left">该属性通知编译器函数从不返回值。<br>当遇到函数需要返回值却还没运行到返回值处就已退出来的情况，该属性可以避免出现错误信息。<br>C库函数中的abort（）和exit（）的声明格式就采用了这种格式：<br>   (1) extern void  exit(int)   <strong>attribute</strong>( ( noreturn ) );<br>   (2) extern void  abort(void)  <strong>attribute</strong>( ( noreturn ) );</td>
</tr>
<tr>
<td align="left">noinline</td>
<td align="center">noinline</td>
<td align="left">用inline修饰的函数能否形成内联，需要看编译器对该函数定义的具体处理。该参数表示：不内联</td>
</tr>
<tr>
<td align="left">always_inline</td>
<td align="center">always_inline</td>
<td align="left">总是内联</td>
</tr>
<tr>
<td align="left">const</td>
<td align="center">const</td>
<td align="left">该属性只能用于带有数值类型参数的函数上，当重复调用带有数值参数的函数时，由于返回值是相同的。所以此时编译器可以进行优化处理，除第一次需要运算外， 其它只需要返回第一次的结果。<br> <em><strong>const参数不能用在带有指针类型参数的函数中，因为该属性不但影响函数的参数值，同样也影响到了参数指向的数据，它可能会对代码本身产生严重甚至是不可恢复的严重后果。</strong></em></td>
</tr>
<tr>
<td align="left">format</td>
<td align="center">format (archetype, string-index, first-to-check)</td>
<td align="left">该属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。<br>format属性告诉编译器，按照 printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。<br>“archetype”指定是哪种风格；<br>“string-index”指定传入函数的第几个参数是格式化字符串；<br>“first-to-check”指定第一个可变参数所在的索引。</td>
</tr>
<tr>
<td align="left">finstrument-functions</td>
<td align="center">finstrument-functions</td>
<td align="left">该参数可以使程序在编译时，在函数的入口和出口处生成instrumentation调用。增加的这两个函数分别为：<br> <code>void __cyg_profile_func_enter (void *this_fn, void *call_site);</code> <br> <code>void __cyg_profile_func_exit  (void *this_fn, void *call_site);</code><br>其中第一个参数为当前函数的起始地址，第二个参数为返回地址，即caller函数中的地址。</td>
</tr>
<tr>
<td align="left">no_instrument_function</td>
<td align="center">no_instrument_function</td>
<td align="left">gcc加上“-finstrument-functions”选项用来跟踪函数的调用关系，在每个函数的入口和出口处会各增加一个额外的hook函数的调用。如果不想跟踪某个函数，可以给该函数指定“no_instrument_function”属性。</td>
</tr>
<tr>
<td align="left">constructor</td>
<td align="center">constructor/constructor(n)</td>
<td align="left">若函数被设定为constructor属性，则该函数会在 main（）函数执行之前被自动的执行。<br>n表示当存在多个被修饰的函数时，执行的优先级顺序，如果没设置n，则执行顺序不确定，其中[0,100]是系统保留的,不可以调用。数值越小,越先调用。<br><em><strong>执行顺序为:load-&gt;constructor-&gt;main，因为：dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法,然后才调用main函数.</strong></em></td>
</tr>
<tr>
<td align="left">destructor</td>
<td align="center">destructor/destructor(n)</td>
<td align="left">与constructor相似，若函数被设定为destructor属性，则该函数会在main（）函数执行之后或者exit（）被调用后被自动的执行。<br>  拥有此类属性的函数经常隐式的用在程序的初始化数据方面。数值越大,越先调用</td>
</tr>
<tr>
<td align="left">unavailable</td>
<td align="center">unavailable(“错误信息”)</td>
<td align="left">适用于方法、属性。告诉编译器不可用。如果使用了，就会编译失败，提示错误信息</td>
</tr>
<tr>
<td align="left">deprecated</td>
<td align="center">deprecated(“警告信息”)</td>
<td align="left">适用于方法、属性。告诉编译器已经过时，如果使用了，会报过时警告</td>
</tr>
<tr>
<td align="left">nonnull</td>
<td align="center">nonnull(int,int,…)</td>
<td align="left">编译器对函数参数进行NULL的检查,参数类型必须是指针类型(包括对象)</td>
</tr>
<tr>
<td align="left">visibility</td>
<td align="center">visibility(“visibilityType”)</td>
<td align="left">该关键字与gcc编译参数-fvisibility=hidden配合使用。<br>visibility_type 是下列值之一：<br>  <strong>default</strong>:先使用-fvisibility=hidden将所有符号隐藏，然后在需要对外的符号前添加__attribute__((visibility(“default”)))属性来保证符号对外可见;<br>  <strong>hidden</strong>:该符号不存放在动态符号表中，因此，其他可执行文件或共享库都无法直接引用它。使用函数指针可进行间接引用。将-fvisibility设置为”default”或不设置这个属性，默认所有符号都对外可见，然后在不对外可见的函数或变量前添加__attribute__((visibility(“hidden”)))来隐藏该符号。<br>  <strong>internal</strong>:除非由特定于处理器的应用二进制接口 (psABI) 指定，否则，内部可见性意味着不允许从另一模块调用该函数;<br>  <strong>protected</strong>:该符号存放在动态符号表中，但定义模块内的引用将与局部符号绑定。也就是说，另一模块无法覆盖该符号。</td>
</tr>
</tbody></table>
<h2 id="同时使用多个参数"><a href="#同时使用多个参数" class="headerlink" title="同时使用多个参数"></a>同时使用多个参数</h2><p>可以在同一个函数声明里使用多个__attribute__。使用方式上，你可以选择两个单独的__attribute__，或者把它们写在一起，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>  <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format， ...)</span>   __<span class="title">attribute__</span><span class="params">( (noreturn))</span>   __<span class="title">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>)) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>  <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format，...)</span>    __attribute __<span class="params">( (noreturn,  format(<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>)) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果带有该属性的自定义函数被追加到库的头文件里，那么所以调用该函数的程序都要做相应的检查。</p>
<p>需要说明的是，__attribute__适用于函数的声明而不是函数的定义。所以，当需要使用该属性的函数时，必须在同一个文件里进行声明，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format， ... )</span> __attribute __<span class="params">( (noreturn) )</span> __attribute __<span class="params">( ( format(<span class="built_in">printf</span>，<span class="number">1</span>，<span class="number">2</span>) ) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *format，... )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 函数定义 */</span>  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h1><p>关键字__attribute__也可以对变量（variable）或结构体成员（structure field）进行属性设置。</p>
<p>下面是常见的属性参数：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">语法格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aligned</td>
<td align="center">aligned(n)</td>
<td align="left">让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。<br> <em><strong>aligned后面必须跟2的次幂，其他的编译器报错。当我们传入1和2的时候，编译器模式都是以4字节对齐的，且只有结构体上下两个字段是char类型的才会将其合并处理</strong></em></td>
</tr>
<tr>
<td align="left">packed</td>
<td align="center">packed</td>
<td align="left">用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中.</td>
</tr>
<tr>
<td align="left">cleanup</td>
<td align="center">cleanup(func)</td>
<td align="left">声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数。<br>   指定的函数传递的参数是变量的地址;<br>   当作用域内有多个cleanup的变量时,遵守先入后出的栈式结构。<br><em><strong>cleanup的执行先于dealloc</strong></em></td>
</tr>
</tbody></table>
<h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><p>关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。</p>
<p>下面是常见的属性参数：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">语法格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aligned</td>
<td align="center">aligned(n)</td>
<td align="left">让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。<br> <em><strong>aligned后面必须跟2的次幂，其他的编译器报错。当我们传入1和2的时候，编译器模式都是以4字节对齐的，且只有结构体上下两个字段是char类型的才会将其合并处理</strong></em></td>
</tr>
<tr>
<td align="left">packed</td>
<td align="center">packed</td>
<td align="left">用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中.</td>
</tr>
<tr>
<td align="left">deprecated</td>
<td align="center">deprecated(“警告信息”)</td>
<td align="left">适用于方法、属性。告诉编译器已经过时，如果使用了，会报过时警告</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ源码解析之RemotingCommand</title>
    <url>/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/</url>
    <content><![CDATA[<p>rocketmq-remoting模块是RocketMQ消息队列中负责网络通信的模块，底层框架是依赖于Netty的。<br><br>为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ自定义了通信协议。</p>
<h1 id="通信协议及编解码方式"><a href="#通信协议及编解码方式" class="headerlink" title="通信协议及编解码方式"></a>通信协议及编解码方式</h1><p>RemotingCommand这个类封装了消息消息传输过程中的所有数据内容，并负责消息的编码和解码操作。</p>
<h2 id="RocketMQ的消息格式"><a href="#RocketMQ的消息格式" class="headerlink" title="RocketMQ的消息格式"></a>RocketMQ的消息格式</h2><p>RocketMQ的一条消息包含四个部分：<br><img src="/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" alt="消息格式.png"></p>
<ol>
<li>消息长度：消息的总长度，占4个字节</li>
<li>序列化类型&amp;消息头长度：占4个字节，第一个字节代表序列化类型，后三个字节为消息头的长度</li>
<li>消息头：RocketMQ定义的通用消息头数据加上不同请求或者响应的自定义字段</li>
<li>消息正文</li>
</ol>
<p>下面是RocketMQ官方定义的消息头的字段：</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>Header字段</th>
<th>类型</th>
<th>Request说明</th>
<th>Response说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td>
<td>应答响应码。0表示成功，非0则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通RPC还是onewayRPC得标志</td>
<td>区分是普通RPC还是onewayRPC得标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p>RemotingCommand类里关于消息Header的数据声明：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应码/请求操作码</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> code;</span><br><span class="line"><span class="comment">// RocketMQ定义的枚举类型，支持JAVA、CPP、PYTHON、GO、OHP、RUBY等</span></span><br><span class="line"><span class="keyword">private</span> LanguageCode language = LanguageCode.JAVA;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> version = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 请求码</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> opaque = requestId.getAndIncrement();</span><br><span class="line"><span class="comment">// flag为0表示request， flag为1表示response， flag为2或者3，表示OneWayRPC</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> remark;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; extFields;</span><br><span class="line"><span class="comment">// 不同请求类型的请求头的特殊字段的序列化处理类，与extFields搭配使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> CommandCustomHeader customHeader;</span><br><span class="line"><span class="comment">// 当前RPC的序列化方式，默认与服务器配置相同。RocketMQ支持两种序列化方式：Json以及自定义的RocketMQ消息</span></span><br><span class="line"><span class="keyword">private</span> SerializeType serializeTypeCurrentRPC = serializeTypeConfigInThisServer;</span><br></pre></td></tr></table></figure>
<h2 id="消息编码"><a href="#消息编码" class="headerlink" title="消息编码"></a>消息编码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 消息编码</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1&gt; header length size，RocketMQ消息的长度，占用4个字节</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2&gt; header data length 序列化消息头并获取对应消息头的长度</span></span><br><span class="line">    <span class="keyword">byte</span>[] headerData = <span class="keyword">this</span>.headerEncode();</span><br><span class="line">    length += headerData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3&gt; body data length 消息正文的数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.body != null) &#123;</span><br><span class="line">        length += body.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配4+length个字节的缓冲区，其中4是序列化方式+表示消息头长度的数值占用的字节</span></span><br><span class="line">    ByteBuffer result = ByteBuffer.allocate(<span class="number">4</span> + length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length 编码消息数据，最开始的4个字节是消息长度</span></span><br><span class="line">    result.putInt(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header length 写入序列化类型和消息头长度的数据</span></span><br><span class="line">    result.<span class="built_in">put</span>(markProtocolType(headerData.length, serializeTypeCurrentRPC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header data 写入消息头</span></span><br><span class="line">    result.<span class="built_in">put</span>(headerData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// body data; 写入消息正文数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.body != null) &#123;</span><br><span class="line">        result.<span class="built_in">put</span>(<span class="keyword">this</span>.body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻转Bytebuffer的活动区域为写入的数据</span></span><br><span class="line">    result.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] headerEncode() &#123;</span><br><span class="line">    <span class="keyword">this</span>.makeCustomHeaderToNet();</span><br><span class="line">    <span class="comment">// 根据不同的序列化方式序列化消息头</span></span><br><span class="line">    <span class="keyword">if</span> (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) &#123;</span><br><span class="line">        <span class="keyword">return</span> RocketMQSerializable.rocketMQProtocolEncode(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RemotingSerializable.encode(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用反射获取自定义消息头相关的拓展字段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCustomHeaderToNet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customHeader != null) &#123;</span><br><span class="line">        Field[] fields = getClazzFields(customHeader.getClass());</span><br><span class="line">        <span class="keyword">if</span> (null == <span class="keyword">this</span>.extFields) &#123;</span><br><span class="line">            <span class="keyword">this</span>.extFields = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isStatic(field.<span class="built_in">getModifiers</span>())) &#123;</span><br><span class="line">                <span class="keyword">String</span> name = field.getName();</span><br><span class="line">                <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;this&quot;</span>)) &#123;</span><br><span class="line">                    Object value = null;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 利用反射打开属性的访问权限的开关</span></span><br><span class="line">                        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        value = field.<span class="built_in">get</span>(<span class="keyword">this</span>.customHeader);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="built_in">log</span>.error(<span class="string">&quot;Failed to access field [&#123;&#125;]&quot;</span>, name, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (value != null) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.extFields.<span class="built_in">put</span>(name, value.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编码消息头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">encodeHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> encodeHeader(<span class="keyword">this</span>.body != null ? <span class="keyword">this</span>.body.length : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">encodeHeader</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> bodyLength)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1&gt; header length size</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2&gt; header data length</span></span><br><span class="line">    <span class="keyword">byte</span>[] headerData;</span><br><span class="line">    headerData = <span class="keyword">this</span>.headerEncode();</span><br><span class="line"></span><br><span class="line">    length += headerData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3&gt; body data length</span></span><br><span class="line">    length += bodyLength;</span><br><span class="line">    <span class="comment">// 分配除了正文外的缓冲区</span></span><br><span class="line">    ByteBuffer result = ByteBuffer.allocate(<span class="number">4</span> + length - bodyLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// length</span></span><br><span class="line">    result.putInt(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header length</span></span><br><span class="line">    result.<span class="built_in">put</span>(markProtocolType(headerData.length, serializeTypeCurrentRPC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// header data</span></span><br><span class="line">    result.<span class="built_in">put</span>(headerData);</span><br><span class="line"></span><br><span class="line">    result.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编码消息的序列化类型加消息头长度的信息， 占据4个字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] markProtocolType(<span class="keyword">int</span> source, SerializeType type) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 序列化类型：0表示json而1表示RocketMQ</span></span><br><span class="line">    result[<span class="number">0</span>] = type.getCode();</span><br><span class="line">    result[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((source &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    result[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((source &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    result[<span class="number">3</span>] = (<span class="keyword">byte</span>) (source &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息编码-1"><a href="#消息编码-1" class="headerlink" title="消息编码"></a>消息编码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息解码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RemotingCommand <span class="title">decode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.wrap(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">return</span> decode(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息解码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RemotingCommand <span class="title">decode</span><span class="params">(<span class="keyword">final</span> ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息长度</span></span><br><span class="line">    <span class="keyword">int</span> length = byteBuffer.limit();</span><br><span class="line">    <span class="comment">// 取消息的前四个字节，其中第一个字节表示序列化类型后三个字节表示消息头的长度，byteBuffer的position向后移动四个字节</span></span><br><span class="line">    <span class="keyword">int</span> oriHeaderLen = byteBuffer.getInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> headerLength = getHeaderLength(oriHeaderLen);</span><br><span class="line">    <span class="comment">// 获取消息头数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] headerData = <span class="keyword">new</span> <span class="keyword">byte</span>[headerLength];</span><br><span class="line">    byteBuffer.<span class="built_in">get</span>(headerData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化headerData为RemotingCommand对象</span></span><br><span class="line">    RemotingCommand cmd = headerDecode(headerData, getProtocolType(oriHeaderLen));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息正文的长度：消息的长度减去固定的四个字节（序列化类型+消息头的长度字节）再减去消息头的长度</span></span><br><span class="line">    <span class="keyword">int</span> bodyLength = length - <span class="number">4</span> - headerLength;</span><br><span class="line">    <span class="keyword">byte</span>[] bodyData = null;</span><br><span class="line">    <span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 填充消息正文内容</span></span><br><span class="line">        bodyData = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyLength];</span><br><span class="line">        byteBuffer.<span class="built_in">get</span>(bodyData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充RemotingCommand的body属性</span></span><br><span class="line">    cmd.body = bodyData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeaderLength</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取最后三个字节，表示消息头的长度</span></span><br><span class="line">    <span class="keyword">return</span> length &amp; <span class="number">0xFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RemotingCommand <span class="title">headerDecode</span><span class="params">(<span class="keyword">byte</span>[] headerData, SerializeType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> JSON:</span><br><span class="line">            RemotingCommand resultJson = RemotingSerializable.decode(headerData, RemotingCommand.class);</span><br><span class="line">            resultJson.setSerializeTypeCurrentRPC(type);</span><br><span class="line">            <span class="keyword">return</span> resultJson;</span><br><span class="line">        <span class="keyword">case</span> ROCKETMQ:</span><br><span class="line">            RemotingCommand resultRMQ = RocketMQSerializable.rocketMQProtocolDecode(headerData);</span><br><span class="line">            resultRMQ.setSerializeTypeCurrentRPC(type);</span><br><span class="line">            <span class="keyword">return</span> resultRMQ;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializeType <span class="title">getProtocolType</span><span class="params">(<span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 截断保留source的第一个字节，表示序列化类型</span></span><br><span class="line">    <span class="keyword">return</span> SerializeType.valueOf((<span class="keyword">byte</span>) ((source &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>链表反转系列</title>
    <url>/2019/04/05/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>限制:</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= 节点个数 &lt;= <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * public <span class="keyword">class</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> next;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) &#123; <span class="keyword">val</span> = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">    public <span class="type">ListNode</span> reverseList(<span class="type">ListNode</span> head) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之extern</title>
    <url>/2019/03/17/Linux%E7%9A%84load-average/C-%E4%B9%8Bextern/</url>
    <content><![CDATA[<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。<br>此外extern也可用来进行链接指定。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ol>
<li><p>与“C”连用进行链接指定</p>
<p>比如: </p>
<p><code>extern &quot;C&quot; void fun(int a, int b);</code></p>
<p> 则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名</p>
</li>
<li><p>extern声明变量</p>
<p> 比如，头文件 testExample.h</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br></pre></td></tr></table></figure>
<p> 源程序 testExample.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>主函数 main.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，a，b的声明也可放在main.c中。此时，就不需要包含 testExample.h这个头文件了。代码如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>extern声明函数</p>
<p>比如，头文件 testExample.h</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>源程序 testExample.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数 main.c</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;testExample.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(a, b) = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，a，b的声明也可放在main.c中。此时，就不需要包含 testExample.h这个头文件了。代码如下：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d , b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(a, b) = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="extern-与-static"><a href="#extern-与-static" class="headerlink" title="extern 与 static"></a>extern 与 static</h1><p>(1) extern 表明引用外部其他模块/单元定义的变量或者函数。</p>
<p>(2) static 表示静态变量，分配内存的时候, 存储在静态区而不是栈上面。static修饰全局变量的作用域只能是本身的编译单元，所以一般定义static全局变量时，都把它放在原文件中而不是头文件。</p>
<p><em><strong>extern和static不能同时修饰一个变量</strong></em></p>
<h1 id="extern-与-const"><a href="#extern-与-const" class="headerlink" title="extern 与 const"></a>extern 与 const</h1><p>C++中const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中。但是const可以与extern连用来声明该常量可以作用于其他编译模块中。当与extern一起合作的时候，它的特性就跟extern的一样，表示一个定义了的全局变量。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>JVM类加载机制</title>
    <url>/2018/03/24/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>一个.java文件从编码完成到最终执行，一般主要包括两个过程：编译和运行，其中编译就是通过javac编译器将.java文件转换成编译成字节码.class文件；然后运行则是把.class文件交给JVM执行的过程。<br>一个Java类从字节代码到能够在JVM中被使用，需要经过加载、链接和初始化这三个步骤，我们称之为类加载。下面我们就开始详解这三个步骤。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>把class字节码文件通过类加载器装载入内存中的阶段。在该阶段，JVM需要完成：</p>
<ol>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ol>
<p>类加载器可以分为：</p>
<ol>
<li>引导类加载器：最顶层的类加载器，负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被JVM认可（按文件名识别，如rt.jar）的类。</li>
<li>扩展类加载器：负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li>
<li>应用类加载器：可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，该类加载器就是默认的类加载器。</li>
<li>用户自定义的类加载器：继承自java.lang.ClassLoader类。</li>
</ol>
<p>类加载器的工作方式：</p>
<ol>
<li>双亲委派模型：加载过程中会先检查类是否被已加载，检查顺序是自底向上，从用户自定义类加载器到引导类加载器逐层检查，只要某个classloader已加载，就视为已加载此类，保证此类只会被所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</li>
<li>代理模式：指的是一个类加载器既可以自己完成Java类的加载工作，也可以代理给其它的类加载器来完成。由于代理模式的存在，启动一个类的加载过程的类加载器和最终加载这个类的类加载器可能并不是一个。前者称为初始类加载器，而后者称为定义类加载器。一个Java类的定义类加载器是该类所导入的其它Java类的初始类加载器。</li>
</ol>
<p>使用双亲委派模型的意义：</p>
<ol>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>链接阶段又分为验证、准备和解析。<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。如果验证过程出现错误的话，会抛出java.lang.VerifyError错误。主要验证以下几个内容：</li>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范，比如开头是否是以0xCAFEBABE开头，版本号是否是JVM支持处理的，以及常量表中是否存在不被支持的数据类型等</li>
<li>元数据验证：我理解就是语义分析，看是否存在比如继承了final修饰的类的这些不符合java语言规范要求的问题</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行，比如校验符号引用中通过全限定名是否能够找到对应的类，校验符号引用中的访问权限是否可被当前类访问等？</li>
</ol>
<p>验证阶段很重要，但是对于程序的运行期没有影响，所以并非必要的。可以通过-Xverifynone参数来关闭大部分的java类的验证行为，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>该阶段的目的是：为类的静态变量分配内存，并将其初始化为默认值。注意，这里的默认值不是我们在程序中设置的值，而是Java的初始值。JVM对于各数据类型指定的默认值如下：</p>
<ol>
<li>8大基本类型的默认值为0</li>
<li>引用类型的默认值为null</li>
<li><em><strong>被final和static共同修饰的变量（静态常量）的默认值为我们程序中设定的值，</strong></em> 例如：final static int a = 100，则准备阶段中a的初值就是100。<br>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>该阶段的目的是把常量池中的符号引用转换为直接引用。<br><br>符号引用是一个给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息的字面量。<br><br>直接引用可以理解为一个内存地址，或者一个偏移量或一个间接定位到目标的句柄。比如类方法，类变量的直接引用是指向方法区的指针；<br><br>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>该阶段主要为类的静态变量赋予正确的初始值，JVM主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
<p>JVM类初始化步骤</p>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<p>JVM类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ol>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Annotation(java注解)</title>
    <url>/2018/03/18/Linux%E7%9A%84load-average/Annotation-java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>注解提供一种为程序元素设置元数据的方法。元数据就是关于数据的数据，可以用来生成文档，进行代码分析或者使编译器对元数据进行编译检查。<br>可以使用注解解析工具或编译器对其进行解析，也可以指定注解在编译期或运行期有效。<br>　　　　　　　　　　　　　　　　　　　　　　<br>注解的基本原则是：无论增加或者删除一个注解都不能对代码造成干扰。</p>
<h2 id="系统注解"><a href="#系统注解" class="headerlink" title="系统注解"></a>系统注解</h2><p>　　1. Override：保证override函数的正确生明</p>
<p>　　2. Deprecated：对于过时不再使用的函数添加该注解，当该函数被调用时，编译时会提示。与javadoc的@deprecated类似，但前者不可以带参数</p>
<p>　　3. SupressWarnings： 配合参数表示关闭特定的警告信息。参数有：</p>
<p>　　　　　|参数名 | 语法格式 |<br>        | :— |  :—  |<br>     　　| deprecation | 使用了过时的类或者方法的警告  |<br>    　　 | unchecked |  执行了未检查的转换时警告  |<br>        | fallthrough |  switch语句某case下没有break语句直接通往下一个case的警告  |<br>    　　 | path |  在类路径或者源文件路径中存在不存在的路径的警告  |<br>        | finally |  finally语句不能正确执行的警告 |<br>        | all |  关闭所有警告信息  |</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><pre><code>元注解的作用就是负责注解其他注解。Java5定义了4个标准的Meta Annotation类型，它们被用来提供对其它 Annotation类型作说明。
</code></pre>
<p>　　　1. Target</p>
<p>　　　　　　作用：用于描述注解的使用范围，即被描述的注解可以用在什么地方</p>
<p>　　　　　　用法： @Target(ElementType.参数,…)</p>
<p>　　　　　　参数：</p>
<p>　　　　　　　　　CONSTRUCTOR：用于描述构造器</p>
<p>　　　　　　　　　FIELD：用于描述域</p>
<p>　　　　　　　　　LOCAL_VARIABLE：用于描述局部变量</p>
<p>　　　　　　　　　METHOD：用于描述方法</p>
<p>　　　　　　　　　PACKAGE：用于描述包</p>
<p>　　　　　　　　　PARAMETER：用于描述参数</p>
<p>　　　　　　　　　TYPE：用于描述类、接口(包括注解类型) 或enum声明</p>
<p>　　　2. Retention</p>
<p>　　　　　　作用： 标识该Annotation的生命周期</p>
<p>　　　　　　用法：　@Retention(RetentionPolicy.参数)</p>
<p>　　　　　　参数：</p>
<p>　　　　　　　　　SOURCE:在源文件中有效（即源文件保留），被编译器丢弃</p>
<p>　　　　　　　　　CLASS:在class文件中有效（即class保留），编译在class文件中的Annotation可能会被虚拟机忽略</p>
<p>　　　　　　　　　RUNTIME:在运行时有效（即运行时保留）</p>
<p>　　　3. Documented</p>
<p>　　　　　　<em><strong>@Documented是一个标记注解，没有成员</strong></em></p>
<p>　　　　　　作用：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。</p>
<p>　　　4.　Inherited</p>
<p>　　　　　　<em><strong>@Inherited 是一个标记注解。</strong></em></p>
<p>　　　　　  　作用: 如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个Annotation将被用于该class的子类。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>　　　Annotation类型使用关键字@interface而非interface，注意开头的@符号。interface可以被实现或者继承，Annotation不可以。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
