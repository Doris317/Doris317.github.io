<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Doris的搬砖日记</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-29T03:21:52.743Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Doris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BIO与NIO和AIO三种reactor模型</title>
    <link href="http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-29T03:21:52.000Z</published>
    <updated>2021-03-29T03:21:52.743Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++11之default与delete关键字</title>
    <link href="http://example.com/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-03-29T02:14:31.000Z</published>
    <updated>2021-03-29T02:14:31.152Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode190.颠倒二进制位</title>
    <link href="http://example.com/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://example.com/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</id>
    <published>2021-03-29T01:22:19.000Z</published>
    <updated>2021-03-29T01:55:34.888Z</updated>
    
    
    <summary type="html">&lt;p&gt;题目（LeetCode摘抄）：&lt;br&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;br&gt;&lt;br&gt;提示：&lt;br&gt;&lt;br&gt;　　请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。&lt;br&gt;在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。&lt;br&gt;&lt;br&gt;进阶:如果多次调用这个函数，你将如何优化你的算法？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pthread_key_create</title>
    <link href="http://example.com/2021/03/26/pthread-key-create/"/>
    <id>http://example.com/2021/03/26/pthread-key-create/</id>
    <published>2021-03-26T09:24:18.000Z</published>
    <updated>2021-03-28T23:01:32.709Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在工作中重新深入认识了一个函数pthread_key_create。深入挖掘该函数源码，才发现这就是java中的ThreadLocal。&lt;br&gt;&lt;br&gt;其实这就是线程本地变量的概念。因为在多线程的程序中，线程是共享程序中的全局变量的。而对于线程本地变量，每一个变量是拥有该全局变量的一个副本，各线程对该变量的修改是线程内可见，线程间不影响。&lt;/p&gt;
&lt;h3 id=&quot;pthread-key-create&quot;&gt;&lt;a href=&quot;#pthread-key-create&quot; class=&quot;headerlink&quot; title=&quot;pthread_key_create&quot;&gt;&lt;/a&gt;pthread_key_create&lt;/h3&gt;&lt;p&gt;函数声明：&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int pthread_key_create(pthread_key_t *key, void &lt;span class=&quot;comment&quot;&gt;(*destructor)(void*)&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数1：pthread_key_t *key，pthread_key_create函数从 TSD ((Thread-specific Data) 池中分配一项，将其地址值赋给 key 供以后访问使用。&lt;br&gt;&lt;br&gt;参数2：是一个清理函数，用来在线程退出(调用 pthread_exit() 函数)时将以 key 锁关联的数据作为参数调用它，以释放分配的缓冲区，或是关闭文件流等。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。该函数成功返回0.其他任何返回值都表示出现了错误。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="linux、线程" scheme="http://example.com/tags/linux%E3%80%81%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ概念入门</title>
    <link href="http://example.com/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/"/>
    <id>http://example.com/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/</id>
    <published>2021-03-26T03:11:00.000Z</published>
    <updated>2021-03-26T10:17:19.175Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在代码评审的过程中，接触到了一个新的之前没接触过的通信框架——ZeroMQ。所以打算借助代码评审的过程对该框架进行学习，并写些博客作为心得笔记。&lt;/p&gt;
&lt;h3 id=&quot;什么是ZeroMQ&quot;&gt;&lt;a href=&quot;#什么是ZeroMQ&quot; class=&quot;headerlink&quot; title=&quot;什么是ZeroMQ&quot;&gt;&lt;/a&gt;什么是ZeroMQ&lt;/h3&gt;&lt;p&gt;ZeroMQ是一个用于分布式或者并发环境下的高性能的异步通信框架。它支持在多种协议上进行消息传递，比如TCP、进程内、进程间、组播以及socket通信等。&lt;br&gt;&lt;br&gt;Zero支持的通信模型有：发布订阅、请求响应、推拉模式以及Router/Dealer模式等。ZeroMQ支持多种语言，比如C、C++、Java、Python等。&lt;/p&gt;</summary>
    
    
    
    <category term="网络通信、消息队列" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="C++、 Java" scheme="http://example.com/tags/C-%E3%80%81-Java/"/>
    
  </entry>
  
  <entry>
    <title>Paxos</title>
    <link href="http://example.com/2021/03/26/Paxos%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/03/26/Paxos%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-03-26T03:01:49.000Z</published>
    <updated>2021-03-26T03:01:49.119Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>binlog与redolog</title>
    <link href="http://example.com/2021/03/26/binlog%E4%B8%8Eredolog/"/>
    <id>http://example.com/2021/03/26/binlog%E4%B8%8Eredolog/</id>
    <published>2021-03-26T01:31:52.000Z</published>
    <updated>2021-03-29T00:04:06.505Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;日志是Mysql数据库的重要组成部分，记录着数据库运行期间各种状态信息。Mysql的日志系统主要有错误日志、查询日志、慢查询日志、事务日志（redolog和undolog）、二进制日志（binlog）几大类。&lt;br&gt;&lt;br&gt;其中：事务日志是InnoDB存储引擎层的日志，而二</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>序列化之大端小端序</title>
    <link href="http://example.com/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F/"/>
    <id>http://example.com/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F/</id>
    <published>2021-03-25T07:48:04.000Z</published>
    <updated>2021-03-25T13:11:13.488Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cmake使用笔记</title>
    <link href="http://example.com/2021/03/25/Cmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/25/Cmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-25T01:58:13.000Z</published>
    <updated>2021-03-25T01:58:13.601Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis的主从复制</title>
    <link href="http://example.com/2021/03/24/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2021/03/24/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-03-24T13:56:36.000Z</published>
    <updated>2021-03-25T14:13:59.998Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;主从复制就是将一台服务器的数据复制到一个或者多个其他服务器中。一般与读写分离一起使用的，以为了提高数据库的高可用高并发性。&lt;br&gt;很多主流的数据库，消息中间件等都支持主从复制，比如：Mysql、Redis、RocketMq，Kafka等。&lt;/p&gt;
</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内存溢出</title>
    <link href="http://example.com/2021/03/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/03/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2021-03-24T13:52:55.000Z</published>
    <updated>2021-03-24T13:52:55.862Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>断言Assert</title>
    <link href="http://example.com/2021/03/24/%E6%96%AD%E8%A8%80Assert/"/>
    <id>http://example.com/2021/03/24/%E6%96%AD%E8%A8%80Assert/</id>
    <published>2021-03-24T03:19:18.000Z</published>
    <updated>2021-03-24T13:43:44.957Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="java、C++" scheme="http://example.com/categories/java%E3%80%81C/"/>
    
    
  </entry>
  
  <entry>
    <title>java.nio.bytebuffer解析</title>
    <link href="http://example.com/2021/03/23/java-nio-bytebuffer%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/03/23/java-nio-bytebuffer%E8%A7%A3%E6%9E%90/</id>
    <published>2021-03-23T11:52:37.000Z</published>
    <updated>2021-03-23T13:51:32.412Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;ByteBuffer继承自抽象类Buffer，用于在堆内存中预留一部分空间对IO数据做临时存储，以提高读写效率。与CharBuffer、IntBuffer等Buffer的其他子类的&lt;br&gt;区别在于数据类型的不同，但是关于缓冲区读写区域的管理全部由父类Buffer负责。&lt;br</summary>
        
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="网络通信" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ解析二</title>
    <link href="http://example.com/2021/03/23/RocketMQ%E8%A7%A3%E6%9E%90%E4%BA%8C/"/>
    <id>http://example.com/2021/03/23/RocketMQ%E8%A7%A3%E6%9E%90%E4%BA%8C/</id>
    <published>2021-03-23T03:24:53.000Z</published>
    <updated>2021-03-23T03:36:06.556Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>进程创建与退出</title>
    <link href="http://example.com/2021/03/22/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BA/"/>
    <id>http://example.com/2021/03/22/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BA/</id>
    <published>2021-03-22T08:49:20.000Z</published>
    <updated>2021-03-22T15:13:13.898Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++学习之__attribute__机制</title>
    <link href="http://example.com/2021/03/17/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B-attribute/"/>
    <id>http://example.com/2021/03/17/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B-attribute/</id>
    <published>2021-03-17T07:24:08.000Z</published>
    <updated>2021-03-17T13:48:39.885Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;__attribute__是GNU C特色之一，可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.&lt;/p&gt;
&lt;p&gt;语法格式： __attribute</summary>
        
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ源码解析之RemotingCommand</title>
    <link href="http://example.com/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/"/>
    <id>http://example.com/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/</id>
    <published>2021-03-11T04:08:28.000Z</published>
    <updated>2021-03-24T03:16:25.678Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;rocketmq-remoting模块是RocketMQ消息队列中负责网络通信的模块，底层框架是依赖于Netty的。&lt;br&gt;&lt;br&gt;为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ自定义了通信协议。&lt;/p&gt;
&lt;h1 id=&quot;通信协议及编解码方式&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>链表反转系列</title>
    <link href="http://example.com/2019/04/05/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%B3%BB%E5%88%97/"/>
    <id>http://example.com/2019/04/05/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%B3%BB%E5%88%97/</id>
    <published>2019-04-05T05:04:07.000Z</published>
    <updated>2021-03-18T05:08:36.756Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;剑指-Offer-24-反转链表&quot;&gt;&lt;a href=&quot;#剑指-Offer-24-反转链表&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 24. 反转链表&quot;&gt;&lt;/a&gt;剑指 Offer 24.</summary>
        
      
    
    
    
    <category term="算法题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C++之extern</title>
    <link href="http://example.com/2019/03/17/C-%E4%B9%8Bextern/"/>
    <id>http://example.com/2019/03/17/C-%E4%B9%8Bextern/</id>
    <published>2019-03-17T13:58:38.000Z</published>
    <updated>2021-03-18T13:22:45.238Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。&lt;br&gt;此外extern也可用来进行链接指定。&lt;/p&gt;
&lt;h1 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM类加载机制</title>
    <link href="http://example.com/2018/03/24/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2018/03/24/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2018-03-24T13:47:18.000Z</published>
    <updated>2021-03-25T05:34:09.536Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;一个.java文件从编码完成到最终执行，一般主要包括两个过程：编译和运行，其中编译就是通过javac编译器将.java文件转换成编译成字节码.class文件；然后运行则是把.class文件交给JVM执行的过程。&lt;br&gt;一个Java类从字节代码到能够在JVM中被使用，需要经过</summary>
        
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
