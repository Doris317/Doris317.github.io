<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Doris的搬砖日记</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-09T12:24:36.201Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Doris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据结构之List_2-ziplist</title>
    <link href="http://example.com/2021/04/09/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BList-2-ziplist/"/>
    <id>http://example.com/2021/04/09/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BList-2-ziplist/</id>
    <published>2021-04-09T03:47:17.000Z</published>
    <updated>2021-04-09T12:24:36.201Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Redis的底层包含9种基本数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String：&lt;/li&gt;
&lt;li&gt;List:</summary>
        
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构之List_1-adlist</title>
    <link href="http://example.com/2021/04/08/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BList_1-adlist/"/>
    <id>http://example.com/2021/04/08/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BList_1-adlist/</id>
    <published>2021-04-08T13:07:53.000Z</published>
    <updated>2021-04-09T03:50:59.480Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Redis的底层包含9种基本数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String：&lt;/li&gt;
&lt;li&gt;List: 列表对象的编码可以是ziplist或者linkedlist。&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;Sorted Set&lt;/li&gt;
&lt;li&gt;bitmap&lt;/li&gt;
&lt;li&gt;GeoHash&lt;/li&gt;
&lt;li&gt;HyperLogLog&lt;/li&gt;
&lt;li&gt;Streams&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文侧重从源码的角度分析下List的底层数据结构之一——adlist.c。&lt;/p&gt;
&lt;h3 id=&quot;什么是adlist？&quot;&gt;&lt;a href=&quot;#什么是adlist？&quot; class=&quot;headerlink&quot; title=&quot;什么是adlist？&quot;&gt;&lt;/a&gt;什么是adlist？&lt;/h3&gt;&lt;p&gt;adlist是 redis 自定义的一种双向链表，3.0及以前运用于list结构中，在3.2以后被quicklist取代。&lt;/p&gt;
&lt;h3 id=&quot;adlist的数据结构&quot;&gt;&lt;a href=&quot;#adlist的数据结构&quot; class=&quot;headerlink&quot; title=&quot;adlist的数据结构&quot;&gt;&lt;/a&gt;adlist的数据结构&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct listNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    struct listNode *prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    struct listNode *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; listNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 双向迭代器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct listIter &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listNode *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int direction;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; listIter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct list &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listNode *head; &amp;#x2F;&amp;#x2F; 头节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listNode *tail; &amp;#x2F;&amp;#x2F; 尾节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;&amp;#x2F; 方法指针，外部设入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *(*dup)(void *ptr); &amp;#x2F;&amp;#x2F; 复制节点的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void (*free)(void *ptr); &amp;#x2F;&amp;#x2F; 释放节点的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int (*match)(void *ptr, void *key); &amp;#x2F;&amp;#x2F; 比较ptr与key是否相同的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned long len; &amp;#x2F;&amp;#x2F; 链表长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; list;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode153之寻找旋转排序数组中的最小值</title>
    <link href="http://example.com/2021/04/08/LeetCode%E4%B9%8B%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://example.com/2021/04/08/LeetCode%E4%B9%8B%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2021-04-08T12:15:51.000Z</published>
    <updated>2021-04-08T13:04:44.999Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;LeetCode153-寻找旋转排序数组中的最小值&quot;&gt;&lt;a href=&quot;#LeetCode153-寻找旋转排序数组中的最小值&quot; class=&quot;headerlink&quot; title=&quot;LeetCode153. 寻找旋转排序数组中的最小值&quot;&gt;&lt;/a&gt;LeetCode153. 寻找旋转排序数组中的最小值&lt;/h3&gt;&lt;p&gt;题目：&lt;br&gt;&lt;br&gt;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&lt;br&gt;&lt;br&gt;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]&lt;br&gt;&lt;br&gt;若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]&lt;br&gt;&lt;br&gt;注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]]。&lt;br&gt;&lt;br&gt;给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode之搜索旋转排序数组I&amp;II</title>
    <link href="http://example.com/2021/04/07/LeetCode%E4%B9%8B%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84I&amp;II/"/>
    <id>http://example.com/2021/04/07/LeetCode%E4%B9%8B%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84I&amp;II/</id>
    <published>2021-04-07T12:22:08.000Z</published>
    <updated>2021-04-08T13:04:59.193Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;LeetCode33-搜索旋转排序数组I&quot;&gt;&lt;a href=&quot;#LeetCode33-搜索旋转排序数组I&quot; class=&quot;headerlink&quot; title=&quot;LeetCode33 搜索旋转排序数组I&quot;&gt;&lt;/a&gt;LeetCode33 搜索旋转排序数组I&lt;/h3&gt;&lt;p&gt;题目：&lt;br&gt;&lt;br&gt;　　整数数组 nums 按升序排列，数组中的值互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。&lt;br&gt;给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums &amp;#x3D; [4,5,6,7,0,1,2], target &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>功能安全ISO26262-4</title>
    <link href="http://example.com/2021/04/06/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8ISO26262-4/"/>
    <id>http://example.com/2021/04/06/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8ISO26262-4/</id>
    <published>2021-04-06T07:26:34.000Z</published>
    <updated>2021-04-06T11:21:38.486Z</updated>
    
    
    <summary type="html">&lt;p&gt;Part 4: Product development at the system level&lt;br&gt;本文件由技术委员会ISO/TC22、道路车辆小组委员会、SC32、电气和电子元件以及一般系统方面编写。&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;ISO26262系列标准改编IEC61508系列标准，以满足道路车辆内电气和/或电子（E/E）系统的行业特定需求。&lt;br&gt;此改编功能适用于由电气、电子和软件组件组成的安全相关系统的安全生命周期内的所有活动。&lt;br&gt;安全是道路车辆发展中的关键问题之一。汽车功能的开发和集成加强了对功能安全的需求和提供满足功能安全目标的证据的需求。&lt;br&gt;&lt;br&gt;随着技术复杂性、软件内容和机电实现的增长趋势，系统故障和随机硬件故障的风险不断增加，这些风险被考虑在功能安全范围内。ISO26262系列标准包括:通过提供适当的要求和流程来降低这些风险的指导。&lt;br&gt;&lt;br&gt;为了达到功能安全的目的，ISO26262系列标准：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为汽车安全生命周期提供参考，并支持在生命周期阶段要开展的活动的定制化，即开发、生产、运营、服务和退役；&lt;/li&gt;
&lt;li&gt;提供基于汽车特定风险来确定完整性等级的方法（ASILS）；&lt;/li&gt;
&lt;li&gt;使用ASILS指定使用ISO26262哪些要求适用于避免不合理的剩余风险；&lt;/li&gt;
&lt;li&gt;为功能安全管理、设计、实现、检验、验证和确认措施提供要求；&lt;/li&gt;
&lt;li&gt;为客户和供应商间的关系提供要求。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="功能安全" scheme="http://example.com/categories/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Road vehicles — Functional safety" scheme="http://example.com/tags/Road-vehicles-%E2%80%94-Functional-safety/"/>
    
  </entry>
  
  <entry>
    <title>算法之递归</title>
    <link href="http://example.com/2021/04/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>http://example.com/2021/04/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</id>
    <published>2021-04-02T01:12:39.000Z</published>
    <updated>2021-04-06T06:26:26.419Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是递归？&quot;&gt;&lt;a href=&quot;#什么是递归？&quot; class=&quot;headerlink&quot; title=&quot;什么是递归？&quot;&gt;&lt;/a&gt;什么是递归？&lt;/h4&gt;&lt;p&gt;用我弟弟最爱挂在嘴边哄孩子的一个故事来阐述下什么是递归吧：&lt;br&gt;从前有座山，&lt;br&gt;山里有座庙，&lt;br&gt;庙里有个老和尚，&lt;br&gt;老和尚给小和尚讲故事：&lt;br&gt;从前有座山，&lt;br&gt;山里有座庙&lt;br&gt;…&lt;br&gt;(其实我每次听我弟讲这个故事的时候，我就想拿小锤锤揍他…）。&lt;br&gt;这个故事阐述了一种递归的特性，就是&lt;code&gt;不停的自我调用&lt;/code&gt;。与递归算法唯一的不同点就是该故事是没有结尾的，是一个死循环。 所以我们总结以下什么是递归算法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;递归算法的设计要素&quot;&gt;&lt;a href=&quot;#递归算法的设计要素&quot; class=&quot;headerlink&quot; title=&quot;递归算法的设计要素&quot;&gt;&lt;/a&gt;递归算法的设计要素&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;明确递归终止条件（不然就像上面的故事一样，死循环）&lt;/li&gt;
&lt;li&gt;给出递归终止时的处理办法；&lt;/li&gt;
&lt;li&gt;提取重复的逻辑，缩小问题规模。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>snprintf与sprintf</title>
    <link href="http://example.com/2021/04/01/snprintf%E4%B8%8Esprintf/"/>
    <id>http://example.com/2021/04/01/snprintf%E4%B8%8Esprintf/</id>
    <published>2021-04-01T07:18:22.000Z</published>
    <updated>2021-04-06T12:59:49.540Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;snprintf&quot;&gt;&lt;a href=&quot;#snprintf&quot; class=&quot;headerlink&quot; title=&quot;snprintf&quot;&gt;&lt;/a&gt;snprintf&lt;/h3&gt;&lt;p&gt;原型： &lt;code&gt; int snprintf(char *str, int n, char * format [, argument, ...]);&lt;/code&gt;&lt;br&gt;参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;str – 目标字符串。&lt;/li&gt;
&lt;li&gt;n – 拷贝字节数(Bytes)。&lt;/li&gt;
&lt;li&gt;format – 格式化成字符串。&lt;/li&gt;
&lt;li&gt;… – 可变参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数功能：将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，n 为要写入的字符的最大数目，超过 size 会被截断：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果格式化后的字符串长度小于等于 n，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0；&lt;/li&gt;
&lt;li&gt;如果格式化后的字符串长度大于 n，超过 n 的部分会被截断，只将其中的 (n-1) 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>sysconf操作</title>
    <link href="http://example.com/2021/04/01/sysconf%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/04/01/sysconf%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-01T06:48:27.000Z</published>
    <updated>2021-04-06T13:19:27.350Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在学习redis的源码过程中认识了一个系统函数sysconf()，因为对其知之甚少，所以抽点时间来了解下该函数的原理以及作用。&lt;/p&gt;
&lt;h3 id=&quot;什么是sysconf函数&quot;&gt;&lt;a href=&quot;#什么是sysconf函数&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>位操作</title>
    <link href="http://example.com/2021/04/01/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/04/01/%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-01T04:49:02.000Z</published>
    <updated>2021-04-06T13:54:21.704Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;基本的位操作&quot;&gt;&lt;a href=&quot;#基本的位操作&quot; class=&quot;headerlink&quot; title=&quot;基本的位操作&quot;&gt;&lt;/a&gt;基本的位操作&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;与：&amp;amp; 每一位进行比较，两位都为1，结果为1，否则为0。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  1 0 1 1 1 --&amp;gt;(23)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;amp; 1 1 0 0 1 --&amp;gt;(25)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 0 0 0 1 --&amp;gt;(17)[10]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或：| 每一位进行比较，两位有一位是1，结果就是1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  1 0 1 1 1 --&amp;gt;(23)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 1 1 0 0 1 --&amp;gt;(25)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 1 1 1 1 --&amp;gt;(31)[10]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis内存分配_zmalloc</title>
    <link href="http://example.com/2021/04/01/Redis%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-zmalloc/"/>
    <id>http://example.com/2021/04/01/Redis%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-zmalloc/</id>
    <published>2021-04-01T03:28:11.000Z</published>
    <updated>2021-04-01T09:03:16.016Z</updated>
    
    
    <summary type="html">&lt;p&gt;zmalloc是一个对内存分配进行简单封装的库。&lt;/p&gt;
&lt;h3 id=&quot;分配器&quot;&gt;&lt;a href=&quot;#分配器&quot; class=&quot;headerlink&quot; title=&quot;分配器&quot;&gt;&lt;/a&gt;分配器&lt;/h3&gt;&lt;p&gt;从zmalloc.h文件中可以看到如下的宏定义：可以看到redis的内存分配根据不同的宏定义分别是对不同的库：google的tcmalloc、jemalloc以及libc的malloc进行了封装。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(USE_TCMALLOC)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZMALLOC_LIB (&lt;span class=&quot;meta-string&quot;&gt;&amp;quot;tcmalloc-&amp;quot;&lt;/span&gt; __xstr(TC_VERSION_MAJOR) &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt; __xstr(TC_VERSION_MINOR))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;google/tcmalloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; (TC_VERSION_MAJOR == 1 &amp;amp;&amp;amp; TC_VERSION_MINOR &amp;gt;= 6) || (TC_VERSION_MAJOR &amp;gt; 1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) tc_malloc_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;Newer version of tcmalloc required&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt; defined(USE_JEMALLOC)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZMALLOC_LIB (&lt;span class=&quot;meta-string&quot;&gt;&amp;quot;jemalloc-&amp;quot;&lt;/span&gt; __xstr(JEMALLOC_VERSION_MAJOR) &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt; __xstr(JEMALLOC_VERSION_MINOR) &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt; __xstr(JEMALLOC_VERSION_BUGFIX))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;jemalloc/jemalloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; (JEMALLOC_VERSION_MAJOR == 2 &amp;amp;&amp;amp; JEMALLOC_VERSION_MINOR &amp;gt;= 1) || (JEMALLOC_VERSION_MAJOR &amp;gt; 2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) je_malloc_usable_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;Newer version of jemalloc required&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt; defined(__APPLE__)  操作系統提供的宏，如果打开就可以提供一个 malloc_size ()，用于查看指针指向内存的大小，该函数是libc不提供的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;malloc/malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) malloc_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt; ZMALLOC_LIB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZMALLOC_LIB &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;libc&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; __GLIBC__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) malloc_usable_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(USE_JEMALLOC) &amp;amp;&amp;amp; defined(JEMALLOC_FRAG_HINT)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_DEFRAG&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;tcmalloc：由google用于优化C++多线程应用而开发。Redis 需要1.6以上的版本。&lt;/li&gt;
&lt;li&gt;jemalloc：第一次用在FreeBSD 的allocator，于2005年释出的版本。强调降低碎片化，可扩展的并行支持。Redis需要2.1以上版本。&lt;/li&gt;
&lt;li&gt;libc：最常使用的libc库。GNU libc，默认使用此allocator。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java内存结构与Java对象的内存布局</title>
    <link href="http://example.com/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2021-04-01T02:22:38.000Z</published>
    <updated>2021-04-06T07:24:04.452Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天跟老大讨论C++的char*与char[]的内存大小的计算方式，引申出指针和对象的问题，也就顺便扯到了java没有指针只有对象的特性。&lt;br&gt;既然扯到了java的对象，那么我就来扯一扯java的内存结构以及java对象在内存中的布局。&lt;/p&gt;
&lt;h3 id=&quot;java的内存结构&quot;&gt;&lt;a href=&quot;#java的内存结构&quot; class=&quot;headerlink&quot; title=&quot;java的内存结构&quot;&gt;&lt;/a&gt;java的内存结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png&quot; alt=&quot;JVM内存结构.png&quot;&gt;&lt;br&gt;JVM的运行时数据区主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中程序计数器，虚拟机栈，本地方法栈是线程私有的；而堆和方法区属于线程共享区域。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM原理" scheme="http://example.com/categories/JVM%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="http://example.com/2021/04/01/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2021/04/01/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-04-01T01:30:35.000Z</published>
    <updated>2021-04-01T02:17:17.994Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;昨儿评审公司项目的某通信模块的设计，本次评审的着重点在于序列化的设计，因此结束后趁热打铁的总结下序列化与反序列化。&lt;/p&gt;
&lt;h3 id=&quot;什么是序列化以及为什么要学序列化&quot;&gt;&lt;a href=&quot;#什么是序列化以及为什么要学序列化&quot; class=&quot;headerlink&quot; title=&quot;什么是序列化以及为什么要学序列化&quot;&gt;&lt;/a&gt;什么是序列化以及为什么要学序列化&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;序列化：&lt;/strong&gt; 将对象转换成二进制数据的过程&lt;br&gt;&lt;br&gt;&lt;strong&gt;反序列化：&lt;/strong&gt; 把字节序列还原为对象的过程&lt;/p&gt;
&lt;p&gt;序列化最终的目的是为了对象可以跨平台存储，和进行网络传输，即IO。而支持的数据格式是字节数组，因此对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，即序列化与反序列化。&lt;/p&gt;
&lt;h3 id=&quot;常见的序列化框架&quot;&gt;&lt;a href=&quot;#常见的序列化框架&quot; class=&quot;headerlink&quot; title=&quot;常见的序列化框架&quot;&gt;&lt;/a&gt;常见的序列化框架&lt;/h3&gt;&lt;p&gt;序列化框架的核心就是设计可以将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个新的对象，来完成反序列化的协议。&lt;/p&gt;</summary>
    
    
    
    <category term="编码" scheme="http://example.com/categories/%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="RPC" scheme="http://example.com/tags/RPC/"/>
    
    <category term="编码" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++之sizeof</title>
    <link href="http://example.com/2021/03/31/Linux%E7%9A%84load-average/C++%E4%B9%8BsizeOf%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/03/31/Linux%E7%9A%84load-average/C++%E4%B9%8BsizeOf%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-31T13:26:07.000Z</published>
    <updated>2021-04-06T11:29:52.923Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在看Redis6.0的源码，发现一个出现频率还不低的C库函数，再加上自己之前的了解不够全面，于是就在复习与学习中不断总结与收获啦。&lt;br&gt;&lt;br&gt;题外话：Redis是一个存储在内存上的缓存数据库，所以会对内存的使用是抠之又抠。&lt;/p&gt;
&lt;h3 id=&quot;什么是sizeof&quot;&gt;&lt;a href=&quot;#什么是sizeof&quot; class=&quot;headerlink&quot; title=&quot;什么是sizeof&quot;&gt;&lt;/a&gt;什么是sizeof&lt;/h3&gt;&lt;p&gt;sizeof是C语言中保留的关键字，也可以认为是一种单目运算符，其作用是返回一个对象或者类型所占的内存字节数。&lt;br&gt;&lt;br&gt;MSDN上的解释为：&lt;br&gt;　　The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type (including aggregate types).&lt;br&gt;This keyword returns a value of type size_t.&lt;br&gt;　　sizeof关键字给出了变量或者类型（包含聚合类型）存储时的字节数，其返回值类型为size_t。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis数据结构之SDS</title>
    <link href="http://example.com/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/"/>
    <id>http://example.com/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</id>
    <published>2021-03-30T13:42:11.000Z</published>
    <updated>2021-03-31T13:24:56.050Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Redis的底层包含9种基本数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String：使用一种叫简单动态字符串（SDS）的数据类型来实现。&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;Sorted Set&lt;/li&gt;
&lt;li&gt;bitmap&lt;/li&gt;
&lt;li&gt;GeoHash&lt;/li&gt;
&lt;li&gt;HyperLogLog&lt;/li&gt;
&lt;li&gt;Streams&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文侧重从源码的角度分析下String的底层数据结构——sds.c。&lt;/p&gt;
&lt;h3 id=&quot;什么是sds&quot;&gt;&lt;a href=&quot;#什么是sds&quot; class=&quot;headerlink&quot; title=&quot;什么是sds&quot;&gt;&lt;/a&gt;什么是sds&lt;/h3&gt;&lt;p&gt;字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/SDS%E7%BB%93%E6%9E%84.png&quot; alt=&quot;SDS结构.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux的load_average</title>
    <link href="http://example.com/2021/03/30/Linux%E7%9A%84load-average/"/>
    <id>http://example.com/2021/03/30/Linux%E7%9A%84load-average/</id>
    <published>2021-03-30T13:03:59.000Z</published>
    <updated>2021-04-06T12:26:16.185Z</updated>
    
    
    <summary type="html">&lt;p&gt;前段时间公司项目需求要写一个负载均衡的demo。在研究负载均衡的计算条件时，不可避免地考虑到了一些linux平台的性能指标，其中就有常被用来和负载均衡load-balance混淆的平均负载load-avearge。&lt;/p&gt;
&lt;h3 id=&quot;什么是load-average？&quot;&gt;&lt;a href=&quot;#什么是load-average？&quot; class=&quot;headerlink&quot; title=&quot;什么是load average？&quot;&gt;&lt;/a&gt;什么是load average？&lt;/h3&gt;&lt;p&gt;平均负载是指cpu在一段时间内正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度的统计信息。也可以说是一段时间内活跃进程的统计信息。&lt;/p&gt;
&lt;h3 id=&quot;怎样查看linux系统当前的平均负载&quot;&gt;&lt;a href=&quot;#怎样查看linux系统当前的平均负载&quot; class=&quot;headerlink&quot; title=&quot;怎样查看linux系统当前的平均负载&quot;&gt;&lt;/a&gt;怎样查看linux系统当前的平均负载&lt;/h3&gt;&lt;p&gt;load average参数后的数值就代表系统当前的平均负载。具体的查看命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;top命令：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;VirtualBox:~$ top：最常见的命令了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top - 17:52:47 up 1 min,  1 user,  load average: 1.83, 0.63, 0.22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tasks: 191 total,   2 running, 189 sleeping,   0 stopped,   0 zombie&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%Cpu(s): 17.2 us,  1.4 sy,  0.0 ni, 80.7 id,  0.3 wa,  0.0 hi,  0.3 si,  0.0 st&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MiB Mem :   3936.0 total,   2012.7 free,    678.1 used,   1245.2 buff&amp;#x2F;cache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   3011.9 avail Mem &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式协议之2pc与3pc</title>
    <link href="http://example.com/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8B2pc%E4%B8%8E3pc/"/>
    <id>http://example.com/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8B2pc%E4%B8%8E3pc/</id>
    <published>2021-03-30T08:06:18.000Z</published>
    <updated>2021-03-30T08:06:18.815Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode74.搜索二维矩阵</title>
    <link href="http://example.com/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://example.com/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</id>
    <published>2021-03-30T01:45:28.000Z</published>
    <updated>2021-03-30T13:34:59.862Z</updated>
    
    
    <summary type="html">&lt;p&gt;题目（LeetCode摘抄）：&lt;br&gt;&lt;br&gt;　　编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = &lt;span class=&quot;string&quot;&gt;[[1,3,5,7],[10,11,16,20],[23,30,34,60]]&lt;/span&gt;, target = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例2：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = &lt;span class=&quot;string&quot;&gt;[[1,3,5,7],[10,11,16,20],[23,30,34,60]]&lt;/span&gt;, target = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;m == &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n == &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;[i].&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= m, n &amp;lt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;number&quot;&gt;104&lt;/span&gt; &amp;lt;= &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;[i][j], target &amp;lt;= &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>_builtin_expect</title>
    <link href="http://example.com/2021/03/29/builtin-expect/"/>
    <id>http://example.com/2021/03/29/builtin-expect/</id>
    <published>2021-03-29T05:46:43.000Z</published>
    <updated>2021-03-30T13:32:39.918Z</updated>
    
    
    <summary type="html">&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;今天在看项目代码的时候看到了unliekly和likely的使用，往上追溯代码的时候找到了如下的宏定义：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#if&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;defined&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;__GNUC__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;likely&lt;/span&gt;(x) &lt;span class=&quot;selector-tag&quot;&gt;__builtin_expect&lt;/span&gt;((x), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;unlikely&lt;/span&gt;(x) &lt;span class=&quot;selector-tag&quot;&gt;__builtin_expect&lt;/span&gt;((x), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于__builtin_expect因为了解的不多，于是就打算整理下笔记，认真学习下这个宏定义。&lt;/p&gt;
&lt;h5 id=&quot;builtin-expect作用&quot;&gt;&lt;a href=&quot;#builtin-expect作用&quot; class=&quot;headerlink&quot; title=&quot;__builtin_expect作用&quot;&gt;&lt;/a&gt;__builtin_expect作用&lt;/h5&gt;&lt;p&gt;该指令是由gcc引入的，其作用是允许程序员将”分支转移”的信息告诉编译器，以便编译器对代码进行优化，来减少指令跳转带来的性能下降问题。&lt;br&gt;&lt;br&gt;原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__builtin_expect(&lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;N&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表示exp==N的概率很大。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="编译优化" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ源码解析之消息存储方式</title>
    <link href="http://example.com/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2021-03-29T04:49:26.000Z</published>
    <updated>2021-03-29T06:29:52.064Z</updated>
    
    
    <summary type="html">&lt;p&gt;ZeroMQ的消息队列主要由yqueue.hpp与ypipe.hpp两个类构成。&lt;br&gt;&lt;br&gt;在yqueue中有一个重要的结构体chunk_t，他是yqueue高效的关键因素。内存的申请和释放非常浪费效率，yqueue为了避免频繁的内存操作，每次不会申请一个元素大小的内存空间，而是申请一批，这一批元素就保存在chunk_t结构体中.&lt;/p&gt;
&lt;figure class=&quot;highlight abnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct chunk_t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    T values[N]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chunk_t *prev&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chunk_t *next&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;yqueue分别用三个指针和三个游标来记录chunk以及在chunk内有效的数据的索引。&lt;/p&gt;</summary>
    
    
    
    <category term="ZeroMQ" scheme="http://example.com/categories/ZeroMQ/"/>
    
    
    <category term="消息队列， C++" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C-C/"/>
    
  </entry>
  
  <entry>
    <title>BIO与NIO和AIO三种reactor模型</title>
    <link href="http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-29T03:21:52.000Z</published>
    <updated>2021-03-29T03:21:52.743Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
