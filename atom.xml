<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Doris的搬砖日记</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-30T01:57:47.204Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Doris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode74.搜索二维矩阵</title>
    <link href="http://example.com/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://example.com/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</id>
    <published>2021-03-30T01:45:28.000Z</published>
    <updated>2021-03-30T01:57:47.204Z</updated>
    
    
    <summary type="html">&lt;p&gt;题目（LeetCode摘抄）：&lt;br&gt;&lt;br&gt;　　编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = &lt;span class=&quot;string&quot;&gt;[[1,3,5,7],[10,11,16,20],[23,30,34,60]]&lt;/span&gt;, target = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例2：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = &lt;span class=&quot;string&quot;&gt;[[1,3,5,7],[10,11,16,20],[23,30,34,60]]&lt;/span&gt;, target = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;m == &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n == &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;[i].&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= m, n &amp;lt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;number&quot;&gt;104&lt;/span&gt; &amp;lt;= &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;[i][j], target &amp;lt;= &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构，java" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8Cjava/"/>
    
  </entry>
  
  <entry>
    <title>_builtin_expect</title>
    <link href="http://example.com/2021/03/29/builtin-expect/"/>
    <id>http://example.com/2021/03/29/builtin-expect/</id>
    <published>2021-03-29T05:46:43.000Z</published>
    <updated>2021-03-29T06:10:37.903Z</updated>
    
    
    <summary type="html">&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;今天在看项目代码的时候看到了unliekly和likely的使用，往上追溯代码的时候找到了如下的宏定义：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#if&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;defined&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;__GNUC__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;likely&lt;/span&gt;(x) &lt;span class=&quot;selector-tag&quot;&gt;__builtin_expect&lt;/span&gt;((x), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;unlikely&lt;/span&gt;(x) &lt;span class=&quot;selector-tag&quot;&gt;__builtin_expect&lt;/span&gt;((x), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于__builtin_expect因为了解的不多，于是就打算整理下笔记，认真学习下这个宏定义。&lt;/p&gt;
&lt;h5 id=&quot;builtin-expect作用&quot;&gt;&lt;a href=&quot;#builtin-expect作用&quot; class=&quot;headerlink&quot; title=&quot;__builtin_expect作用&quot;&gt;&lt;/a&gt;__builtin_expect作用&lt;/h5&gt;&lt;p&gt;该指令是由gcc引入的，其作用是允许程序员将”分支转移”的信息告诉编译器，以便编译器对代码进行优化，来减少指令跳转带来的性能下降问题。&lt;br&gt;&lt;br&gt;原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__builtin_expect(&lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;N&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表示exp==N的概率很大。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="编译优化，linux" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%EF%BC%8Clinux/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ源码解析之消息存储方式</title>
    <link href="http://example.com/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2021-03-29T04:49:26.000Z</published>
    <updated>2021-03-29T06:29:52.064Z</updated>
    
    
    <summary type="html">&lt;p&gt;ZeroMQ的消息队列主要由yqueue.hpp与ypipe.hpp两个类构成。&lt;br&gt;&lt;br&gt;在yqueue中有一个重要的结构体chunk_t，他是yqueue高效的关键因素。内存的申请和释放非常浪费效率，yqueue为了避免频繁的内存操作，每次不会申请一个元素大小的内存空间，而是申请一批，这一批元素就保存在chunk_t结构体中.&lt;/p&gt;
&lt;figure class=&quot;highlight abnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct chunk_t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    T values[N]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chunk_t *prev&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chunk_t *next&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;yqueue分别用三个指针和三个游标来记录chunk以及在chunk内有效的数据的索引。&lt;/p&gt;</summary>
    
    
    
    <category term="ZeroMQ" scheme="http://example.com/categories/ZeroMQ/"/>
    
    
    <category term="消息队列， C++" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C-C/"/>
    
  </entry>
  
  <entry>
    <title>BIO与NIO和AIO三种reactor模型</title>
    <link href="http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-29T03:21:52.000Z</published>
    <updated>2021-03-29T03:21:52.743Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++11之default与delete关键字</title>
    <link href="http://example.com/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-03-29T02:14:31.000Z</published>
    <updated>2021-03-29T12:29:56.433Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在讲default与delete关键字之前，我们先了解下C++的几个特殊函数。&lt;br&gt;&lt;br&gt;C++98编译器会隐式的产生四个函数：缺省构造函数，析构函数，拷贝构造函数和拷贝赋值运算符，它们称为特殊成员函数，负责创建、初始化、销毁，或者拷贝类的对象。&lt;br&gt;在 C++11 中，除了上面四个外，特殊成员函数还有两个：移动构造函数和移动赋值算符。例：&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; ();                  &lt;span class=&quot;comment&quot;&gt;// 缺省构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~&lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; ();                 &lt;span class=&quot;comment&quot;&gt;// 析构函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; (const &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; rhs);         　 　  &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; operator=(const &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; rhs);    &lt;span class=&quot;comment&quot;&gt;// 拷贝赋值运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; (const &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp;&amp;amp; rhs);         &lt;span class=&quot;comment&quot;&gt;// 移动构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; operator=(&lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp;&amp;amp; rhs);    &lt;span class=&quot;comment&quot;&gt;// 移动赋值算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-的特殊成员函数&quot;&gt;&lt;a href=&quot;#C-的特殊成员函数&quot; class=&quot;headerlink&quot; title=&quot;C++的特殊成员函数&quot;&gt;&lt;/a&gt;C++的特殊成员函数&lt;/h3&gt;&lt;h4 id=&quot;缺省构造函数与析构函数&quot;&gt;&lt;a href=&quot;#缺省构造函数与析构函数&quot; class=&quot;headerlink&quot; title=&quot;缺省构造函数与析构函数&quot;&gt;&lt;/a&gt;缺省构造函数与析构函数&lt;/h4&gt;&lt;p&gt;缺省构造函数指不需要参数就能初始化的构造函数，包含无参和所有参数有默认值两种类型的构造函数。 一个缺省的构造函数只有在类中没有声明任何构造函数的情况下才会被编译器自动生成。&lt;br&gt;&lt;br&gt;特殊成员函数被隐式生成为public和inline，并且它们是nonvirtual，除非是在派生类中的析构函数，并且这个派生类继承自带virtual析构函数的基类。在这种情况下，派生类中，编译器生成的析构函数也是virtual。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode190.颠倒二进制位</title>
    <link href="http://example.com/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://example.com/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</id>
    <published>2021-03-29T01:22:19.000Z</published>
    <updated>2021-03-30T01:46:04.850Z</updated>
    
    
    <summary type="html">&lt;p&gt;题目（LeetCode摘抄）：&lt;br&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;br&gt;&lt;br&gt;提示：&lt;br&gt;&lt;br&gt;　　请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。&lt;br&gt;在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。&lt;br&gt;&lt;br&gt;进阶:如果多次调用这个函数，你将如何优化你的算法？&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构，java" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8Cjava/"/>
    
  </entry>
  
  <entry>
    <title>pthread_key_create</title>
    <link href="http://example.com/2021/03/26/pthread-key-create/"/>
    <id>http://example.com/2021/03/26/pthread-key-create/</id>
    <published>2021-03-26T09:24:18.000Z</published>
    <updated>2021-03-28T23:01:32.709Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在工作中重新深入认识了一个函数pthread_key_create。深入挖掘该函数源码，才发现这就是java中的ThreadLocal。&lt;br&gt;&lt;br&gt;其实这就是线程本地变量的概念。因为在多线程的程序中，线程是共享程序中的全局变量的。而对于线程本地变量，每一个变量是拥有该全局变量的一个副本，各线程对该变量的修改是线程内可见，线程间不影响。&lt;/p&gt;
&lt;h3 id=&quot;pthread-key-create&quot;&gt;&lt;a href=&quot;#pthread-key-create&quot; class=&quot;headerlink&quot; title=&quot;pthread_key_create&quot;&gt;&lt;/a&gt;pthread_key_create&lt;/h3&gt;&lt;p&gt;函数声明：&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int pthread_key_create(pthread_key_t *key, void &lt;span class=&quot;comment&quot;&gt;(*destructor)(void*)&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数1：pthread_key_t *key，pthread_key_create函数从 TSD ((Thread-specific Data) 池中分配一项，将其地址值赋给 key 供以后访问使用。&lt;br&gt;&lt;br&gt;参数2：是一个清理函数，用来在线程退出(调用 pthread_exit() 函数)时将以 key 锁关联的数据作为参数调用它，以释放分配的缓冲区，或是关闭文件流等。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。该函数成功返回0.其他任何返回值都表示出现了错误。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="linux、线程" scheme="http://example.com/tags/linux%E3%80%81%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ概念入门</title>
    <link href="http://example.com/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/"/>
    <id>http://example.com/2021/03/26/ZeroMQ%E8%A7%A3%E6%9E%90%E4%B8%80/</id>
    <published>2021-03-26T03:11:00.000Z</published>
    <updated>2021-03-26T10:17:19.175Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在代码评审的过程中，接触到了一个新的之前没接触过的通信框架——ZeroMQ。所以打算借助代码评审的过程对该框架进行学习，并写些博客作为心得笔记。&lt;/p&gt;
&lt;h3 id=&quot;什么是ZeroMQ&quot;&gt;&lt;a href=&quot;#什么是ZeroMQ&quot; class=&quot;headerlink&quot; title=&quot;什么是ZeroMQ&quot;&gt;&lt;/a&gt;什么是ZeroMQ&lt;/h3&gt;&lt;p&gt;ZeroMQ是一个用于分布式或者并发环境下的高性能的异步通信框架。它支持在多种协议上进行消息传递，比如TCP、进程内、进程间、组播以及socket通信等。&lt;br&gt;&lt;br&gt;Zero支持的通信模型有：发布订阅、请求响应、推拉模式以及Router/Dealer模式等。ZeroMQ支持多种语言，比如C、C++、Java、Python等。&lt;/p&gt;</summary>
    
    
    
    <category term="网络通信、消息队列" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="C++、 Java" scheme="http://example.com/tags/C-%E3%80%81-Java/"/>
    
  </entry>
  
  <entry>
    <title>Paxos</title>
    <link href="http://example.com/2021/03/26/Paxos%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/03/26/Paxos%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-03-26T03:01:49.000Z</published>
    <updated>2021-03-30T06:02:45.867Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Paxos is a consensus algorithm executed by a set of processes, termed replicas, to agree on a single value in the presence of failures.&lt;br&gt;&lt;br&gt;Lamport提出的Paxos算法用于解决分布式系统中一致性问题：将所有节点都写入同一个值，且被写入后不再更改。Paxos算法又分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Basic Paxos算法：描述多节点如何就某个提案Value达成共识&lt;/li&gt;
&lt;li&gt;Multi-Paxos算法：描述执行多个Basic Paxos的实例如何就一系列值达成共识。&lt;br&gt;&lt;br&gt;Paxos算法的变种有：Fast Paxos、Cheap Paxos、Raft算法等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Basic-Paxos&quot;&gt;&lt;a href=&quot;#Basic-Paxos&quot; class=&quot;headerlink&quot; title=&quot;Basic Paxos&quot;&gt;&lt;/a&gt;Basic Paxos&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;角色是Basic Paxos算法中最核心的三个功能的抽象：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;提议者Proposer&lt;/td&gt;
&lt;td&gt;提议一个用于投票表决的值，即提案Value。在大多数的分布式场景下，集群中收到客户端请求的节点会是一个Proposer。&lt;/td&gt;
&lt;td&gt;接入和协调功能：在收到客户端请求后，发起二阶段提交，进行共识协商&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;接受者Acceptor&lt;/td&gt;
&lt;td&gt;负责对每个提议的值进行投票，并存储接受的值。一般来说，集群中的所有节点都在扮演Acceptor的角色，参与共识协商并接受和存储数据。&lt;/td&gt;
&lt;td&gt;投票协商与数据存储功能：对提案Value进行投票，并接受达成共识的值，存储保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;学习者Learner&lt;/td&gt;
&lt;td&gt;被通知投票的结果，接受并存储达成共识的值，不参与投票过程。一般来说，集群中的数据备份节点，比如主从结构宏的从节点是Learner，被动接受并保存数据，进行容灾备份。&lt;/td&gt;
&lt;td&gt;数据存储功能：不参与共识协商，只进行达成共识的值接受与存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一致性协议框架中，集群中的节点可以同时承担以上多种角色。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式协议" scheme="http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="大数据、 分布式" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E3%80%81-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>binlog与redolog</title>
    <link href="http://example.com/2021/03/26/binlog%E4%B8%8Eredolog/"/>
    <id>http://example.com/2021/03/26/binlog%E4%B8%8Eredolog/</id>
    <published>2021-03-26T01:31:52.000Z</published>
    <updated>2021-03-29T12:42:26.875Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;日志是Mysql数据库的重要组成部分，记录着数据库运行期间各种状态信息。Mysql的日志系统主要有错误日志、查询日志、慢查询日志、事务日志（redolog和undolog）、二进制日志（binlog）几大类。&lt;br&gt;&lt;br&gt;其中：事务日志是InnoDB存储引擎层的日志，而二</summary>
        
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>序列化之大端小端序</title>
    <link href="http://example.com/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F/"/>
    <id>http://example.com/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F/</id>
    <published>2021-03-25T07:48:04.000Z</published>
    <updated>2021-03-25T13:11:13.488Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cmake使用笔记</title>
    <link href="http://example.com/2021/03/25/Cmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/03/25/Cmake%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-25T01:58:13.000Z</published>
    <updated>2021-03-25T01:58:13.601Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis的主从复制</title>
    <link href="http://example.com/2021/03/24/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2021/03/24/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-03-24T13:56:36.000Z</published>
    <updated>2021-03-25T14:13:59.998Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;主从复制就是将一台服务器的数据复制到一个或者多个其他服务器中。一般与读写分离一起使用的，以为了提高数据库的高可用高并发性。&lt;br&gt;很多主流的数据库，消息中间件等都支持主从复制，比如：Mysql、Redis、RocketMq，Kafka等。&lt;/p&gt;
</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内存溢出</title>
    <link href="http://example.com/2021/03/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/03/24/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2021-03-24T13:52:55.000Z</published>
    <updated>2021-03-24T13:52:55.862Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>断言Assert</title>
    <link href="http://example.com/2021/03/24/%E6%96%AD%E8%A8%80Assert/"/>
    <id>http://example.com/2021/03/24/%E6%96%AD%E8%A8%80Assert/</id>
    <published>2021-03-24T03:19:18.000Z</published>
    <updated>2021-03-24T13:43:44.957Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="java、C++" scheme="http://example.com/categories/java%E3%80%81C/"/>
    
    
  </entry>
  
  <entry>
    <title>java.nio.bytebuffer解析</title>
    <link href="http://example.com/2021/03/23/java-nio-bytebuffer%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/03/23/java-nio-bytebuffer%E8%A7%A3%E6%9E%90/</id>
    <published>2021-03-23T11:52:37.000Z</published>
    <updated>2021-03-23T13:51:32.412Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;ByteBuffer继承自抽象类Buffer，用于在堆内存中预留一部分空间对IO数据做临时存储，以提高读写效率。与CharBuffer、IntBuffer等Buffer的其他子类的&lt;br&gt;区别在于数据类型的不同，但是关于缓冲区读写区域的管理全部由父类Buffer负责。&lt;br</summary>
        
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="网络通信" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ解析二</title>
    <link href="http://example.com/2021/03/23/RocketMQ%E8%A7%A3%E6%9E%90%E4%BA%8C/"/>
    <id>http://example.com/2021/03/23/RocketMQ%E8%A7%A3%E6%9E%90%E4%BA%8C/</id>
    <published>2021-03-23T03:24:53.000Z</published>
    <updated>2021-03-23T03:36:06.556Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>进程创建与退出</title>
    <link href="http://example.com/2021/03/22/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BA/"/>
    <id>http://example.com/2021/03/22/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BA/</id>
    <published>2021-03-22T08:49:20.000Z</published>
    <updated>2021-03-29T13:27:14.482Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++学习之__attribute__机制</title>
    <link href="http://example.com/2021/03/17/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B-attribute/"/>
    <id>http://example.com/2021/03/17/C-%E5%AD%A6%E4%B9%A0%E4%B9%8B-attribute/</id>
    <published>2021-03-17T07:24:08.000Z</published>
    <updated>2021-03-17T13:48:39.885Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;__attribute__是GNU C特色之一，可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.&lt;/p&gt;
&lt;p&gt;语法格式： __attribute</summary>
        
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ源码解析之RemotingCommand</title>
    <link href="http://example.com/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/"/>
    <id>http://example.com/2021/03/11/RocketMQ%E4%B9%8BRemotingCommand/</id>
    <published>2021-03-11T04:08:28.000Z</published>
    <updated>2021-03-24T03:16:25.678Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;rocketmq-remoting模块是RocketMQ消息队列中负责网络通信的模块，底层框架是依赖于Netty的。&lt;br&gt;&lt;br&gt;为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ自定义了通信协议。&lt;/p&gt;
&lt;h1 id=&quot;通信协议及编解码方式&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
