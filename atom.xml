<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Doris的搬砖日记</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-08T12:14:16.239Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Doris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode之搜索旋转排序数组I&amp;II</title>
    <link href="http://example.com/2021/04/07/LeetCode%E4%B9%8B%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84I&amp;II/"/>
    <id>http://example.com/2021/04/07/LeetCode%E4%B9%8B%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84I&amp;II/</id>
    <published>2021-04-07T12:22:08.000Z</published>
    <updated>2021-04-08T12:14:16.239Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;LeetCode33-搜索旋转排序数组I&quot;&gt;&lt;a href=&quot;#LeetCode33-搜索旋转排序数组I&quot; class=&quot;headerlink&quot; title=&quot;LeetCode33 搜索旋转排序数组I&quot;&gt;&lt;/a&gt;LeetCode33</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>功能安全ISO26262-4</title>
    <link href="http://example.com/2021/04/06/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8ISO26262-4/"/>
    <id>http://example.com/2021/04/06/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8ISO26262-4/</id>
    <published>2021-04-06T07:26:34.000Z</published>
    <updated>2021-04-06T11:21:38.486Z</updated>
    
    
    <summary type="html">&lt;p&gt;Part 4: Product development at the system level&lt;br&gt;本文件由技术委员会ISO/TC22、道路车辆小组委员会、SC32、电气和电子元件以及一般系统方面编写。&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;ISO26262系列标准改编IEC61508系列标准，以满足道路车辆内电气和/或电子（E/E）系统的行业特定需求。&lt;br&gt;此改编功能适用于由电气、电子和软件组件组成的安全相关系统的安全生命周期内的所有活动。&lt;br&gt;安全是道路车辆发展中的关键问题之一。汽车功能的开发和集成加强了对功能安全的需求和提供满足功能安全目标的证据的需求。&lt;br&gt;&lt;br&gt;随着技术复杂性、软件内容和机电实现的增长趋势，系统故障和随机硬件故障的风险不断增加，这些风险被考虑在功能安全范围内。ISO26262系列标准包括:通过提供适当的要求和流程来降低这些风险的指导。&lt;br&gt;&lt;br&gt;为了达到功能安全的目的，ISO26262系列标准：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为汽车安全生命周期提供参考，并支持在生命周期阶段要开展的活动的定制化，即开发、生产、运营、服务和退役；&lt;/li&gt;
&lt;li&gt;提供基于汽车特定风险来确定完整性等级的方法（ASILS）；&lt;/li&gt;
&lt;li&gt;使用ASILS指定使用ISO26262哪些要求适用于避免不合理的剩余风险；&lt;/li&gt;
&lt;li&gt;为功能安全管理、设计、实现、检验、验证和确认措施提供要求；&lt;/li&gt;
&lt;li&gt;为客户和供应商间的关系提供要求。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="功能安全" scheme="http://example.com/categories/%E5%8A%9F%E8%83%BD%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Road vehicles — Functional safety" scheme="http://example.com/tags/Road-vehicles-%E2%80%94-Functional-safety/"/>
    
  </entry>
  
  <entry>
    <title>算法之递归</title>
    <link href="http://example.com/2021/04/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>http://example.com/2021/04/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</id>
    <published>2021-04-02T01:12:39.000Z</published>
    <updated>2021-04-06T06:26:26.419Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是递归？&quot;&gt;&lt;a href=&quot;#什么是递归？&quot; class=&quot;headerlink&quot; title=&quot;什么是递归？&quot;&gt;&lt;/a&gt;什么是递归？&lt;/h4&gt;&lt;p&gt;用我弟弟最爱挂在嘴边哄孩子的一个故事来阐述下什么是递归吧：&lt;br&gt;从前有座山，&lt;br&gt;山里有座庙，&lt;br&gt;庙里有个老和尚，&lt;br&gt;老和尚给小和尚讲故事：&lt;br&gt;从前有座山，&lt;br&gt;山里有座庙&lt;br&gt;…&lt;br&gt;(其实我每次听我弟讲这个故事的时候，我就想拿小锤锤揍他…）。&lt;br&gt;这个故事阐述了一种递归的特性，就是&lt;code&gt;不停的自我调用&lt;/code&gt;。与递归算法唯一的不同点就是该故事是没有结尾的，是一个死循环。 所以我们总结以下什么是递归算法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;递归算法的设计要素&quot;&gt;&lt;a href=&quot;#递归算法的设计要素&quot; class=&quot;headerlink&quot; title=&quot;递归算法的设计要素&quot;&gt;&lt;/a&gt;递归算法的设计要素&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;明确递归终止条件（不然就像上面的故事一样，死循环）&lt;/li&gt;
&lt;li&gt;给出递归终止时的处理办法；&lt;/li&gt;
&lt;li&gt;提取重复的逻辑，缩小问题规模。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>snprintf与sprintf</title>
    <link href="http://example.com/2021/04/01/snprintf%E4%B8%8Esprintf/"/>
    <id>http://example.com/2021/04/01/snprintf%E4%B8%8Esprintf/</id>
    <published>2021-04-01T07:18:22.000Z</published>
    <updated>2021-04-06T12:59:49.540Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;snprintf&quot;&gt;&lt;a href=&quot;#snprintf&quot; class=&quot;headerlink&quot; title=&quot;snprintf&quot;&gt;&lt;/a&gt;snprintf&lt;/h3&gt;&lt;p&gt;原型： &lt;code&gt; int snprintf(char *str, int n, char * format [, argument, ...]);&lt;/code&gt;&lt;br&gt;参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;str – 目标字符串。&lt;/li&gt;
&lt;li&gt;n – 拷贝字节数(Bytes)。&lt;/li&gt;
&lt;li&gt;format – 格式化成字符串。&lt;/li&gt;
&lt;li&gt;… – 可变参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数功能：将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，n 为要写入的字符的最大数目，超过 size 会被截断：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果格式化后的字符串长度小于等于 n，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0；&lt;/li&gt;
&lt;li&gt;如果格式化后的字符串长度大于 n，超过 n 的部分会被截断，只将其中的 (n-1) 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>sysconf操作</title>
    <link href="http://example.com/2021/04/01/sysconf%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/04/01/sysconf%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-01T06:48:27.000Z</published>
    <updated>2021-04-06T13:19:27.350Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在学习redis的源码过程中认识了一个系统函数sysconf()，因为对其知之甚少，所以抽点时间来了解下该函数的原理以及作用。&lt;/p&gt;
&lt;h3 id=&quot;什么是sysconf函数&quot;&gt;&lt;a href=&quot;#什么是sysconf函数&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>位操作</title>
    <link href="http://example.com/2021/04/01/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/04/01/%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-01T04:49:02.000Z</published>
    <updated>2021-04-06T13:54:21.704Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;基本的位操作&quot;&gt;&lt;a href=&quot;#基本的位操作&quot; class=&quot;headerlink&quot; title=&quot;基本的位操作&quot;&gt;&lt;/a&gt;基本的位操作&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;与：&amp;amp; 每一位进行比较，两位都为1，结果为1，否则为0。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  1 0 1 1 1 --&amp;gt;(23)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;amp; 1 1 0 0 1 --&amp;gt;(25)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 0 0 0 1 --&amp;gt;(17)[10]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或：| 每一位进行比较，两位有一位是1，结果就是1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  1 0 1 1 1 --&amp;gt;(23)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 1 1 0 0 1 --&amp;gt;(25)[10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1 1 1 1 1 --&amp;gt;(31)[10]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis内存分配_zmalloc</title>
    <link href="http://example.com/2021/04/01/Redis%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-zmalloc/"/>
    <id>http://example.com/2021/04/01/Redis%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-zmalloc/</id>
    <published>2021-04-01T03:28:11.000Z</published>
    <updated>2021-04-01T09:03:16.016Z</updated>
    
    
    <summary type="html">&lt;p&gt;zmalloc是一个对内存分配进行简单封装的库。&lt;/p&gt;
&lt;h3 id=&quot;分配器&quot;&gt;&lt;a href=&quot;#分配器&quot; class=&quot;headerlink&quot; title=&quot;分配器&quot;&gt;&lt;/a&gt;分配器&lt;/h3&gt;&lt;p&gt;从zmalloc.h文件中可以看到如下的宏定义：可以看到redis的内存分配根据不同的宏定义分别是对不同的库：google的tcmalloc、jemalloc以及libc的malloc进行了封装。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(USE_TCMALLOC)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZMALLOC_LIB (&lt;span class=&quot;meta-string&quot;&gt;&amp;quot;tcmalloc-&amp;quot;&lt;/span&gt; __xstr(TC_VERSION_MAJOR) &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt; __xstr(TC_VERSION_MINOR))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;google/tcmalloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; (TC_VERSION_MAJOR == 1 &amp;amp;&amp;amp; TC_VERSION_MINOR &amp;gt;= 6) || (TC_VERSION_MAJOR &amp;gt; 1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) tc_malloc_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;Newer version of tcmalloc required&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt; defined(USE_JEMALLOC)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZMALLOC_LIB (&lt;span class=&quot;meta-string&quot;&gt;&amp;quot;jemalloc-&amp;quot;&lt;/span&gt; __xstr(JEMALLOC_VERSION_MAJOR) &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt; __xstr(JEMALLOC_VERSION_MINOR) &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt; __xstr(JEMALLOC_VERSION_BUGFIX))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;jemalloc/jemalloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; (JEMALLOC_VERSION_MAJOR == 2 &amp;amp;&amp;amp; JEMALLOC_VERSION_MINOR &amp;gt;= 1) || (JEMALLOC_VERSION_MAJOR &amp;gt; 2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) je_malloc_usable_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;Newer version of jemalloc required&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt; defined(__APPLE__)  操作系統提供的宏，如果打开就可以提供一个 malloc_size ()，用于查看指针指向内存的大小，该函数是libc不提供的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;malloc/malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) malloc_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt; ZMALLOC_LIB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZMALLOC_LIB &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;libc&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; __GLIBC__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_MALLOC_SIZE 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; zmalloc_size(p) malloc_usable_size(p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(USE_JEMALLOC) &amp;amp;&amp;amp; defined(JEMALLOC_FRAG_HINT)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; HAVE_DEFRAG&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;tcmalloc：由google用于优化C++多线程应用而开发。Redis 需要1.6以上的版本。&lt;/li&gt;
&lt;li&gt;jemalloc：第一次用在FreeBSD 的allocator，于2005年释出的版本。强调降低碎片化，可扩展的并行支持。Redis需要2.1以上版本。&lt;/li&gt;
&lt;li&gt;libc：最常使用的libc库。GNU libc，默认使用此allocator。&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java内存结构与Java对象的内存布局</title>
    <link href="http://example.com/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2021-04-01T02:22:38.000Z</published>
    <updated>2021-04-06T07:24:04.452Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天跟老大讨论C++的char*与char[]的内存大小的计算方式，引申出指针和对象的问题，也就顺便扯到了java没有指针只有对象的特性。&lt;br&gt;既然扯到了java的对象，那么我就来扯一扯java的内存结构以及java对象在内存中的布局。&lt;/p&gt;
&lt;h3 id=&quot;java的内存结构&quot;&gt;&lt;a href=&quot;#java的内存结构&quot; class=&quot;headerlink&quot; title=&quot;java的内存结构&quot;&gt;&lt;/a&gt;java的内存结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/01/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8EJava%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png&quot; alt=&quot;JVM内存结构.png&quot;&gt;&lt;br&gt;JVM的运行时数据区主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中程序计数器，虚拟机栈，本地方法栈是线程私有的；而堆和方法区属于线程共享区域。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM原理" scheme="http://example.com/categories/JVM%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="http://example.com/2021/04/01/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2021/04/01/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-04-01T01:30:35.000Z</published>
    <updated>2021-04-01T02:17:17.994Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;昨儿评审公司项目的某通信模块的设计，本次评审的着重点在于序列化的设计，因此结束后趁热打铁的总结下序列化与反序列化。&lt;/p&gt;
&lt;h3 id=&quot;什么是序列化以及为什么要学序列化&quot;&gt;&lt;a href=&quot;#什么是序列化以及为什么要学序列化&quot; class=&quot;headerlink&quot; title=&quot;什么是序列化以及为什么要学序列化&quot;&gt;&lt;/a&gt;什么是序列化以及为什么要学序列化&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;序列化：&lt;/strong&gt; 将对象转换成二进制数据的过程&lt;br&gt;&lt;br&gt;&lt;strong&gt;反序列化：&lt;/strong&gt; 把字节序列还原为对象的过程&lt;/p&gt;
&lt;p&gt;序列化最终的目的是为了对象可以跨平台存储，和进行网络传输，即IO。而支持的数据格式是字节数组，因此对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，即序列化与反序列化。&lt;/p&gt;
&lt;h3 id=&quot;常见的序列化框架&quot;&gt;&lt;a href=&quot;#常见的序列化框架&quot; class=&quot;headerlink&quot; title=&quot;常见的序列化框架&quot;&gt;&lt;/a&gt;常见的序列化框架&lt;/h3&gt;&lt;p&gt;序列化框架的核心就是设计可以将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个新的对象，来完成反序列化的协议。&lt;/p&gt;</summary>
    
    
    
    <category term="编码" scheme="http://example.com/categories/%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="RPC" scheme="http://example.com/tags/RPC/"/>
    
    <category term="编码" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++之sizeof</title>
    <link href="http://example.com/2021/03/31/Linux%E7%9A%84load-average/C++%E4%B9%8BsizeOf%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/03/31/Linux%E7%9A%84load-average/C++%E4%B9%8BsizeOf%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-31T13:26:07.000Z</published>
    <updated>2021-04-06T11:29:52.923Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在看Redis6.0的源码，发现一个出现频率还不低的C库函数，再加上自己之前的了解不够全面，于是就在复习与学习中不断总结与收获啦。&lt;br&gt;&lt;br&gt;题外话：Redis是一个存储在内存上的缓存数据库，所以会对内存的使用是抠之又抠。&lt;/p&gt;
&lt;h3 id=&quot;什么是sizeof&quot;&gt;&lt;a href=&quot;#什么是sizeof&quot; class=&quot;headerlink&quot; title=&quot;什么是sizeof&quot;&gt;&lt;/a&gt;什么是sizeof&lt;/h3&gt;&lt;p&gt;sizeof是C语言中保留的关键字，也可以认为是一种单目运算符，其作用是返回一个对象或者类型所占的内存字节数。&lt;br&gt;&lt;br&gt;MSDN上的解释为：&lt;br&gt;　　The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type (including aggregate types).&lt;br&gt;This keyword returns a value of type size_t.&lt;br&gt;　　sizeof关键字给出了变量或者类型（包含聚合类型）存储时的字节数，其返回值类型为size_t。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis数据结构之SDS</title>
    <link href="http://example.com/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/"/>
    <id>http://example.com/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</id>
    <published>2021-03-30T13:42:11.000Z</published>
    <updated>2021-03-31T13:24:56.050Z</updated>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Redis的底层包含9种基本数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String：使用一种叫简单动态字符串（SDS）的数据类型来实现。&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;Sorted Set&lt;/li&gt;
&lt;li&gt;bitmap&lt;/li&gt;
&lt;li&gt;GeoHash&lt;/li&gt;
&lt;li&gt;HyperLogLog&lt;/li&gt;
&lt;li&gt;Streams&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文侧重从源码的角度分析下String的底层数据结构——sds.c。&lt;/p&gt;
&lt;h3 id=&quot;什么是sds&quot;&gt;&lt;a href=&quot;#什么是sds&quot; class=&quot;headerlink&quot; title=&quot;什么是sds&quot;&gt;&lt;/a&gt;什么是sds&lt;/h3&gt;&lt;p&gt;字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/03/30/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/SDS%E7%BB%93%E6%9E%84.png&quot; alt=&quot;SDS结构.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux的load_average</title>
    <link href="http://example.com/2021/03/30/Linux%E7%9A%84load-average/"/>
    <id>http://example.com/2021/03/30/Linux%E7%9A%84load-average/</id>
    <published>2021-03-30T13:03:59.000Z</published>
    <updated>2021-04-06T12:26:16.185Z</updated>
    
    
    <summary type="html">&lt;p&gt;前段时间公司项目需求要写一个负载均衡的demo。在研究负载均衡的计算条件时，不可避免地考虑到了一些linux平台的性能指标，其中就有常被用来和负载均衡load-balance混淆的平均负载load-avearge。&lt;/p&gt;
&lt;h3 id=&quot;什么是load-average？&quot;&gt;&lt;a href=&quot;#什么是load-average？&quot; class=&quot;headerlink&quot; title=&quot;什么是load average？&quot;&gt;&lt;/a&gt;什么是load average？&lt;/h3&gt;&lt;p&gt;平均负载是指cpu在一段时间内正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度的统计信息。也可以说是一段时间内活跃进程的统计信息。&lt;/p&gt;
&lt;h3 id=&quot;怎样查看linux系统当前的平均负载&quot;&gt;&lt;a href=&quot;#怎样查看linux系统当前的平均负载&quot; class=&quot;headerlink&quot; title=&quot;怎样查看linux系统当前的平均负载&quot;&gt;&lt;/a&gt;怎样查看linux系统当前的平均负载&lt;/h3&gt;&lt;p&gt;load average参数后的数值就代表系统当前的平均负载。具体的查看命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;top命令：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;VirtualBox:~$ top：最常见的命令了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;top - 17:52:47 up 1 min,  1 user,  load average: 1.83, 0.63, 0.22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Tasks: 191 total,   2 running, 189 sleeping,   0 stopped,   0 zombie&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%Cpu(s): 17.2 us,  1.4 sy,  0.0 ni, 80.7 id,  0.3 wa,  0.0 hi,  0.3 si,  0.0 st&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MiB Mem :   3936.0 total,   2012.7 free,    678.1 used,   1245.2 buff&amp;#x2F;cache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   3011.9 avail Mem &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式协议之2pc与3pc</title>
    <link href="http://example.com/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8B2pc%E4%B8%8E3pc/"/>
    <id>http://example.com/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B9%8B2pc%E4%B8%8E3pc/</id>
    <published>2021-03-30T08:06:18.000Z</published>
    <updated>2021-03-30T08:06:18.815Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode74.搜索二维矩阵</title>
    <link href="http://example.com/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://example.com/2021/03/30/LeetCode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</id>
    <published>2021-03-30T01:45:28.000Z</published>
    <updated>2021-03-30T13:34:59.862Z</updated>
    
    
    <summary type="html">&lt;p&gt;题目（LeetCode摘抄）：&lt;br&gt;&lt;br&gt;　　编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = &lt;span class=&quot;string&quot;&gt;[[1,3,5,7],[10,11,16,20],[23,30,34,60]]&lt;/span&gt;, target = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例2：&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = &lt;span class=&quot;string&quot;&gt;[[1,3,5,7],[10,11,16,20],[23,30,34,60]]&lt;/span&gt;, target = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;m == &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n == &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;[i].&lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= m, n &amp;lt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;number&quot;&gt;104&lt;/span&gt; &amp;lt;= &lt;span class=&quot;built_in&quot;&gt;matrix&lt;/span&gt;[i][j], target &amp;lt;= &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>_builtin_expect</title>
    <link href="http://example.com/2021/03/29/builtin-expect/"/>
    <id>http://example.com/2021/03/29/builtin-expect/</id>
    <published>2021-03-29T05:46:43.000Z</published>
    <updated>2021-03-30T13:32:39.918Z</updated>
    
    
    <summary type="html">&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;今天在看项目代码的时候看到了unliekly和likely的使用，往上追溯代码的时候找到了如下的宏定义：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#if&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;defined&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;__GNUC__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;likely&lt;/span&gt;(x) &lt;span class=&quot;selector-tag&quot;&gt;__builtin_expect&lt;/span&gt;((x), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;unlikely&lt;/span&gt;(x) &lt;span class=&quot;selector-tag&quot;&gt;__builtin_expect&lt;/span&gt;((x), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于__builtin_expect因为了解的不多，于是就打算整理下笔记，认真学习下这个宏定义。&lt;/p&gt;
&lt;h5 id=&quot;builtin-expect作用&quot;&gt;&lt;a href=&quot;#builtin-expect作用&quot; class=&quot;headerlink&quot; title=&quot;__builtin_expect作用&quot;&gt;&lt;/a&gt;__builtin_expect作用&lt;/h5&gt;&lt;p&gt;该指令是由gcc引入的，其作用是允许程序员将”分支转移”的信息告诉编译器，以便编译器对代码进行优化，来减少指令跳转带来的性能下降问题。&lt;br&gt;&lt;br&gt;原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__builtin_expect(&lt;span class=&quot;built_in&quot;&gt;exp&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;N&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表示exp==N的概率很大。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="编译优化" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ZeroMQ源码解析之消息存储方式</title>
    <link href="http://example.com/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/03/29/ZeroMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2021-03-29T04:49:26.000Z</published>
    <updated>2021-03-29T06:29:52.064Z</updated>
    
    
    <summary type="html">&lt;p&gt;ZeroMQ的消息队列主要由yqueue.hpp与ypipe.hpp两个类构成。&lt;br&gt;&lt;br&gt;在yqueue中有一个重要的结构体chunk_t，他是yqueue高效的关键因素。内存的申请和释放非常浪费效率，yqueue为了避免频繁的内存操作，每次不会申请一个元素大小的内存空间，而是申请一批，这一批元素就保存在chunk_t结构体中.&lt;/p&gt;
&lt;figure class=&quot;highlight abnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct chunk_t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    T values[N]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chunk_t *prev&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chunk_t *next&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;yqueue分别用三个指针和三个游标来记录chunk以及在chunk内有效的数据的索引。&lt;/p&gt;</summary>
    
    
    
    <category term="ZeroMQ" scheme="http://example.com/categories/ZeroMQ/"/>
    
    
    <category term="消息队列， C++" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C-C/"/>
    
  </entry>
  
  <entry>
    <title>BIO与NIO和AIO三种reactor模型</title>
    <link href="http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/03/29/BIO%E4%B8%8ENIO%E5%92%8CAIO%E4%B8%89%E7%A7%8Dreactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-29T03:21:52.000Z</published>
    <updated>2021-03-29T03:21:52.743Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++11之default与delete关键字</title>
    <link href="http://example.com/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2021/03/29/C-11%E4%B9%8Bdefault%E4%B8%8Edelete%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-03-29T02:14:31.000Z</published>
    <updated>2021-03-29T12:29:56.433Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在讲default与delete关键字之前，我们先了解下C++的几个特殊函数。&lt;br&gt;&lt;br&gt;C++98编译器会隐式的产生四个函数：缺省构造函数，析构函数，拷贝构造函数和拷贝赋值运算符，它们称为特殊成员函数，负责创建、初始化、销毁，或者拷贝类的对象。&lt;br&gt;在 C++11 中，除了上面四个外，特殊成员函数还有两个：移动构造函数和移动赋值算符。例：&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; ();                  &lt;span class=&quot;comment&quot;&gt;// 缺省构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~&lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; ();                 &lt;span class=&quot;comment&quot;&gt;// 析构函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; (const &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; rhs);         　 　  &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; operator=(const &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; rhs);    &lt;span class=&quot;comment&quot;&gt;// 拷贝赋值运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; (const &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp;&amp;amp; rhs);         &lt;span class=&quot;comment&quot;&gt;// 移动构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp; operator=(&lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; &amp;amp;&amp;amp; rhs);    &lt;span class=&quot;comment&quot;&gt;// 移动赋值算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-的特殊成员函数&quot;&gt;&lt;a href=&quot;#C-的特殊成员函数&quot; class=&quot;headerlink&quot; title=&quot;C++的特殊成员函数&quot;&gt;&lt;/a&gt;C++的特殊成员函数&lt;/h3&gt;&lt;h4 id=&quot;缺省构造函数与析构函数&quot;&gt;&lt;a href=&quot;#缺省构造函数与析构函数&quot; class=&quot;headerlink&quot; title=&quot;缺省构造函数与析构函数&quot;&gt;&lt;/a&gt;缺省构造函数与析构函数&lt;/h4&gt;&lt;p&gt;缺省构造函数指不需要参数就能初始化的构造函数，包含无参和所有参数有默认值两种类型的构造函数。 一个缺省的构造函数只有在类中没有声明任何构造函数的情况下才会被编译器自动生成。&lt;br&gt;&lt;br&gt;特殊成员函数被隐式生成为public和inline，并且它们是nonvirtual，除非是在派生类中的析构函数，并且这个派生类继承自带virtual析构函数的基类。在这种情况下，派生类中，编译器生成的析构函数也是virtual。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode190.颠倒二进制位</title>
    <link href="http://example.com/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://example.com/2021/03/29/LeetCode190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</id>
    <published>2021-03-29T01:22:19.000Z</published>
    <updated>2021-03-30T13:34:59.884Z</updated>
    
    
    <summary type="html">&lt;p&gt;题目（LeetCode摘抄）：&lt;br&gt;&lt;br&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;br&gt;&lt;br&gt;提示：&lt;br&gt;&lt;br&gt;　　请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。&lt;br&gt;在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。&lt;br&gt;&lt;br&gt;进阶:如果多次调用这个函数，你将如何优化你的算法？&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>pthread_key_create</title>
    <link href="http://example.com/2021/03/26/pthread-key-create/"/>
    <id>http://example.com/2021/03/26/pthread-key-create/</id>
    <published>2021-03-26T09:24:18.000Z</published>
    <updated>2021-03-30T13:39:09.238Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在工作中重新深入认识了一个函数pthread_key_create。深入挖掘该函数源码，才发现这就是java中的ThreadLocal。&lt;br&gt;&lt;br&gt;其实这就是线程本地变量的概念。因为在多线程的程序中，线程是共享程序中的全局变量的。而对于线程本地变量，每一个变量是拥有该全局变量的一个副本，各线程对该变量的修改是线程内可见，线程间不影响。&lt;/p&gt;
&lt;h3 id=&quot;pthread-key-create&quot;&gt;&lt;a href=&quot;#pthread-key-create&quot; class=&quot;headerlink&quot; title=&quot;pthread_key_create&quot;&gt;&lt;/a&gt;pthread_key_create&lt;/h3&gt;&lt;p&gt;函数声明：&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int pthread_key_create(pthread_key_t *key, void &lt;span class=&quot;comment&quot;&gt;(*destructor)(void*)&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数1：pthread_key_t *key，pthread_key_create函数从 TSD ((Thread-specific Data) 池中分配一项，将其地址值赋给 key 供以后访问使用。&lt;br&gt;&lt;br&gt;参数2：是一个清理函数，用来在线程退出(调用 pthread_exit() 函数)时将以 key 锁关联的数据作为参数调用它，以释放分配的缓冲区，或是关闭文件流等。该函数指针可以设成 NULL，这样系统将调用默认的清理函数。该函数成功返回0.其他任何返回值都表示出现了错误。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
